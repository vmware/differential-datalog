typedef AMethod = AMethod{a1: Symbol, a2: Symbol}
typedef Address = Address{addr: ip_addr_t}
typedef Adjusted = Adjusted{id: bigint, alloc: std.Vec<(string, bit<32>)>}
typedef Aggregate1 = Aggregate1{x: string, cnt: bit<64>}
typedef Aggregate2 = Aggregate2{x: string, set: std.Set<string>}
typedef Aggregate3 = Aggregate3{x: string, vec: std.Vec<string>}
typedef Aggregate4 = Aggregate4{x: string, map: std.Map<string,string>}
typedef AggregateByX = AggregateByX{x: string, cnt: bit<64>}
typedef AggregateCnt = AggregateCnt{cnt: bit<64>}
typedef AggregateCnt2 = AggregateCnt2{cnt: bit<64>}
typedef AggregateCnt3 = AggregateCnt3{cnt: bit<64>}
typedef AggregateMe1 = AggregateMe1{x: string, y: string}
typedef AggregateMe3 = AggregateMe3{x: string, y: string, z: string}
typedef AggregateMeInts = AggregateMeInts{x: string, y: bit<32>}
typedef Alloc = Alloc{id: bigint, allocated: std.Map<string,bit<32>>, toallocate: std.Vec<string>, min_val: bit<32>, max_val: bit<32>}
typedef Allocated = Allocated{name: string, xs: std.Set<bit<32>>}
typedef Allocation = Allocation{name: string, id: string, x: bit<32>}
typedef Alt = C0{x: bit<32>} | C1{x: bit<32>}
typedef Answer = Answer{x: station}
typedef Arithm = Arithm{n: bit<32>}
typedef BMethod = BMethod{b1: Symbol, b2: Symbol}
typedef Blacklist = Blacklist{addr: ip_addr_t}
typedef C = C{f1: string, f2: string}
typedef CMethod = CMethod{c1: Symbol, c2: Symbol}
typedef Cast_bigint = Cast_bigint{description: string, expected: bigint, actual: bigint}
typedef Cast_s32 = Cast_s32{description: string, expected: signed<32>, actual: signed<32>}
typedef Cast_u24 = Cast_u24{description: string, expected: bit<24>, actual: bit<24>}
typedef Cast_u256 = Cast_u256{description: string, expected: bit<256>, actual: bit<256>}
typedef Cast_u32 = Cast_u32{description: string, actual: bit<32>, expected: bit<32>}
typedef ConcatString = ConcatString{s: string}
typedef DMethod = DMethod{c1: Symbol, c2: Symbol}
typedef DdlogBinding = DdlogBinding{tn: tnid_t, entity: entid_t}
typedef DdlogDependency = DdlogDependency{parent: entid_t, child: entid_t}
typedef DdlogNode = DdlogNode{id: entid_t}
typedef Disaggregate = Disaggregate{x: string, y: string}
typedef Edge = Edge{from: bigint, to: bigint}
typedef ExternalId = ExternalId{host: bit<64>, id: (string, string)}
typedef ExternalIds = ExternalIds{host: bit<64>, ids: std.Map<string,string>}
typedef Filtered = Filtered{r: std.Ref<Referenced>}
typedef Filtered2 = Filtered2{r: std.Ref<Referee2>}
typedef FooStruct = Option1{f1: bigint, f2: IPAddr, f3: (bool, string)} | Option2{f4: bit<32>, f5: IPAddr}
typedef Gangster = Gangster{nickname: string, name: string}
typedef HostAddress = HostAddress{host: bit<64>, addr: string}
typedef HostAddresses = HostAddresses{host: bit<64>, addrs: std.Set<string>}
typedef Human = Human{h: person}
typedef IConcatString = IConcatString{s: intern.IString}
typedef IP4Addr = bit<32>
typedef IP4Subnet = IP4Subnet{addr: IP4Addr, mask: bit<32>}
typedef IP6Addr = bit<128>
typedef IPAddr = IP4{ip4: IP4Addr} | IP6{ip6: IP6Addr}
typedef IString1 = IString1{s: intern.IString}
typedef Innocent = Innocent{name: string}
typedef J = J{b: bool}
typedef Links = Links{l: line, s1: station, s2: station}
typedef NewAllocation = NewAllocation{id: bigint, alloc: std.Vec<(string, bit<32>)>}
typedef NewAllocationOpt = NewAllocationOpt{id: bigint, alloc: std.Vec<(string, std.Option<bit<32>>)>}
typedef Numbers = Numbers{x: bigint}
typedef Parent = Parent{child: person, parent: person}
typedef Power3 = Power3{y: bigint}
typedef R1 = bigint
typedef R13 = R13{t: t13}
typedef R14 = R14{t: t11}
typedef R1_nl = R1_nl{a1: string}
typedef R2_nl = R2_nl{a2: string}
typedef R3 = R3{f1: bigint, f2: bool}
typedef R3_nl = R3_nl{a3: string, b3: string}
typedef R4_nl = R4_nl{a4: string, b4: string}
typedef R6 = R6{f: bigint}
typedef R7 = R7{f1: bigint, f2: bit<16>} | R7Other{}
typedef Re = Re{_x: Tnumber, _t: Ttxt, _y: Tnumber}
typedef Reach = Reach{s1: station, s2: station}
typedef Realized = Realized{name: string, id: string, x: bit<32>}
typedef Referee = Referee{r: std.Ref<Referenced>}
typedef Referee2 = Referee2{r: Referenced}
typedef Referenced = Referenced{x: bool, y: std.Option<string>}
typedef Regex = Regex{regex: string, text: string}
typedef RegexMatch = RegexMatch{regex: string, text: string, m: bool}
typedef Rel1 = Rel1{x: bigint, y: IPAddr}
typedef Rel2 = Rel2{x: bigint, z: FooStruct}
typedef Rel3 = Rel3{x: bigint, y: IPAddr, z: FooStruct}
typedef Rel4 = Rel4{x: bigint, y: IPAddr, b: bool}
typedef Request = Request{name: string, id: string}
typedef Ris_true = Ris_true{_s: TB}
typedef S = S{f1: (bool, bool), f2: bit<32>}
typedef SetOfSet = SetOfSet{x: std.Set<std.Set<bool>>}
typedef Sib = Sib{s1: person, s2: person}
typedef Signed = Signed{n: signed<32>}
typedef Signed16 = Signed16{x: signed<16>}
typedef Signed64 = Signed64{x: signed<64>}
typedef Signed8 = Signed8{x: signed<8>}
typedef Span = Span{entity: entid_t, tns: std.Set<tnid_t>}
typedef String2 = String2{s: string}
typedef StringOrd = StringOrd{s: string, ord: bit<32>}
typedef Strings = Strings{s: string}
typedef Sum = Sum{x: string, sum: bit<32>}
typedef Suspect = Suspect{name: string}
typedef Symbol = intern.IString
typedef T = T{x: bigint, y: string}
typedef T1 = C11{f1: bigint, f2: (bigint, string)} | C12{f3: bit<32>, f4: (bool, bool, bool)}
typedef T16 = t15
typedef T17 = bigint
typedef T2 = C21{f1: T1, f2: bigint} | C22{f3: (bool, T1)}
typedef T3 = C31{f1: T1, f2: bigint, s: string, b: bit<32>} | C32{f3: ((bool, (bool, bool, bool)), T1)}
typedef TB = intern.IString
typedef Table1 = Table1{id: bit<64>, name: string}
typedef Table12 = Table12{id: bit<128>, name: string, f3: S}
typedef Table2 = Table2{name: string, f2: bigint, f3: S}
typedef Tnumber = bit<32>
typedef ToAllocate = ToAllocate{name: string, ids: std.Vec<string>}
typedef Tsymbol = intern.IString
typedef Ttxt = intern.IString
typedef UMinus_bigint = UMinus_bigint{description: string, n: bigint}
typedef UMinus_s32 = UMinus_s32{description: string, n: signed<32>}
typedef ValidDestination = ValidDestination{addr: ip_addr_t}
typedef VecTest = VecTest{x: std.Vec<string>}
typedef W = W{f1: bigint, f2: bigint, f3: bigint}
typedef WithKey = WithKey{key: bit<128>, val: string}
typedef WithKeyDbg = WithKeyDbg{key: bit<128>, val: string}
typedef X = X{field: bigint}
typedef XX = XX{b: bigint, c: R3, d: R1}
typedef XY = XY{x: bigint, y: bigint}
typedef Y = Y{b: bigint, e: string}
typedef YX = YX{y: bigint, x: bigint}
typedef YZX = YZX{y: bigint, z: bigint, x: bigint}
typedef Z = Z{field: bigint}
typedef ZZ = ZZ{x: bigint, y: R3}
typedef entid_t = bit<32>
#[size = 4]
extern type intern.IObj<'A>
typedef intern.IString = intern.IObj<string>
typedef ip_addr_t = IPAddr{b3: bit<8>, b2: bit<8>, b1: bit<8>, b0: bit<8>}
typedef line = bigint
typedef log.log_level_t = signed<32>
typedef log.module_t = signed<32>
typedef nested_t = N{field: C}
typedef person = string
typedef serializable_t = ConsInt{x: bigint} | ConsBit{y: bit<32>} | ConsBool{z: bool} | Cons0{}
typedef souffle_types.TEmtpy = ()
typedef souffle_types.Tnumber = signed<32>
typedef souffle_types.Tsymbol = intern.IString
typedef station = string
typedef std.Either<'A,'B> = std.Left{l: 'A} | std.Right{r: 'B}
extern type std.Group<'A>
extern type std.Map<'K,'V>
typedef std.Option<'A> = std.Some{x: 'A} | std.None{}
#[size = 8]
extern type std.Ref<'A>
extern type std.Set<'A>
extern type std.Vec<'A>
typedef string_syn = string
typedef t00 = bigint
typedef t01 = bool
typedef t02 = string
typedef t03 = bit<32>
typedef t04 = bigint
typedef t05 = (bigint, bigint)
typedef t06 = (bigint, bigint, bigint)
typedef t07 = ()
typedef t08 = ((), (), ())
typedef t09 = (bigint, (), bigint)
typedef t10 = (bigint, bool, string, bit<32>)
typedef t11 = (bigint, (bool, (string, bit<32>)))
typedef t12 = t11
typedef t13 = (t00, t01, t02, t03)
typedef t14 = (t04, t04)
typedef t15 = Const15{f: bigint}
typedef t18 = Const18{f0: bigint, f1: string, f2: t00}
typedef t19 = C000{f0: bigint} | C111{f0: bigint} | C222{f0: bigint}
typedef t20 = signed<32>
typedef tnid_t = bit<16>
function a0 (): bigint =
    1
function a1 (): bigint =
    (1 + 2)
function a10 (): signed<32> =
    (32'sd0 + 32'sd1)
function a11 (): signed<32> =
    (32'sd0: signed<32>)
function a12 (a: signed<16>, b: signed<16>): signed<16> =
    (((((a + b) + (a - b)) + (a / b)) + (a * b)) + (a % b))
function a13 (a: signed<16>, b: signed<16>): bool =
    (((((((a < b) or (a > b)) or (a <= b)) or (a >= b)) or (a == b)) or (a != b)) or (a < b))
function a2 (): bit<32> =
    (32'd0 + 32'd1)
function a3 (): bit<32> =
    (32'd0: bit<32>)
function a4 (): bit<32> =
    (64'd0: bit<64>)[40:9]
function a5 (a: bit<32>, b: bit<32>): bit<32> =
    ((((((a & b) | (a | b)) | (~ a)) | (a << 32'd5)) | (a >> 32'd5)) | (a[15:0] ++ a[31:16]))
function a6 (a: bit<16>, b: bit<16>): bit<16> =
    (((((a + b) + (a - b)) + (a / b)) + (a * b)) + (a % b))
function a7 (a: bit<16>, b: bit<16>): bool =
    (((((((a < b) or (a > b)) or (a <= b)) or (a >= b)) or (a == b)) or (a != b)) or (a < b))
function a8 (): bit<32> =
    (((32'd125 | 32'd255) | 32'd511) | 32'd683)
function a9 (): bit<32> =
    (((32'd125 | 32'd255) | 32'd511) | 32'd683)
extern function allocate.adjust_allocation (allocated: std.Map<'A,'N>, toallocate: std.Vec<'A>, min_val: 'N, max_val: 'N): std.Vec<('A, 'N)>
extern function allocate.allocate (allocated: std.Set<'N>, toallocate: std.Vec<'B>, min_val: 'N, max_val: 'N): std.Vec<('B, 'N)>
extern function allocate.allocate_opt (allocated: std.Set<'N>, toallocate: std.Vec<'B>, min_val: 'N, max_val: 'N): std.Vec<('B, std.Option<'N>)>
extern function allocate.allocate_with_hint (allocated: std.Set<'N>, toallocate: std.Vec<('B, std.Option<'N>)>, min_val: 'N, max_val: 'N): std.Vec<('B, 'N)>
function b0 (): bool =
    (true and false)
function b1 (a: bool): bool =
    ((((a and true) or (a or false)) or (a => false)) or (not a))
function c0 (a: bit<32>, b: bit<16>): bit<16> =
    (a;
     b)
function dummy (x: string): string =
    (x ++ " dummy")
function edge_from (e: Edge): bigint =
    e.from
function edge_to (e: Edge): bigint =
    e.to
extern function f (): bigint
function f1 (x: T1, y: T2, q: T3): bool =
    (match (x) {
         C11{.f1=_, .f2=_} -> true,
         _ -> false
     };
     (match (x) {
          C11{.f1=_, .f2=_} -> true,
          C12{.f3=_, .f4=_} -> false
      };
      (match (y) {
           C21{.f1=_, .f2=_} -> true,
           C22{.f3=(_, C11{.f1=_, .f2=_})} -> true,
           _ -> false
       };
       (match (y) {
            C21{.f1=_, .f2=_} -> true,
            C22{.f3=(true, C11{.f1=_, .f2=_})} -> true,
            C22{.f3=(true, C12{.f3=_, .f4=_})} -> true,
            C22{.f3=(false, C11{.f1=_, .f2=_})} -> true,
            C22{.f3=(false, C12{.f3=_, .f4=_})} -> true
        };
        ((var z: (bool, (bool, (bool, bool)))) = (true, (false, (true, false)));
         (match (z) {
              (true, _) -> true,
              (false, (_, (true, true))) -> true,
              (false, (_, (true, false))) -> true,
              (false, (_, (false, true))) -> true,
              (false, (_, (false, false))) -> true
          };
          (match (z) {
               (_, (_, (true, true))) -> true,
               (_, (_, (true, false))) -> true,
               (_, (_, (false, true))) -> true,
               (false, (_, (false, false))) -> true,
               (true, (_, (false, false))) -> true
           };
           (match (q) {
                C31{.f1=_, .f2=_, .s=_, .b=_} -> true,
                C32{.f3=((true, (_, _, false)), _)} -> true,
                C32{.f3=((false, (_, _, false)), _)} -> true,
                C32{.f3=((false, (_, _, true)), _)} -> true,
                C32{.f3=((_, (_, _, true)), C11{.f1=_, .f2=_})} -> true,
                C32{.f3=((_, (_, _, true)), C12{.f3=_, .f4=(true, true, true)})} -> false,
                C32{.f3=((_, (_, _, true)), C12{.f3=_, .f4=(_, _, false)})} -> false,
                C32{.f3=((_, (_, _, true)), C12{.f3=_, .f4=(_, _, true)})} -> false
            };
            (match (q) {
                 C31{.f1=_, .f2=0, .s="foo", .b=32'd15} -> true,
                 C31{.f1=_, .f2=_, .s=_, .b=32'd15} -> true,
                 C31{.f1=_, .f2=0, .s=_, .b=_} -> true,
                 C31{.f1=_, .f2=_, .s="foo", .b=_} -> true,
                 C32{.f3=_} -> true,
                 C31{.f1=_, .f2=_, .s=_, .b=_} -> true
             };
             ((var s: string) = "bar";
              match (s) {
                  "foo" -> true,
                  "bar" -> true,
                  _ -> false
              }))))))))))
function fnested (x: nested_t): string =
    (N{.field=C{.f1=var res, .f2=_}} = x;
     res)
function foo (): bool =
    ((var v1: bigint) = 0;
     ((var v2: bit<32>) = 32'd1;
      ((var v3: bit<129>) = 129'd0;
       ((var v4: bool) = true;
        ((var v5: (bigint, string)) = (0, "test_string");
         (var v6 = IP4{.ip4=32'd2864434397};
          (var v7 = Option1{.f1=0, .f2=IP4{.ip4=32'd0}, .f3=(true, "bar")};
           (v3 = (v3 + 129'd703710);
            (match (v6) {
                 IP4{.ip4=_} -> true,
                 _ -> false
             };
             match (v7) {
                 Option1{.f1=_, .f2=IP6{.ip6=_}, .f3=(_, "bar")} -> true,
                 _ -> false
             })))))))))
extern function g (a: bigint): bigint
extern function h (a: (bigint, bigint)): (bigint, bigint)
extern function intern.istring_ord (s: intern.IString): bit<32>
extern function intern.istring_str (s: intern.IString): string
extern function intern.string_intern (s: string): intern.IString
extern function log.log (module: log.module_t, level: log.log_level_t, msg: string): bool
extern function parameterized (x: 'A, y: 'A): 'A
function parameterized2 (x: 'A, y: 'A): bool =
    (x == y)
function patterns (): () =
    ((var a: Alt) = C0{.x=32'd1};
     (var b = match (a) {
                  C0{.x=_} -> true,
                  C1{.x=_} -> false
              };
      (var i: bit<32>) = match (a) {
                             C0{.x=var v} -> v,
                             C1{.x=var v} -> v
                         }))
extern function regex.regex_match (regex: string, str: string): bool
function s0 (): string =
    "Some string"
function s1 (): string =
    "\t\r\n\"\\\a"
function serializable_t2string (x: serializable_t): string =
    match (x) {
        ConsInt{.x=var v} -> (("ConsInt(" ++ std.__builtin_2string(v)) ++ ")"),
        ConsBit{.y=var v} -> (("ConsBool(" ++ std.__builtin_2string(v)) ++ ")"),
        ConsBool{.z=true} -> "ConsBool(true)",
        ConsBool{.z=false} -> "ConsBool(false)",
        Cons0{} -> "Cons0"
    }
function shadow (): string =
    ((var b: std.Option<string>) = std.None{};
     (var a = std.Some{.x="foo"};
      match (a) {
          std.Some{.x=var v} -> v,
          std.None{} -> ""
      }))
function souffle_lib.castTo32 (i: bit<64>): souffle_types.Tnumber =
    (i[31:0] as souffle_types.Tnumber)
function souffle_lib.castTo64 (i: souffle_types.Tnumber): bit<64> =
    (32'd0 ++ (i as bit<32>))
function souffle_lib.cat (s: intern.IString, t: intern.IString): intern.IString =
    intern.string_intern((intern.istring_str(s) ++ intern.istring_str(t)))
function souffle_lib.contains (s: intern.IString, i: intern.IString): bool =
    std.string_contains(intern.istring_str(i), intern.istring_str(s))
function souffle_lib.group_count32 (g: std.Group<'A>): souffle_types.Tnumber =
    souffle_lib.castTo32(std.group_count(g))
function souffle_lib.land (l: souffle_types.Tnumber, r: souffle_types.Tnumber): souffle_types.Tnumber =
    if ((l != 32'sd0) and (r != 32'sd0)) {
        32'sd1
    } else {
          32'sd0
      }
function souffle_lib.lnot (l: souffle_types.Tnumber): souffle_types.Tnumber =
    if (l != 32'sd0) {
        32'sd0
    } else {
          32'sd1
      }
function souffle_lib.lor (l: souffle_types.Tnumber, r: souffle_types.Tnumber): souffle_types.Tnumber =
    if ((l == 32'sd0) and (r == 32'sd0)) {
        32'sd0
    } else {
          32'sd1
      }
function souffle_lib.ord (s: intern.IString): souffle_types.Tnumber =
    (intern.istring_ord(s) as souffle_types.Tnumber)
function souffle_lib.random (): souffle_types.Tnumber =
    32'sd0
function souffle_lib.re_match (pattern: intern.IString, s: intern.IString): bool =
    regex.regex_match((("^" ++ intern.istring_str(pattern)) ++ "$"), intern.istring_str(s))
function souffle_lib.strlen (s: intern.IString): souffle_types.Tnumber =
    souffle_lib.castTo32(std.string_len(intern.istring_str(s)))
function souffle_lib.substr (s: intern.IString, i: souffle_types.Tnumber, l: souffle_types.Tnumber): intern.IString =
    intern.string_intern(std.string_substr(intern.istring_str(s), souffle_lib.castTo64(i), souffle_lib.castTo64((i + l))))
function souffle_lib.to_number (s: intern.IString): souffle_types.Tnumber =
    match (std.parse_dec_i64(intern.istring_str(s))) {
        std.None{} -> 32'sd0,
        std.Some{.x=var x} -> (x as souffle_types.Tnumber)
    }
function souffle_lib.to_string (n: souffle_types.Tnumber): intern.IString =
    intern.string_intern(std.__builtin_2string(n))
extern function std.__builtin_2string (x: 'X): string
extern function std.deref (x: std.Ref<'A>): 'A
extern function std.group2map (g: std.Group<('K, 'V)>): std.Map<'K,'V>
extern function std.group2set (g: std.Group<'A>): std.Set<'A>
extern function std.group2vec (g: std.Group<'A>): std.Vec<'A>
extern function std.group_count (g: std.Group<'A>): bit<64>
extern function std.group_first (g: std.Group<'A>): 'A
extern function std.group_max (g: std.Group<'A>): 'A
extern function std.group_min (g: std.Group<'A>): 'A
extern function std.group_nth (g: std.Group<'A>, n: bit<64>): std.Option<'A>
extern function std.group_set_unions (g: std.Group<std.Set<'A>>): std.Set<'A>
extern function std.group_setref_unions (g: std.Group<std.Ref<std.Set<'A>>>): std.Ref<std.Set<'A>>
extern function std.group_sum (g: std.Group<'A>): 'A
function std.group_unzip (g: std.Group<('X, 'Y)>): (std.Vec<'X>, std.Vec<'Y>) =
    ((var xs: std.Vec<'X>) = std.vec_empty();
     ((var ys: std.Vec<'Y>) = std.vec_empty();
      (for (v in g) {
           ((var x, var y) = v;
            (std.vec_push(xs, x);
             std.vec_push(ys, y)))
       };
       (xs, ys))))
extern function std.hash128 (x: 'X): bit<128>
extern function std.hash64 (x: 'X): bit<64>
extern function std.hex (x: 'X): string
extern function std.htonl (x: bit<32>): bit<32>
extern function std.htons (x: bit<16>): bit<16>
function std.is_none (x: std.Option<'A>): bool =
    match (x) {
        std.None{} -> true,
        _ -> false
    }
function std.is_some (x: std.Option<'A>): bool =
    match (x) {
        std.Some{.x=_} -> true,
        _ -> false
    }
extern function std.map_contains_key (m: std.Map<'K,'V>, k: 'K): bool
extern function std.map_empty (): std.Map<'K,'V>
extern function std.map_get (m: std.Map<'K,'V>, k: 'K): std.Option<'V>
extern function std.map_insert (m: mut std.Map<'K,'V>, k: 'K, v: 'V): ()
extern function std.map_insert_imm (m: std.Map<'K,'V>, k: 'K, v: 'V): std.Map<'K,'V>
extern function std.map_is_empty (m: std.Map<'K,'V>): bool
extern function std.map_remove (m: mut std.Map<'K,'V>, k: 'K): ()
extern function std.map_singleton (k: 'K, v: 'V): std.Map<'K,'V>
extern function std.map_union (m1: std.Map<'K,'V>, m2: std.Map<'K,'V>): std.Map<'K,'V>
extern function std.max (x: 'A, y: 'A): 'A
extern function std.min (x: 'A, y: 'A): 'A
extern function std.ntohl (x: bit<32>): bit<32>
extern function std.ntohs (x: bit<16>): bit<16>
extern function std.parse_dec_i64 (s: string): std.Option<signed<64>>
extern function std.parse_dec_u64 (s: string): std.Option<bit<64>>
extern function std.pow32 (base: 'A, exp: bit<32>): 'A
extern function std.range (from: 'A, to: 'A, step: 'A): std.Vec<'A>
extern function std.ref_new (x: 'A): std.Ref<'A>
extern function std.set2vec (s: std.Set<'A>): std.Vec<'A>
extern function std.set_contains (s: std.Set<'X>, v: 'X): bool
extern function std.set_empty (): std.Set<'X>
extern function std.set_insert (s: mut std.Set<'X>, v: 'X): ()
extern function std.set_insert_imm (s: std.Set<'X>, v: 'X): std.Set<'X>
extern function std.set_is_empty (s: std.Set<'X>): bool
extern function std.set_nth (s: std.Set<'X>, n: bit<64>): std.Option<'X>
extern function std.set_singleton (x: 'X): std.Set<'X>
extern function std.set_size (s: std.Set<'X>): bit<64>
extern function std.set_union (s1: std.Set<'X>, s2: std.Set<'X>): std.Set<'X>
extern function std.set_unions (sets: std.Vec<std.Set<'X>>): std.Set<'X>
extern function std.str_to_lower (s: string): string
extern function std.string_contains (s1: string, s2: string): bool
extern function std.string_join (strings: std.Vec<string>, sep: string): string
extern function std.string_len (s: string): bit<64>
extern function std.string_split (s: string, sep: string): std.Vec<string>
extern function std.string_substr (s: string, start: bit<64>, end: bit<64>): string
extern function std.vec2set (s: std.Vec<'A>): std.Set<'A>
extern function std.vec_contains (v: std.Vec<'X>, x: 'X): bool
extern function std.vec_empty (): std.Vec<'A>
extern function std.vec_is_empty (v: std.Vec<'X>): bool
extern function std.vec_len (v: std.Vec<'X>): bit<64>
extern function std.vec_nth (v: std.Vec<'X>, n: bit<64>): std.Option<'X>
extern function std.vec_push (v: mut std.Vec<'X>, x: 'X): ()
extern function std.vec_push_imm (v: std.Vec<'X>, x: 'X): std.Vec<'X>
extern function std.vec_singleton (x: 'X): std.Vec<'X>
function strings (): () =
    (var str1 = ("foo" ++ "bar");
     (var str2 = ((("foobar" ++ "buzz") ++ "\nraw string ") ++ "quoted string");
      (var str3 = ("str1: " ++ str1);
       (var str4 = (((((("str1: " ++ str1) ++ ", str2: ") ++ str2) ++ ", str3: ") ++ str3) ++ ".");
        (var str5 = [|str1: ${str1},
str2: ${str2},
str3: ${str3}.|];
         (var str6 = ("" ++ (str1 ++ str2));
          (var str7 = ("" ++ (var x = (str1 ++ str2);
                              x));
           (var str8 = ("" ++ (var x = (str1 ++ str2);
                               dummy(x)));
            ()))))))))
function tostring1 (): () =
    ((var a: bigint) = 5;
     ((var b: bit<32>) = 32'd5;
      ((var c: bool) = true;
       ((var d: string) = "foo";
        (var err = ((((((("a=" ++ std.__builtin_2string(a)) ++ ", b=") ++ std.__builtin_2string(b)) ++ ", c=") ++ std.__builtin_2string(c)) ++ ", d=") ++ d);
         ())))))
function tostring2 (): () =
    ((var a: bigint) = 5;
     ((var b: bit<32>) = 32'd5;
      ((var c: bool) = true;
       ((var d: string) = "foo";
        ((var e: serializable_t) = ConsInt{.x=0};
         (var err = ((((((((("a=" ++ std.__builtin_2string(a)) ++ ", b=") ++ std.__builtin_2string(b)) ++ ", c=") ++ std.__builtin_2string(c)) ++ ", d=") ++ d) ++ ", e:") ++ serializable_t2string(e));
          ()))))))
function use_parameterized (x: string, y: string_syn): string =
    parameterized(x, y)
function v (): string =
    ((var v1: string) = "hello";
     (var v2 = "there";
      v2))
function v2 (): bool =
    b1(true)
function vars (): () =
    ((var x: bigint) = 0;
     (x = 10;
      (var y = C{.f1="foo", .f2="bar"};
       ((var z: C) = C{.f1="bar", .f2="foo"};
        ((var a, var b) = ((x + 5), (x - 5));
         (C{.f1=var e, .f2=_} = y;
          C{.f1=var c, .f2=var d} = y))))))
function x (): Alt =
    C0{.x=32'd5}
extern transformer graph.ConnectedComponents(Edges: relation['E], from: function(e: 'E): 'N, to: function(e: 'E): 'N) -> (CCLabels: relation[('N, 'N)])
extern transformer graph.ConnectedComponents64(Edges: relation['E], from: function(e: 'E): 'N, to: function(e: 'E): 'N) -> (CCLabels: relation[('N, 'N)])
extern transformer graph.SCC(Edges: relation['E], from: function(e: 'E): 'N, to: function(e: 'E): 'N) -> (SCCLabels: relation[('N, 'N)])
extern transformer graph.UnsafeBidirectionalEdges(Edges: relation['E], from: function(e: 'E): 'N, to: function(e: 'E): 'N) -> (BiEdges: relation[('N, 'N)])
input relation AMethod [AMethod]
input relation Address [Address]
output relation Adjusted [Adjusted]
output relation Aggregate1 [Aggregate1]
output relation Aggregate2 [Aggregate2]
output relation Aggregate3 [Aggregate3]
output relation Aggregate4 [Aggregate4]
output relation AggregateByX [AggregateByX]
output relation AggregateCnt [AggregateCnt]
output relation AggregateCnt2 [AggregateCnt2]
output relation AggregateCnt3 [AggregateCnt3]
input relation AggregateMe1 [AggregateMe1]
input relation AggregateMe3 [AggregateMe3]
input relation AggregateMeInts [AggregateMeInts]
input relation Alloc [Alloc]
relation Allocated [Allocated]
output relation Allocation [Allocation]
output relation Answer [Answer]
output relation Arithm [Arithm]
input relation BMethod [BMethod]
input relation Blacklist [Blacklist]
output relation CMethod [CMethod]
output relation Cast_bigint [Cast_bigint]
output relation Cast_s32 [Cast_s32]
output relation Cast_u24 [Cast_u24]
output relation Cast_u256 [Cast_u256]
output relation Cast_u32 [Cast_u32]
output relation ConcatString [ConcatString]
output relation DMethod [DMethod]
input relation DdlogBinding [DdlogBinding]
input relation DdlogDependency [DdlogDependency]
input relation DdlogNode [DdlogNode]
output relation Disaggregate [Disaggregate]
input relation Edge [Edge]
output relation ExternalId [ExternalId]
input relation ExternalIds [ExternalIds]
output relation Filtered [Filtered]
output relation Filtered2 [Filtered2]
input relation Gangster [Gangster]
output relation HostAddress [HostAddress]
input relation HostAddresses [HostAddresses]
input relation Human [Human]
relation IConcatString [IConcatString]
input relation IString1 [IString1]
output relation Innocent [Innocent]
output relation J [J]
input relation Links [Links]
output relation NewAllocation [NewAllocation]
output relation NewAllocationOpt [NewAllocationOpt]
input relation Numbers [Numbers]
input relation Parent [Parent]
output relation Power3 [Power3]
input relation R1 [R1]
relation R13 [R13]
relation R14 [R14]
input relation R1_nl [R1_nl]
input relation R2 [(bigint, bigint)]
relation R2_nl [R2_nl]
input relation R3 [R3]
relation R3_nl [R3_nl]
output relation R4 [R3]
relation R4_nl [R4_nl]
output relation R5 [bigint]
output relation R6 [R6]
output relation R7 [R7]
input relation R8 [bit<32>]
relation Re [Re]
output relation Reach [Reach]
input relation Realized [Realized]
output relation Referee [Referee]
output relation Referee2 [std.Ref<Referee2>]
input relation Referenced [Referenced]
input relation Regex [Regex]
output relation RegexMatch [RegexMatch]
input relation Rel1 [Rel1]
input relation Rel2 [Rel2]
output relation Rel3 [Rel3]
output relation Rel4 [Rel4]
input relation Request [Request]
relation Ris_true [Ris_true]
output relation SCCLabel [(bigint, bigint)]
input relation SetOfSet [SetOfSet]
output relation Sib [Sib]
output relation Signed [Signed]
input relation Signed16 [Signed16]
input relation Signed64 [Signed64]
input relation Signed8 [Signed8]
output relation Span [Span]
input relation String2 [String2]
output relation StringOrd [StringOrd]
input relation Strings [Strings]
output relation Sum [Sum]
input relation Suspect [Suspect]
output relation T [T]
input relation Table1 [Table1]
output relation Table12 [Table12]
input relation Table2 [Table2]
relation ToAllocate [ToAllocate]
output relation UMinus_bigint [UMinus_bigint]
output relation UMinus_s32 [UMinus_s32]
output relation ValidDestination [ValidDestination]
output relation VecTest [VecTest]
output relation W [W]
input relation WithKey [WithKey] primary key (x) x.key
output relation WithKeyDbg [WithKeyDbg]
input relation X [X]
input relation XX [XX]
input relation XY [XY]
input relation Y [Y]
output relation YX [YX]
input relation YZX [YZX]
output relation Z [Z]
output relation ZZ [ZZ]
Sib(.s1=x, .s2=y) :- Parent(.child=x, .parent=z), Parent(.child=y, .parent=z), (x != y).
Parent(.child="Alice", .parent="Bob").
Parent(.child="Ben", .parent="Bob").
Parent(.child="Bob", .parent="Bob").
VecTest(.x=std.vec_empty()).
VecTest(.x=((var v: std.Vec<string>) = std.vec_empty();
            (std.vec_push(v, "Hello,");
             v))).
VecTest(.x=std.vec_push_imm(std.vec_push_imm((std.vec_empty(): std.Vec<string>), "Hello, "), "world!")).
Reach(.s1=x, .s2=y) :- Links(.l=l, .s1=x, .s2=y).
Reach(.s1=x, .s2=y) :- Links(.l=l, .s1=y, .s2=x).
Reach(.s1=x, .s2=y) :- Links(.l=l, .s1=x, .s2=z), Reach(.s1=z, .s2=y).
Answer(.x=x) :- Reach(.s1="Odeon", .s2=x).
Z(.field=a.field) :- X[(a@ X{.field=_})].
Z(.field=a.field) :- X[a].
Z(.field=a.field) :- X[(a@ X{.field=_})], match (a.field) {
                                              1 -> true,
                                              2 -> false,
                                              _ -> false
                                          }.
Z(.field=(a.field + 1)) :- X[(a@ X{.field=_})], match (a.field) {
                                                    1 -> false,
                                                    2 -> true,
                                                    _ -> false
                                                }.
Z(.field=(a.field - 1)) :- X[(a@ X{.field=_})], match (a.field) {
                                                    1 -> false,
                                                    2 -> false,
                                                    _ -> true
                                                }.
Z(.field=a) :- X(.field=a), match (a) {
                                1 -> true,
                                2 -> false,
                                _ -> false
                            }.
Z(.field=(a + 1)) :- X(.field=a), match (a) {
                                      1 -> false,
                                      2 -> true,
                                      _ -> false
                                  }.
Z(.field=(a - 1)) :- X(.field=a), match (a) {
                                      1 -> false,
                                      2 -> false,
                                      _ -> true
                                  }.
Z(.field=a) :- X(.field=a), match (a) {
                                1 -> true,
                                _ -> false
                            }.
Z(.field=(a + 1)) :- X(.field=a), match (a) {
                                      1 -> false,
                                      2 -> true,
                                      _ -> false
                                  }.
Z(.field=(a - 1)) :- X(.field=a), match (a) {
                                      1 -> false,
                                      2 -> false,
                                      _ -> true
                                  }.
Z(.field=a.field) :- X[(a@ X{.field=_})], ((a.field % 2) == 0).
Z(.field=a.field) :- X[(a@ X{.field=_})], ((a.field % 2) == 0).
Z(.field=a) :- X(.field=a), ((a % 2) == 0).
Z(.field=(a.field + 1)) :- X[(a@ X{.field=_})], (a.field == 2).
Z(.field=a.field) :- X[(a@ X{.field=_})], (not (a.field == 2)).
Z(.field=(a + 1)) :- X(.field=a), (a == 2).
Z(.field=a) :- X(.field=a), (a != 1).
Z(.field=a.field) :- X[(a@ X{.field=_})], (a.field >= 2), (a.field > 2).
Z(.field=(a.field + 2)) :- X[(a@ X{.field=_})], (a.field >= 2), (a.field > 2).
Z(.field=a) :- X(.field=a), (a >= 2), (a > 2).
Z(.field=(a + 2)) :- X(.field=a), (a >= 2), (a > 2).
Z(.field=(a.field + b.field)) :- X[(a@ X{.field=_})], X[(b@ X{.field=_})].
Z(.field=(a.field + c.field)) :- X[(a@ X{.field=_})], X[(c@ X{.field=_})].
Z(.field=(a + b)) :- X(.field=a), X(.field=b).
Z(.field=(a + c)) :- X(.field=a), X(.field=c).
Z(.field=(a + b)),
Z(.field=(a + c)) :- X(.field=a), X(.field=b), X(.field=c).
Z(.field=(a.field + b)) :- X[(a@ X{.field=_})], (var b: bigint) = (a.field + 2).
Z(.field=(a + b)) :- X(.field=a), var b = (a + 2).
W(.f1=a.field, .f2=b, .f3=c) :- X[(a@ X{.field=_})], var b = (a.field + 2), var c = (b + a.field).
W(.f1=a, .f2=b, .f3=c) :- X(.field=a), var b = (a + 2), var c = (b + a).
R1[1].
R2[(1, 2)].
R4[x] :- R3[x].
R5[x.f1] :- R3[x].
R6(.f=x.f1) :- R3[x].
ZZ(.x=a.b, .y=a.c) :- XX[a].
T(.x=a.b, .y=e) :- XX[a], Y(.b=a.d, .e=e).
R7(.f1=1, .f2=16'd2).
R7(.f1=1, .f2=16'd3).
R7[R7Other{}].
Table12(.id=std.hash128((id, name, f2, f3)), .name=name, .f3=f3) :- Table1(.id=id, .name=name), Table2(.name=name, .f2=f2, .f3=f3).
R2_nl(.a2=x) :- R1_nl(.a1=x).
R2_nl(.a2=x) :- R3_nl(.a3=x, .b3=y), R4_nl(.a4=y, .b4=z).
R3_nl(.a3=x, .b3=y),
R4_nl(.a4=x, .b4=y) :- R2_nl(.a2=x), R2_nl(.a2=y).
Strings(.s="").
Strings(.s="foo").
Strings(.s="bar\n").
Strings(.s="\t\tbar").
Strings(.s="\"buzz").
Strings(.s="\r\n\abuzz").
Strings(.s="\\buzz").
Strings(.s="\\buzz").
Strings(.s="bar\916").
Strings(.s="").
Strings(.s="foo").
Strings(.s="foo\nbuzz\nbar").
Strings(.s="\n    foo\n    buzz\n    bar").
Strings(.s="bar\916\n\928").
Strings(.s=("bar\916\n\928" ++ " quoted string")).
Strings(.s="\n    foo\\r\\n\n    buzz\n    bar").
Strings(.s="foo-bar").
Strings(.s="foo\nbar").
Strings(.s="foo\\bar").
Strings(.s=("foo\\" ++ "bar")).
Strings(.s="word1 word2").
Strings(.s="line1\nline2").
Rel3(.x=x, .y=y, .z=z) :- Rel1(.x=x, .y=y), Rel2(.x=x, .z=z).
Rel4(.x=x, .y=y, .b=b) :- Rel1(.x=x, .y=y), Rel2(.x=x, .z=Option1{.f1=_, .f2=IP4{.ip4=_}, .f3=(b, "buzz")}).
Aggregate1(.x=x, .cnt=cnt) :- AggregateMe1(.x=x, .y=y), var cnt = Aggregate((x), std.group_count(y)).
AggregateCnt(.cnt=cnt) :- AggregateMe1(.x=x, .y=y), var cnt = Aggregate((), std.group_count(())).
AggregateCnt2(.cnt=cnt) :- AggregateMe1(.x=x, .y=y), var cnt = Aggregate((), std.group_sum((64'd1: bit<64>))).
AggregateCnt3(.cnt=cnt) :- AggregateMe1(.x=x, .y=y), (y != "1"), var cnt = Aggregate((), std.group_sum((64'd1: bit<64>))).
Aggregate2(.x=x, .set=set) :- AggregateMe1(.x=x, .y=y), var set = Aggregate((x), std.group2set(y)).
Aggregate3(.x=x, .vec=vec) :- AggregateMe1(.x=x, .y=y), var vec = Aggregate((x), std.group2vec(y)).
Aggregate4(.x=x, .map=map) :- AggregateMe1(.x=x, .y=y), var map = Aggregate((x), std.group2map((x, y))).
Disaggregate(.x=x, .y=y) :- AggregateMe1(.x=x, .y=y), var set = Aggregate((x), std.group2set(y)), var y = FlatMap(set).
Sum(.x=x, .sum=sum) :- AggregateMeInts(.x=x, .y=y), var sum = Aggregate((x), std.group_sum(y)).
AggregateByX(.x=x, .cnt=cnt) :- AggregateMe3(.x=x, .y=y, .z=z), AggregateMe1(.x=x, .y=y), var cnt = Aggregate((x), std.group_count(())).
WithKeyDbg(.key=k, .val=v) :- WithKey(.key=k, .val=v).
Innocent(.name=name) :- Suspect(.name=name), not Gangster(.nickname=_, .name=name).
ValidDestination(.addr=addr) :- Address(.addr=addr), IPAddr{.b3=var b3, .b2=var b2, .b1=_, .b0=_} = addr, not Blacklist(.addr=IPAddr{.b3=b3, .b2=b2, .b1=_, .b0=_}).
HostAddress(.host=host, .addr=addr) :- HostAddresses(.host=host, .addrs=addrs), var addr = FlatMap(addrs).
ExternalId(.host=host, .id=id) :- ExternalIds(.host=host, .ids=ids), var id = FlatMap(ids).
Allocation(.name=name, .id=id, .x=x) :- Request(.name=name, .id=id), Realized(.name=name, .id=id, .x=x).
ToAllocate(.name=name, .ids=ids) :- Request(.name=name, .id=id), not Realized(.name=name, .id=id, .x=_), var ids = Aggregate((name), std.group2vec(id)).
Allocated(.name=name, .xs=xs) :- Realized(.name=name, .id=_, .x=x), var xs = Aggregate((name), std.group2set(x)).
Allocation(.name=name, .id=id, .x=x) :- ToAllocate(.name=name, .ids=ids), Allocated(.name=name, .xs=xs), var allocation = FlatMap(allocate.allocate(xs, ids, 32'd1, ((32'd1 << 32'd24) - 32'd1))), (var id, var x) = allocation.
Referee(.r=std.ref_new(r)) :- Referenced[(r@ Referenced{.x=_, .y=std.Some{.x=_}})].
Filtered(.r=r.r) :- Referee[(r@ Referee{.r=(&Referenced{.x=true, .y=_})})].
Referee2[std.ref_new(Referee2{.r=r})] :- Referenced[r].
Filtered2(.r=r) :- Referee2[(r@ (&Referee2{.r=Referenced{.x=true, .y=_}}))].
NewAllocation(.id=id, .alloc=alloc) :- Alloc(.id=id, .allocated=allocated, .toallocate=toallocate, .min_val=min_val, .max_val=max_val), var allocated_nums = ((var allocated_nums: std.Set<bit<32>>) = std.set_empty();
                                                                                                                                                              (for (a in allocated) {
                                                                                                                                                                   ((_, var num) = a;
                                                                                                                                                                    std.set_insert(allocated_nums, num))
                                                                                                                                                               };
                                                                                                                                                               allocated_nums)), var alloc = allocate.allocate(allocated_nums, toallocate, min_val, max_val).
NewAllocationOpt(.id=id, .alloc=alloc) :- Alloc(.id=id, .allocated=allocated, .toallocate=toallocate, .min_val=min_val, .max_val=max_val), var allocated_nums = ((var allocated_nums: std.Set<bit<32>>) = std.set_empty();
                                                                                                                                                                 (for (a in allocated) {
                                                                                                                                                                      ((_, var num) = a;
                                                                                                                                                                       std.set_insert(allocated_nums, num))
                                                                                                                                                                  };
                                                                                                                                                                  allocated_nums)), var alloc = allocate.allocate_opt(allocated_nums, toallocate, min_val, max_val).
Adjusted(.id=id, .alloc=alloc) :- Alloc(.id=id, .allocated=allocated, .toallocate=toallocate, .min_val=min_val, .max_val=max_val), var alloc = allocate.adjust_allocation(allocated, toallocate, min_val, max_val).
YX(.y=y, .x=x) :- XY(.x=x, .y=y), YZX(.y=y, .z=z, .x=x).
IConcatString(.s=intern.string_intern((intern.istring_str(s1) ++ s2))) :- IString1(.s=s1), String2(.s=s2).
ConcatString(.s=intern.istring_str(s)) :- IConcatString(.s=s).
StringOrd(.s=intern.istring_str(s), .ord=intern.istring_ord(s)) :- IString1(.s=s).
StringOrd(.s=intern.istring_str(s), .ord=intern.istring_ord(s)) :- IConcatString(.s=s).
Ris_true(._s=intern.string_intern("true")).
Re(._x=(32'd10 % 32'd3), ._t=intern.string_intern("10%3"), ._y=32'd1) :- Ris_true(._s=_).
CMethod(.c1=a, .c2=b) :- BMethod(.b1=intern.string_intern("c"), .b2=b), AMethod(.a1=b, .a2=a).
DMethod(.c1=a, .c2=b) :- AMethod(.a1=b, .a2=a), BMethod(.b1=intern.string_intern("c"), .b2=b).
Power3(.y=std.pow32(x, 32'd3)) :- Numbers(.x=x).
RegexMatch(.regex=regex, .text=text, .m=regex.regex_match(regex, text)) :- Regex(.regex=regex, .text=text).
Arithm(.n=32'd0).
Arithm(.n=(32'd1 + 32'd0)).
Arithm(.n=(32'd0 + 32'd2)).
Arithm(.n=(32'd2 + 32'd1)).
Arithm(.n=(32'd2 + 32'd2)).
Arithm(.n=(32'd1 + 32'd4)).
Arithm(.n=(32'd2 * 32'd3)).
Arithm(.n=(32'd28 / 32'd4)).
Arithm(.n=(32'd24 % 32'd16)).
Arithm(.n=(32'd18 >> 32'd1)).
Arithm(.n=(32'd5 << 32'd1)).
Arithm(.n=(32'd10 | 32'd9)).
Arithm(.n=(32'd15 & 32'd12)).
Arithm(.n=(~ 32'd4294967282)).
Arithm(.n=(32'sd14 as bit<32>)).
Signed(.n=32'sd0).
Signed(.n=(32'sd1 + 32'sd0)).
Signed(.n=(32'sd0 + 32'sd2)).
Signed(.n=(32'sd2 + 32'sd1)).
Signed(.n=(32'sd2 + 32'sd2)).
Signed(.n=(32'sd1 + 32'sd4)).
Signed(.n=(32'sd2 * 32'sd3)).
Signed(.n=(32'sd28 / 32'sd4)).
Signed(.n=(32'sd24 % 32'sd16)).
Signed(.n=(32'sd18 >> 32'd1)).
Signed(.n=(32'sd5 << 32'd1)).
Signed(.n=(- 32'sd2147483648)).
Cast_u32(.description="32'd100  as bit<32>", .actual=(32'd100 as bit<32>), .expected=32'd100).
Cast_u32(.description="16'd100  as bit<32>", .actual=(16'd100 as bit<32>), .expected=32'd100).
Cast_u32(.description="8'd100   as bit<32>", .actual=(8'd100 as bit<32>), .expected=32'd100).
Cast_u32(.description="128'd100 as bit<32>", .actual=(128'd100 as bit<32>), .expected=32'd100).
Cast_u32(.description="256'd100 as bit<32>", .actual=(256'd100 as bit<32>), .expected=32'd100).
Cast_u32(.description="64'hffffffffffff as bit<32>", .actual=(64'd281474976710655 as bit<32>), .expected=32'd4294967295).
Cast_u32(.description="128'hffffffffffffffffffff as bit<32>", .actual=(128'd1208925819614629174706175 as bit<32>), .expected=32'd4294967295).
Cast_u32(.description="256'hffffffffffffffffffffffffffffffffffff as bit<32>", .actual=(256'd22300745198530623141535718272648361505980415 as bit<32>), .expected=32'd4294967295).
Cast_u32(.description="(100: signed<32>) as bit<32>", .actual=((32'sd100: signed<32>) as bit<32>), .expected=32'd100).
Cast_u32(.description="(32'sd0 - 32'sd10) as bit<32>", .actual=((32'sd0 - 32'sd10) as bit<32>), .expected=32'd4294967286).
Cast_s32(.description="32'sd100  as signed<32>", .expected=(32'sd100 as signed<32>), .actual=32'sd100).
Cast_s32(.description="16'sd100  as signed<32>", .expected=(16'sd100 as signed<32>), .actual=32'sd100).
Cast_s32(.description="8'sd100   as signed<32>", .expected=(8'sd100 as signed<32>), .actual=32'sd100).
Cast_s32(.description="128'sd100 as signed<32>", .expected=(128'sd100 as signed<32>), .actual=32'sd100).
Cast_s32(.description="64'shffffffffffff as signed<32>", .expected=(64'sd281474976710655 as signed<32>), .actual=32'sd4294967295).
Cast_s32(.description="128'shffffffffffffffffffff as signed<32>", .expected=(128'sd1208925819614629174706175 as signed<32>), .actual=32'sd4294967295).
Cast_s32(.description="(100: bit<32>) as signed<32>", .expected=((32'd100: bit<32>) as signed<32>), .actual=32'sd100).
Cast_u24(.description="24'd100  as bit<24>", .expected=(24'd100 as bit<24>), .actual=24'd100).
Cast_u24(.description="32'd100  as bit<24>", .expected=(32'd100 as bit<24>), .actual=24'd100).
Cast_u24(.description="16'd100  as bit<24>", .expected=(16'd100 as bit<24>), .actual=24'd100).
Cast_u24(.description="8'd100   as bit<24>", .expected=(8'd100 as bit<24>), .actual=24'd100).
Cast_u24(.description="128'd100 as bit<24>", .expected=(128'd100 as bit<24>), .actual=24'd100).
Cast_u24(.description="256'd100 as bit<24>", .expected=(256'd100 as bit<24>), .actual=24'd100).
Cast_u24(.description="64'hffffffffffff as bit<24>", .expected=(64'd281474976710655 as bit<24>), .actual=24'd16777215).
Cast_u24(.description="128'hffffffffffffffffffff as bit<24>", .expected=(128'd1208925819614629174706175 as bit<24>), .actual=24'd16777215).
Cast_u24(.description="256'hffffffffffffffffffffffffffffffffffff as bit<24>", .expected=(256'd22300745198530623141535718272648361505980415 as bit<24>), .actual=24'd16777215).
Cast_u24(.description="(100: signed<32>) as bit<32> as bit<24>", .expected=(((32'sd100: signed<32>) as bit<32>) as bit<24>), .actual=24'd100).
Cast_u24(.description="(32'sd0 - 32'sd10) as bit<32> as bit<24>", .expected=(((32'sd0 - 32'sd10) as bit<32>) as bit<24>), .actual=24'd16777206).
Cast_u256(.description="24'd100  as bit<256>", .expected=(24'd100 as bit<256>), .actual=256'd100).
Cast_u256(.description="32'd100  as bit<256>", .expected=(32'd100 as bit<256>), .actual=256'd100).
Cast_u256(.description="16'd100  as bit<256>", .expected=(16'd100 as bit<256>), .actual=256'd100).
Cast_u256(.description="8'd100   as bit<256>", .expected=(8'd100 as bit<256>), .actual=256'd100).
Cast_u256(.description="128'd100 as bit<256>", .expected=(128'd100 as bit<256>), .actual=256'd100).
Cast_u256(.description="256'd100 as bit<256>", .expected=(256'd100 as bit<256>), .actual=256'd100).
Cast_u256(.description="512'd100 as bit<256>", .expected=(512'd100 as bit<256>), .actual=256'd100).
Cast_u256(.description="264'hfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa as bit<256>", .expected=(264'd29642774844752946028434172162224104410437116074403984394101141506025761187823610 as bit<256>), .actual=256'd115792089237316195423570985008687907853269984665640564039457584007913129639930).
Cast_u256(.description="128'hffffffffffffffffffff as bit<256>", .expected=(128'd1208925819614629174706175 as bit<256>), .actual=256'd1208925819614629174706175).
Cast_u256(.description="(100: signed<32>) as bit<32> as bit<256>", .expected=(((32'sd100: signed<32>) as bit<32>) as bit<256>), .actual=256'd100).
Cast_u256(.description="(32'sd0 - 32'sd10) as bit<32> as bit<256>", .expected=(((32'sd0 - 32'sd10) as bit<32>) as bit<256>), .actual=256'd4294967286).
Cast_bigint(.description="24'd100  as bigint", .expected=(24'd100 as bigint), .actual=100).
Cast_bigint(.description="32'd100  as bigint", .expected=(32'd100 as bigint), .actual=100).
Cast_bigint(.description="16'd100  as bigint", .expected=(16'd100 as bigint), .actual=100).
Cast_bigint(.description="8'd100   as bigint", .expected=(8'd100 as bigint), .actual=100).
Cast_bigint(.description="128'd100 as bigint", .expected=(128'd100 as bigint), .actual=100).
Cast_bigint(.description="256'd100 as bigint", .expected=(256'd100 as bigint), .actual=100).
Cast_bigint(.description="512'd100 as bigint", .expected=(512'd100 as bigint), .actual=100).
Cast_bigint(.description="264'hfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa as bigint", .expected=(264'd29642774844752946028434172162224104410437116074403984394101141506025761187823610 as bigint), .actual=29642774844752946028434172162224104410437116074403984394101141506025761187823610).
Cast_bigint(.description="(32'sd0 - 32'sd10) as bigint", .expected=((32'sd0 - 32'sd10) as bigint), .actual=(0 - 10)).
UMinus_s32(.description="-32'sd100", .n=(- 32'sd100)).
UMinus_s32(.description="-(-32'sd100)", .n=(- (- 32'sd100))).
UMinus_s32(.description="-32768", .n=(- 32'sd32768)).
UMinus_bigint(.description="-100", .n=(- 100)).
UMinus_bigint(.description="- -100", .n=(- (- 100))).
UMinus_bigint(.description="-32768", .n=(- 32768)).
Span(.entity=(entity: entid_t), .tns=bindings) :- DdlogNode(.id=entity), DdlogBinding(.tn=tn, .entity=entity), var bindings = Aggregate((entity), std.group2set(tn)).
Span(.entity=parent, .tns=tns) :- DdlogNode(.id=parent), DdlogDependency(.parent=child, .child=parent), Span(.entity=child, .tns=child_tns), var tns = Aggregate((parent), std.group_set_unions(child_tns)).
R13(.t=(1, true, "", 32'd1)).
R14(.t=(1, (true, ("", 32'd1)))).
R14(.t=(0, (true, ("", 32'd1)))).
J(.b=b) :- R13(.t=a), R14(.t=c), (a.3 == c.1.1.1), var b = a.1.
apply graph.SCC(Edge, edge_from, edge_to) -> (SCCLabel)
