// This file contains a port of the OVN FTL code.
// This is a fairly literal translation of the code.

// ftl/ovn/northd/lswitch-acls.ftl
// TODO: declare used rules:
// -Flow: the output table
// -Logical_Switch

typedef stage = LS_IN_ACL{}
              | LS_OUT_ACL{}
              | LR_IN_ADMISSION{}
              | LR_IN_IP_INPUT{}
              | LR_IN_UNSNAT{}
              | LR_OUT_SNAT{}
              | LR_IN_DNAT{}
              | LR_IN_ARP_RESOLVE{}

/* Ingress and Egress ACL Table (Priority 0): Packets are allowed by
 * default.  A related rule at priority 1 is added below if there
 * are any stateful ACLs in this datapath. */
for (ls in Logical_Switch) {
    Flow(ls, LS_IN_ACL, 0, "1", "next;");
    Flow(ls, LS_OUT_ACL, 0, "1", "next;")
}

for (ls in Logical_Switch if ls.has_stateful_acl) {
    Flow(ls, LS_IN_ACL, 1,
         "ip && (!ct.est || (ct.est && ct_label.blocked))",
         "{ reg0[1] = 1; next; }");
    Flow(ls, LS_OUT_ACL, 1,
         "ip && (!ct.est || (ct.est && ct_label.blocked))",
         "{ reg0[1] = 1; next; }");

    /* Ingress and Egress ACL Table (Priority 65535).
     *
     * Always drop traffic that's in an invalid state.  Also drop
     * reply direction packets for connections that have been marked
     * for deletion (bit 0 of ct_label is set).
     *
     * This is enforced at a higher priority than ACLs can be defined. */
    Flow(ls, LS_IN_ACL, 65535,
         "ct.inv || (ct.est && ct.rpl && ct_label.blocked)",
         "{ drop; }");
    Flow(ls, LS_OUT_ACL, 65535,
         "ct.inv || (ct.est && ct.rpl && ct_label.blocked)",
         "{ drop; };");

    /* Ingress and Egress ACL Table (Priority 65535).
     *
     * Allow reply traffic that is part of an established
     * conntrack entry that has not been marked for deletion
     * (bit 0 of ct_label).  We only match traffic in the
     * reply direction because we want traffic in the request
     * direction to hit the currently defined policy from ACLs.
     *
     * This is enforced at a higher priority than ACLs can be defined. */
    Flow(ls, LS_IN_ACL, 65535,
         "(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && !ct_label.blocked)",
         "{ next; }");
    Flow(ls, LS_OUT_ACL, 65535,
         "(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && !ct_label.blocked)",
         "{ next; }");

    /* Ingress and Egress ACL Table (Priority 65535).
     *
     * Allow traffic that is related to an existing conntrack entry that
     * has not been marked for deletion (bit 0 of ct_label).
     *
     * This is enforced at a higher priority than ACLs can be defined.
     *
     * NOTE: This does not support related data sessions (eg,
     * a dynamically negotiated FTP data channel), but will allow
     * related traffic such as an ICMP Port Unreachable through
     * that's generated from a non-listening UDP port.  */
    Flow(ls, LS_IN_ACL, 65535,
         "!ct.est && ct.rel && !ct.new && !ct.inv && !ct_label.blocked",
         "{ next; }");
    Flow(ls, LS_OUT_ACL, 65535,
         "!ct.est && ct.rel && !ct.new && !ct.inv && !ct_label.blocked",
         "{ next; }");

    /* Ingress and Egress ACL Table (Priority 65535).
     *
     * Not to do conntrack on ND packets. */
    Flow(ls, LS_IN_ACL, 65535, "nd", "{ next; }");
    Flow(ls, LS_OUT_ACL, 65535, "nd", "{ next; }")
}

///////////////////////////
// https://github.com/blp/ovs-reviews/blob/ftl/ovn/northd/lrouter.ftl

/* Logical router ingress table 0: Admission control framework. */
for (lr in Logical_Router) {
    /* Logical VLANs not supported.
     * Broadcast/multicast source address is invalid. */
    Flow(lr, LR_IN_ADMISSION, 100, "vlan.present || eth.src[40]", "{ drop; }")
}

/* Logical router ingress table 0: match (priority 50). */
for (lrp in Logical_Router_Port if lrp.enabled) {
    let P = lrp.name,
        E = lrp.mac in {
        Flow(lrp.lr, LR_IN_ADMISSION, 50,
             $"inport == ${P} && (eth.mcast || eth.dst == ${E})", "{ next; }")
    }
}

/* Logical router ingress table 1: IP Input. */
for (lr in Logical_Router) {
    /* L3 admission control: drop multicast and broadcast source, localhost
     * source or destination, and zero network source or destination
     * (priority 100). */
    Flow(lr, LR_IN_IP_INPUT, 100,
         [|ip4.mcast ||
           ip4.src == 255.255.255.255 ||
           ip4.src == 127.0.0.0/8 ||
           ip4.dst == 127.0.0.0/8 ||
           ip4.src == 0.0.0.0/8 ||
           ip4.dst == 0.0.0.0/8)|], "{ drop; }");

    /* ARP reply handling.  Use ARP replies to populate the logical
     * router's ARP table. */
    Flow(lr, LR_IN_IP_INPUT, 90, "arp.op == 2",
         "put_arp(inport, arp.spa, arp.sha);");

    /* Drop Ethernet local broadcast.  By definition this traffic should
     * not be forwarded. */
    Flow(lr, LR_IN_IP_INPUT, 50, "eth.bcast", "{ drop; }");

    /* TTL discard.
     *
     * XXX Need to send ICMP time exceeded if !ip.later_frag. */
    Flow(lr, LR_IN_IP_INPUT, 30, "ip4 && ip.ttl == {0, 1}", "{ drop; }");

    /* ND advertisement handling.  Use advertisements to populate
     * the logical router's ARP/ND table. */
    Flow(lr, LR_IN_IP_INPUT, 90, "nd_na", "{ put_nd(inport, nd.target, nd.tll); }");

    /* Learn from neighbor solicitations that were not directed at
     * us.  (A priority-90 flow will respond to requests to us and
     * learn the sender's mac address. */
    Flow(lr, LR_IN_IP_INPUT, 80, "nd_na", "{ put_nd(inport, ip6.src, nd.sll); }");

    /* Pass other traffic not already handled to the next table for
     * routing. */
    Flow(lr, LR_IN_IP_INPUT, 0, "1", "{ next; }")
}

/* NAT, Defrag and load balancing in Gateway routers. */
for (lr in Logical_Router) {
    /* Packets are allowed by default. */
    Flow(lr, LR_IN_DEFRAG, 0, "1", "{ next; }");
    Flow(lr, LR_IN_UNSNAT, 0, "1", "{ next; }");
    Flow(lr, LR_OUT_SNAT, 0, "1", "{ next; }");
    Flow(lr, LR_IN_DNAT, 0, "1", "{ next; }")
}

for (lr in Logical_Router) {
    Flow(lr, LR_IN_ARP_RESOLVE, 0, "ip4", "{ get_arp(outport, reg0); next; }");
    Flow(lr, LR_IN_ARP_RESOLVE, 0, "ip6", "{ get_nd(outport, xxreg0); next; }")
}

/* Local router ingress table 6: ARP request.
 *
 * In the common case where the Ethernet destination has been resolved,
 * this table outputs the packet (priority 0).  Otherwise, it composes
 * and sends an ARP request (priority 100). */
for (lr in Logical_Router) {
    Flow(lr, LR_IN_ARP_REQUEST, 100, "eth.dst == 00:00:00:00:00:00", [|{
        arp {
            eth.dst = ff:ff:ff:ff:ff:ff;
            arp.spa = reg1;
            arp.tpa = reg0;
            arp.op = 1;  /* ARP request */
            output;
        }
    }|]);
    Flow(lr, LR_IN_ARP_REQUEST, 0, "1", "{ output; }")
}

/* Logical router egress table 1: Delivery (priority 100).
 *
 * Priority 100 rules deliver packets to enabled logical ports. */
for (lrp in Logical_Router_Port if lrp.enabled) {
    let P = lrp.name in {
        Flow(lrp.lr, LR_OUT_DELIVERY, 100, $"outport == ${P}", "{ output; }")
    }
}

///////////////////////////
// https://github.com/blp/ovs-reviews/blob/ftl/ovn/northd/lswitch.ftl

/* Logical switch ingress table 0: Admission control framework (priority
 * 100). */
for (lsp in Logical_Switch_Port) {
    /* Logical VLANs not supported. */
    Flow(lsp.ls, LS_IN_PORT_SEC_L2, 100, "vlan.present", "{ drop; }");
    /* Broadcast/multicast source address is invalid. */
    Flow(lsp.ls, LS_IN_PORT_SEC_L2, 100, "eth.src[40]", "{ drop; }")
    /* Port security flows have priority 50 (see below) and will continue
     * to the next table if packet source is acceptable. */
}

/* Logical switch ingress table 0: Ingress port security - L2
 *  (priority 50).
 *  Ingress table 1: Ingress port security - IP (priority 90 and 80)
 *  Ingress table 2: Ingress port security - ND (priority 90 and 80)
 */
for (lsp in Logical_Switch_Port if lsp.enabled) {
    let  P = lsp.name,
         L2 = lsp.port_security_l2,
         IP = lsp.port_security_ip_ingress,
         ND = lsp.port_security_nd in
    {
        if (lsp.port_security.not_empty) { /* lsp.port_security != []) { TODO mbudiu */
            Flow(lsp.ls, LS_IN_PORT_SEC_L2, 50, $"inport == \"{P}\" && eth.src == {L2}", "{ next; }");
            Flow(lsp.ls, LS_IN_PORT_SEC_IP, 90, $"inport == \"{P}\" && ({IP}))", "{ next; }");
            Flow(lsp.ls, LS_IN_PORT_SEC_IP, 80, $"inport == \"{P}\" && ip && eth.src == {L2}", "{ drop; }");
            Flow(lsp.ls, LS_IN_PORT_SEC_ND, 90, $"inport == \"{P}\" && ({ND})", "{ next; }");
            Flow(lsp.ls, LS_IN_PORT_SEC_ND, 80, $"inport == \"{P}\" && (arp || nd)", "{ drop; }")
        } else {
            Flow(lsp.ls, LS_IN_PORT_SEC_L2, 50, $"inport == \"{P}\"", "{ next; }")
        }
    }
}

/* Ingress table 1 and 2: Port security - IP and ND, by default goto next.
 * (priority 0). */
for (lsp in Logical_Switch_Port) {
    Flow(lsp.ls, LS_IN_PORT_SEC_ND, 0, "1", "{ next; }");
    Flow(lsp.ls, LS_IN_PORT_SEC_IP, 0, "1", "{ next; }")
}

/* Ingress table 9: Respond to ARP/ND requests, for ports that are up and for
 * router ports (up or not), but not from localnet ports. */
for (lsp in Logical_Switch_Port)
    if (lsp.type == "localnet") {
        let P = lsp.name in
            Flow(lsp.ls, LS_IN_ARP_RSP, 100, $"inport == \"{P}\"", "{ next; }")
    }

for (ls in Logical_Switch)
    Flow(ls, LS_IN_ARP_RSP, 0, "1", "{ next; }")

//for (lspip in Logical_Switch_Port_IP if lspip.lsp.up) {
//    let E = lspip.mac, A = lspip.ip, P = lspip.lsp.name in {
//        if (lspip.ip_version == 4) {
//            Flow(lspip.lsp.ls, LS_IN_ARP_RSP, "50", $[|
//                arp.tpa == ${A} && arp.op == 1) \{
//                eth.dst = eth.src;
//                eth.src = ${E};
//                arp.op = 2;     /* ARP reply */
//                arp.tha = arp.sha;
//                arp.sha = ${E};
//                arp.tpa = arp.spa;
//                arp.spa = ${A};
//                outport = inport;
//                flags.loopback = 1;
//                output;
//            \};|]);
//
//            /* Do not reply to an ARP request from the port that owns the
//             * address (otherwise a DHCP client that ARPs to check for a
//             * duplicate address will fail).  Instead, forward it the usual
//             * way.
//             *
//             * (Another alternative would be to simply drop the packet.  If
//             * everything is working as it is configured, then this would
//             * produce equivalent results, since no one should reply to the
//             * request.  But ARPing for one's own IP address is intended to
//             * detect situations where the network is not working as
//             * configured, so dropping the request would frustrate that
//             * intent.) */
//            Flow(lspip.lsp.ls, LS_IN_ARP_RSP, 100,
//                 $"arp.tpa == ${A} && arp.op == 1 && inport == \"${P}\", "{ next; }");
//        } else {
//            /* For ND solicitations, we need to listen for both the unicast
//             * IPv6 address and its all-nodes multicast address, but always
//             * respond with the unicast IPv6 address. */
//            let S = lspip.sn_ip in {
//                Flow(lspip.lsp.ls, LS_IN_ARP_RSP, 50,
//                     $"nd_ns && ip6.dst == {${A}, ${S}} && nd.target == ${A}", $[|{
//                    nd_na {
//                        eth.src = ${E};
//                        ip6.src = ${A};
//                        nd.target = ${A};
//                        nd.tll = ${E};
//                        outport = inport;
//                        flags.loopback = 1;
//                        output;
//                    };
//                }|]);
//                /* Do not reply to a solicitation from the port that owns
//                 * the address (otherwise DAD detection will fail). */
//                Flow(lspip.lsp.ls, LS_IN_ARP_RSP, 100,
//                     [| nd_ns && ip6.dst == {${A}, ${S}} && nd.target == ${A}
//                     && inport == \"${P}\", "{ next; })
//            }
//        }
//    }
//}
//
///* Ingress table 10 and 11: DHCP options and response, by default goto next.
// * (priority 0). */
//for (ls in Logical_Switch) {
//    Flow(ls, LS_IN_DHCP_OPTIONS, 0, "1", "{ next; }");
//    Flow(ls, LS_IN_DHCP_RESPONSE, 0, "1", "{ next; }")
//}
//for (lspip in Logical_Switch_Port_IP
//     if lspip.lsp.enabled && lspip.lsp.type != "router") {
//    let P = lspip.lsp.name,
//        A = lspip.ip,
//        E = lspip.mac in {
//        if (lspip.ip_version == 4) {
//            if (lspip.lsp.dhcpv4_options != []
//                /*&& !((lspip.ip ^ lspip.lsp.dhcpv4_options.host)
//                  & lspip.lsp.dhcpv4_options.netmask)*/) {
//                let M = lspip.lsp.dhcpv4_options.netmask,
//                    O = lspip.lsp.dhcpv4_options.option_args,
//                    SM = lspip.lsp.dhcpv4_options.server_mac,
//                    SI = lspip.lsp.dhcpv4_options.server_ip in {
//                    Flow(lspip.lsp.ls, LS_IN_DHCP_OPTIONS, 100,
//                         [| inport == "${P}" && eth.src == ${E}
//                         && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255
//                         && udp.src == 68 && udp.dst == 67|], [|{
//                        reg0[3] = put_dhcp_opts(offerip = ${A},
//                                                netmask = ${M},
//                                                ${O}); next; }|]);
//
//                    /* If reg0[3] is set, it means the put_dhcp_opts action is
//                     * successful. */
//                    Flow(lspip.lsp.ls, LS_IN_DHCP_RESPONSE, 100,
//                         [|inport == "${P}" && eth.src == ${E}
//                         && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255
//                         && udp.src == 68 && udp.dst == 67
//                         && reg0[3]|], [|{
//                        eth.dst = eth.src;
//                        eth.src = ${SM};
//                        ip4.dst = ${A};
//                        ip4.src = ${SI};
//                        udp.src = 67;
//                        udp.dst = 68;
//                        outport = inport;
//                        flags.loopback = 1;
//                        output;
//                    };|])
//                }
//            }
//        } else {
//            let O = lspip.lsp.dhcpv6_options.option_args,
//                SM = lspip.lsp.dhcpv6_options.server_mac,
//                SI = lspip.lsp.dhcpv6_options.server_ip) in {
//                /* Stateful DHCPv6 includes an IP address,
//                 * stateless DHCPv6 is options-only. */
//                if (lspip.lsp.dhcpv6_options.stateful) {
//                    Flow(lspip.lsp.ls, LS_IN_DHCP_OPTIONS, 100,
//                         [|inport == "${P}" && eth.src == ${E}
//                         && ip6.dst == ff02::1:2
//                         && udp.src == 546 && udp.dst == 547)|], [|{
//                        reg0[3] = put_dhcpv6_opts(ia_addr = ${A}, ${O});
//                        next;
//                    }|]);
//                } else {
//                    Flow(lspip.lsp.ls, LS_IN_DHCP_OPTIONS, 100,
//                         [|inport == "${P}" && eth.src == ${E}
//                         && ip6.dst == ff02::1:2
//                         && udp.src == 546 && udp.dst == 547)|], [|{
//                        reg0[3] = put_dhcpv6_opts(${O});
//                        next;
//                    }|]);
//                }
//
//                /* If reg0[3] is set, it means the put_dhcpv6_opts action is
//                 * successful. */
//                Flow(lspip.lsp.ls, LS_IN_DHCP_RESPONSE, 100,
//                     [|inport == "${P}" && eth.src == ${E}
//                     && ip6.dst == ff02::1:2
//                     && udp.src == 546 && udp.dst == 547
//                     && reg0[3]|], [|{
//                    eth.dst = eth.src;
//                    eth.src = ${SM};
//                    ip6.dst = ip6.src;
//                    ip6.src = ${SI};
//                    udp.src = 547;
//                    udp.dst = 546;
//                    outport = inport;
//                    flags.loopback = 1;
//                    output;
//                };"|])
//            }
//        }
//    }
//}
//
///* Ingress table 12: Destination lookup, broadcast and multicast handling
// * (priority 100). */
//for (ls in Logical_Switch) {
//    Flow(ls, LS_IN_L2_LKUP, 100, "eth.mcast", [|
//        outport = "_MC_flood";
//        output;
//    };|])
//}
//
///* Ingress table 12: Destination lookup, unicast handling (priority 50), */
//for (lsp in Logical_Switch_Port) {
//    if (lsp.macs != "") {
//        let P = lsp.name, M = lsp.macs in
//            Flow(lsp.ls, LS_IN_L2_LKUP, 50, $"eth.dst == {${M}}", [|{
//                outport = "${P}";
//                output;
//            }|])
//        }
//    }
//}
//for (ls in Logical_Switch) {
//    Flow(ls, LS_IN_L2_LKUP, 0, "1", [|{
//        outport = "_MC_unknown";
//        output;
//    }|])
//}
//
///* Egress table 6: Egress port security - IP (priorities 90 and 80)
// * if port security enabled.
// *
// * Egress table 7: Egress port security - L2 (priorities 50 and 150).
// *
// * Priority 50 rules implement port security for enabled logical port.
// *
// * Priority 150 rules drop packets to disabled logical ports: so that they
// * don't even receive multicast or broadcast packets. */
//for (lsp in Logical_Switch_Port) {
//    let P = lsp.name,
//        L2 = lsp.port_security_l2,
//        IP = lsp.port_security_ip_egress in
//    {
//        if (lsp.port_security != []) {
//            Flow(lsp.ls, LS_OUT_PORT_SEC_IP, 90,
//                 $[|"outport == "${P}" && (${IP})|], "{ next; }");
//            Flow(lsp.ls, LS_OUT_PORT_SEC_IP, 80,
//                 $[|"outport == "${P}" && ip && eth.dst == ${L2}|], "{ drop; }")
//        }
//
//        if (lsp.enabled) {
//            Flow(lsp.ls, LS_OUT_PORT_SEC_L2, 50, $[|outport == "${P}" && eth.dst == ${L2}|],
//             "{ output; }")
//        } else {
//            Flow(lsp.ls, LS_OUT_PORT_SEC_L2, 150, $"outport == \"${P}\"", "{ drop; }")
//        }
//    }
//}
//for (ls in Logical_Switch) {
//    Flow(ls, LS_OUT_PORT_SEC_IP, 0, "1", "{ next; }");
//    Flow(ls, LS_OUT_PORT_SEC_L2, 100, "eth.mcast", "{ output; }")
//}