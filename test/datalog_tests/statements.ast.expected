typedef W = W{f1: int, f2: int, f3: int}
typedef X = X{field: int}
typedef Z = Z{field: int}
typedef set<'A>
function __builtin_2string (x: 'X): string
relation W [W]
ground relation X [X]
relation Z [Z]
Z(.field=a) :- X(.field=a).
Z(.field=a) :- X(.field=a), match (a) {
                                1 -> true,
                                2 -> false,
                                _ -> false
                            }.
Z(.field=(a + 1)) :- X(.field=a), match (a) {
                                      1 -> false,
                                      2 -> true,
                                      _ -> false
                                  }.
Z(.field=(a - 1)) :- X(.field=a), match (a) {
                                      1 -> false,
                                      2 -> false,
                                      _ -> true
                                  }.
Z(.field=a) :- X(.field=a), ((a % 2) == 0).
Z(.field=(a + 1)) :- X(.field=a), (a == 2).
Z(.field=a) :- X(.field=a), (a != 1).
Z(.field=a) :- X(.field=a), (a >= 2), (a > 2).
Z(.field=(a + 2)) :- X(.field=a), (a >= 2), (a > 2).
Z(.field=(a + b)) :- X(.field=a), X(.field=b).
Z(.field=(a + c)) :- X(.field=a), X(.field=c).
Z(.field=(a + b)),
Z(.field=(a + c)) :- X(.field=a), X(.field=b), X(.field=c).
Z(.field=(a + b)) :- X(.field=a), var b = (a + 2).
W(.f1=a, .f2=b, .f3=c) :- X(.field=a), var b = (a + 2), var c = (b + a).
for (a in X)
    skip
for (a in X)
    Z(a)
for (a in X)
    match (a)
    {
        1 -> Z(a),
        2 -> Z((a + 1)),
        _ -> Z((a - 1))
    }
for (a in X if true)
    skip
for (a in X)
    if (true)
        skip
for (a in X)
    {
        skip;
        skip
    }
for (a in X if ((a % 2) == 0))
    Z(a)
for (a in X)
    if (((a % 2) == 0))
        Z(a)
for (a in X)
    {
        if ((a == 2))
            skip
    }
for (a in X)
    {
        if ((a == 2))
            skip
        else
            skip
    }
for (a in X)
    {
        if ((a == 2))
            Z((a + 1))
        else
            Z(a)
    }
for (a in X)
    if ((a >= 2))
        if ((a > 2))
            {
                Z(a);
                Z((a + 2))
            }
for (a in X)
    {
        for (b in X)
            Z((a + b));
        for (c in X)
            Z((a + c))
    }
for (a in X)
    let b = (a + 2) in
        skip
for (a in X)
    let b = (a + 2) in
        Z((a + b))
for (a in X)
    let b = (a + 2), c = (b + a) in
        W(a, b, c)
