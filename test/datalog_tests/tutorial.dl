/*
 * Example: "Hello, world!" in Datalog
 */

// Category type with two type constructors.  Since constructors have
// no arguments, this is similar to a C enum.
typedef Category = CategoryStarWars
                 | CategoryOther

// Declare two input relations (the `input` keyword indicates that
// these relations can only be populated by input facts and cannot
// appear in the head of a rule).
// `string` is a primitive type in ddlog.
input relation Word1(word: string, cat: Category)
input relation Word2(word: string, cat: Category)

// Computed relation populated by facts derived from rules.
relation Phrases(phrase: string)

// Produce phrases by combining pairs of words from the same category.
// The `++` operator is string concatenation.
Phrases(w1 ++ " " ++ w2) :- Word1(w1, cat), Word2(w2, cat).

// Let's add some static facts (which have not effect in the current
// implementation)
Word1("Hello,", CategoryOther).
Word2("World!", CategoryOther).


/*
 * Example: Map hosts to IP subnets.
 */

// Type aliases improve readability.
typedef UUID    = bit<128>
typedef IPAddr  = bit<32>
typedef NetMask = bit<32>

// IP host specified by its name and address.
input relation Host(id: UUID, name: string, ip: IPAddr)

// IP subnet specified by its IP prefix and mask
input relation Subnet(id: UUID, prefix: IPAddr, mask: NetMask)

// HostInSubnet relation maps hosts to known subnets
relation HostInSubnet(host: UUID, subnet: UUID)

// Compute `HostInSubnet` by filtering all host-subnet pairs where host address matches
// subnet prefix and mask.
//
// Note the use of wildcard (`_`) for fields that are not relevant in this rule.
//
// Note: ddlog computes this space efficiently by applying the
// filter at the same time as it computes Cartesian product of `Host` and 
// `Subnet` relations.
HostInSubnet(host_id, subnet_id) :- Host(host_id, _, host_ip),
                                    Subnet(subnet_id, subnet_prefix, subnet_mask),
                                    ((host_ip & subnet_mask) == subnet_prefix).    // filter condition


/*
 * Example: Strings
 */

input relation Number(n: bigint)
relation Pow2(p: string)

Pow2($"The square of ${x} is ${x*x}") :- Number(x).

typedef ip_addr_t = IPAddr{addr: bit<32>}
typedef mac_addr_t = MACAddr{addr: bit<48>}

function ip_addr_t2string(ip: ip_addr_t): string = {
    $"${ip.addr[31:24]}.${ip.addr[23:16]}.${ip.addr[15:8]}.${ip.addr[7:0]}"
}

function mac_addr_t2string(mac: mac_addr_t): string = {
    $"${hex(mac.addr[47:40])}:${hex(mac.addr[39:32])}:${hex(mac.addr[31:24])}:${hex(mac.addr[23:16])}:${hex(mac.addr[15:8])}:${hex(mac.addr[7:0])}"
}

typedef nethost_t = NHost {
    ip:  ip_addr_t,
    mac: mac_addr_t
}

function nethost_t2string(h: nethost_t): string = {
    $"Host: IP=${h.ip}, MAC=${h.mac}"
}

input relation NetHost(id: bigint, h: nethost_t)
relation NetHostString(id: bigint, s: string)

NetHostString(id, $"${h}") :- NetHost(id, h).

/*
 * Example: arithmetics
 */

// Form IP address from bytes using bit vector concatenation
function ip_from_bytes(b3: bit<8>, b2: bit<8>, b1: bit<8>, b0: bit<8>)
    : ip_addr_t = 
{
    IPAddr{.addr = b3 ++ b2 ++ b1 ++ b0}
}

// Check for multicast IP address using bit slicing
function is_multicast_addr(ip: ip_addr_t): bool = ip.addr[31:28] == 14

input relation Bytes(b3: bit<8>, b2: bit<8>, b1: bit<8>, b0: bit<8>)
relation Address(addr: ip_addr_t)
relation MCastAddress(addr: ip_addr_t)

Address(ip_from_bytes(b3,b2,b1,b0)) :- Bytes(b3,b2,b1,b0).
MCastAddress(a) :- Address(a), is_multicast_addr(a).

/*
 * Example: control flow
 */

function addr_port(ip: ip_addr_t,
                   proto: string,
                   preferred_port: bit<16>): string = {
    var port: bit<16> = 
        match (proto) {
            "FTP"   -> 20,
            "HTTPS" -> 443,
            _       -> {
                if (preferred_port != 0) 
                    preferred_port 
                else 
                    16'd80 // assume HTTP
            }
        };
    $"${ip}:${port}"
}

input relation Connection(ip: ip_addr_t,
                          proto: string,
                          preferred_port: bit<16>)

relation ConnectionString(s: string)

ConnectionString(addr_port(ip, proto, preferred_port)) :-
    Connection(ip, proto, preferred_port).

/*
 * Example: assignment clauses and antijoins
 */
input relation Blacklisted(ep: string)
relation Endpoint(ep: string)

Endpoint(endpoint) :- 
    Connection(ip, proto, preferred_port),
    var endpoint = addr_port(ip, proto, preferred_port),
    not Blacklisted(endpoint).

/*
 * Example: recursion
 * (see path.dl)
 */

/*
 * Example: FlatMap, extern functions
 */

extern function split_ip_list(x: string): set<string>

input relation HostAddresses(host: bit<64>, addrs: string)
relation HostIP(host: bit<64>, addr: string)

HostIP(host, addr) :- HostAddresses(host, addrs), 
                      FlatMap(addr=split_ip_list(addrs)).

/*
 * Example: Multiple heads
 */
input relation X(x: bit<16>)

relation Sum(x: bit<16>, y: bit<16>, sum: bit<16>)
relation Product(x: bit<16>, y: bit<16>, prod: bit<16>)

Sum(x,y,x+y),
Product(x,y,x*y) :- X(x), X(y).

/*
 * Example: tagged unions
 */

typedef ip4_addr_t = bit<32>
typedef ip6_addr_t = bit<128>

typedef eth_pkt_t = EthPacket { src     : bit<48>
                              , dst     : bit<48>
                              , payload : eth_payload_t}

typedef eth_payload_t = EthIP4   {ip4 : ip4_pkt_t}
                      | EthIP6   {ip6 : ip6_pkt_t}
                      | EthOther

typedef ip4_pkt_t = IP4Pkt { ttl      : bit<8>
                           , src      : ip4_addr_t
                           , dst      : ip4_addr_t
                           , payload  : ip_payload_t}

typedef ip6_pkt_t = IP6Pkt { ttl     : bit<8>
                           , src     : ip6_addr_t
                           , dst     : ip6_addr_t
                           , payload : ip_payload_t}

typedef ip_payload_t = IPTCP   { tcp : tcp_pkt_t}
                     | IPUDP   { udp : udp_pkt_t}
                     | IPOther

typedef tcp_pkt_t = TCPPkt { src   : bit<16>
                           , dst   : bit<16>
                           , flags : bit<9> }

typedef udp_pkt_t = UDPPkt { src     : bit<16>
                           , dst     : bit<16> 
                           , len     : bit<16>}


input relation Packet(pkt: eth_pkt_t)

relation TCPDstPort(port: bit<16>)

TCPDstPort(port) :- Packet(EthPacket{.payload = EthIP4{IP4Pkt{.payload = IPTCP{TCPPkt{.dst = port}}}}}).
TCPDstPort(port) :- Packet(EthPacket{.payload = EthIP6{IP6Pkt{.payload = IPTCP{TCPPkt{.dst = port}}}}}).

function pkt_udp_port(pkt: eth_pkt_t): bit<16> = {
    match (pkt) {
        EthPacket{.payload = EthIP4{IP4Pkt{.payload = IPUDP{UDPPkt{.dst = port}}}}} -> port,
        EthPacket{.payload = EthIP6{IP6Pkt{.payload = IPUDP{UDPPkt{.dst = port}}}}} -> port,
        _ -> 0
    }
}

relation UDPDstPort(port: bit<16>)

UDPDstPort(port) :- Packet(pkt), var port = pkt_udp_port(pkt), port != 0.

function pkt_udp_port2(pkt: eth_pkt_t): option_t<bit<16>> = {
    match (pkt) {
        EthPacket{.payload = EthIP4{IP4Pkt{.payload = IPUDP{UDPPkt{.dst = port}}}}} -> Some{port},
        EthPacket{.payload = EthIP6{IP6Pkt{.payload = IPUDP{UDPPkt{.dst = port}}}}} -> Some{port},
        _ -> None
    }
}

relation UDPDstPort2(port: bit<16>)

UDPDstPort2(port) :- Packet(pkt), Some{var port} = pkt_udp_port2(pkt).

/*
 * Example: tuples
 */

input relation KnownHost(addr: ip4_addr_t)

function addr_to_tuple(addr: ip4_addr_t): (bit<8>, bit<8>, bit<8>, bit<8>) = {
    (addr[31:24], addr[23:16], addr[15:8], addr[7:0])
}

relation IntranetHost(addr: ip4_addr_t)

IntranetHost(addr) :- KnownHost(addr), (192, 168, _, _) = addr_to_tuple(addr).

/*
 * Example: explicit relation type
 */



/*
 * Example: Advanced features
 */

// option_t is a generic type that can be use to represent optional values of any other type.
// It is parameterized by type argument 'A.
typedef option_t<'A> = None
                     | Some {value : 'A}

// The Load_Balancer relation instantiates option_t type for strings.
input relation Load_Balancer (
    lb:           bigint, // bigint is a primitive ddlog type that models 
                       // unbounded mathematical integers.
    ls:           bigint,
    ip_addresses: string,
    protocol:     option_t<string>,
    name:         string
)

typedef stage = LS_IN_PRE_LB
              | LS_OUT_PRE_LB

input relation Logical_Switch (
    ls:  bigint
)

// Relation that represents OVS flows.
relation Flow(lr: bigint,
              stage: stage,
              prio: bigint,
              matchStr: string,
              actionStr: string)

// The following rule illustrates several new syntactic constructs.
//
// 1. Note the use of named arguments in the head of the relation (e.g., `.stage=LS_IN_PRE_LB`).
//    This syntax is more verbose, but sometimes more readable especially for relations that have
//    several arguments.
// 2. Note the `$` syntax for string literals.  A string literal prefixed by `$` is an interpolated
//    string.  It can contain arbitrary ddlog expressions enclosed in `${}`.  These expressions are
//    automatically converted to string representation and concatenated with the rest of the string.
// 3. The body of the rule uses pattern matching to filter only those Load_Balancer records whose
//    protocol is specified (i.e., is not `None`).  Alternatively, one could match on a specific
//    protocol, e.g., TCP, by writing `Some{"TCP"}` instead of `Some{_}`.
Flow(.lr=ls,
     .stage=LS_IN_PRE_LB,
     .prio=100,
     .matchStr= $"ip4.dst == ${addresses}",
     .actionStr="{ reg0[0] = 1; next; }")   :-
    Load_Balancer(_, ls, addresses, Some{_}, _).


Flow(.lr=ls,
     .stage=LS_OUT_PRE_LB,
     .prio=100,
     .matchStr="ip4",
     .actionStr="{ reg0[0] = 1; next; }") :-
    Logical_Switch(.ls=ls),
    Load_Balancer(.ls=ls).


// The above two rules can be equivalently written using FTL syntax.

// Introduce another Flow relation, so that we can compare the results of the two encodings.
relation Flow1(lr: bigint,
               stage: stage,
               prio: bigint,
               matchStr: string,
               actionStr: string)

for (lb in Load_Balancer) {
    let a = lb.ip_addresses in
    match (lb.protocol) {
        Some{_} -> Flow1(lb.ls, LS_IN_PRE_LB, 100, $"ip4.dst == ${a}", "{ reg0[0] = 1; next; }"),
        None -> {}
    }
}


for (ls in Logical_Switch) {
    for (lb in Load_Balancer if lb.ls == ls.ls) {
        Flow1(ls.ls, LS_OUT_PRE_LB, 100, "ip4", "{ reg0[0] = 1; next; }")
    }
}


