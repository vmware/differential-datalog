typedef Address = Address{addr: ip_addr_t}
typedef Arguments = Arguments{arg: ddlog_std::u64}
typedef Author = Author{name: string, born: ddlog_std::u32}
typedef BestDeal = BestDeal{best: string}
typedef BestPrice = BestPrice{item: string, price: bit<64>}
typedef BestVendor = BestVendor{item: string, vendor: string, price: bit<64>}
typedef Blacklisted = Blacklisted{ep: string}
typedef Book = Book{author: string, title: string}
typedef BookByAuthor = BookByAuthor{book: Book, author: Author}
typedef Bytes = Bytes{b3: bit<8>, b2: bit<8>, b1: bit<8>, b0: bit<8>}
typedef Category = CategoryStarWars{} |
                   CategoryOther{}
typedef Closures = Closures{f: function(ddlog_std::u64):string}
typedef ClosuresXArguments = ClosuresXArguments{arg: ddlog_std::u64, res: string}
typedef Endpoint = Endpoint{ip: ip_addr_t, proto: string, preferred_port: bit<16>}
typedef EndpointString = EndpointString{s: string}
typedef Evens = Evens{evens_and_odds: ddlog_std::Vec<bigint>, evens: ddlog_std::Vec<bigint>}
typedef EvensAndOdds = EvensAndOdds{vec: ddlog_std::Vec<bigint>}
typedef First5 = First5{str: string}
typedef Flow = Flow{lr: bigint, stage: stage, prio: bigint, matchStr: string, actionStr: string}
typedef Flow1 = Flow1{lr: bigint, stage: stage, prio: bigint, matchStr: string, actionStr: string}
typedef Host = Host{id: UUID, name: string, ip: IP4}
typedef HostAddress = HostAddress{host: bit<64>, addrs: string}
typedef HostIP = HostIP{host: bit<64>, addr: string}
typedef HostIPVSep = HostIPVSep{host: bit<64>, addrs: string}
typedef HostInSubnet = HostInSubnet{host: UUID, subnet: UUID}
typedef IP4 = bit<32>
typedef IStoreItem = internment::Intern<StoreItem>
typedef IntranetHost = IntranetHost{addr: ip4_addr_t}
typedef IntranetHost2 = IntranetHost2{addr: ip4_addr_t}
typedef IntranetHost3 = IntranetHost3{addr: ip4_addr_t}
typedef InventoryItemName = InventoryItemName{name: string}
typedef ItemInOrders = ItemInOrders{item: string, orders: ddlog_std::Vec<ddlog_std::u64>}
typedef KnownHost = KnownHost{addr: ip4_addr_t}
typedef Library = Library{book: Book}
typedef Load_Balancer = Load_Balancer{lb: bigint, ls: bigint, ip_addresses: string, protocol: ddlog_std::Option<string>, name: string}
typedef Logical_Switch = Logical_Switch{ls: bigint}
typedef MCastAddress = MCastAddress{addr: ip_addr_t}
typedef MSetIn = MSetIn{x: ddlog_std::u32}
typedef MSetOut = MSetOut{x: ddlog_std::u32}
typedef MilkOrders = MilkOrders{order: ddlog_std::u64}
typedef NetHost = NetHost{id: bigint, h: nethost_t}
typedef NetHostString = NetHostString{id: bigint, s: string}
typedef NetMask = bit<32>
typedef Number = Number{n: bigint}
typedef OnlineOrder = OnlineOrder{order_id: ddlog_std::u64, item: internment::istring}
typedef OrderFormatted = OrderFormatted{order: string}
typedef Packet = Packet{pkt: eth_pkt_t}
typedef Person = Person{name: string, nationality: string, occupation: string}
typedef Phrases = Phrases{phrase: string}
typedef Pow2 = Pow2{p: string}
typedef Prefix = Prefix{vec: ddlog_std::Vec<string>}
typedef Price = Price{item: string, vendor: string, price: bit<64>}
typedef PriceInCents = PriceInCents{item: string, price1: ddlog_std::Option<ddlog_std::u64>, price2: ddlog_std::u64, price3: ddlog_std::Option<ddlog_std::u64>}
typedef Product = Product{x: bit<16>, y: bit<16>, prod: bit<16>}
typedef SanitizedEndpoint = SanitizedEndpoint{ep: string}
typedef School = School{name: string, address: string}
typedef StoreInventory = StoreInventory{item: IStoreItem}
typedef StoreItem = StoreItem{name: string, description: internment::istring}
typedef Student = Student{id: student_id, name: string, school: string, sat_score: bit<16>}
typedef StudentInfo = StudentInfo{student: ddlog_std::Ref<Student>, school: ddlog_std::Ref<School>}
typedef Subnet = Subnet{id: UUID, prefix: IP4, mask: NetMask}
typedef Sum = Sum{x: bit<16>, y: bit<16>, sum: bit<16>}
typedef TCPDstPort = TCPDstPort{port: bit<16>}
typedef TopScore = TopScore{school: string, top_score: bit<16>}
typedef UDPDstPort = UDPDstPort{port: bit<16>}
typedef UDPDstPort2 = UDPDstPort2{port: bit<16>}
typedef UUID = bit<128>
typedef Vector = Vector{vec: ddlog_std::Vec<string>, sep: string}
typedef Word1 = Word1{word: string, cat: Category}
typedef Word2 = Word2{word: string, cat: Category}
typedef WorstPrice = WorstPrice{item: string, price: bit<64>}
typedef X = X{x: bit<16>}
typedef ddlog_std::DDEpoch = ddlog_std::u64
typedef ddlog_std::DDIteration = ddlog_std::u64
typedef ddlog_std::DDNestedTS = ddlog_std::DDNestedTS{epoch: ddlog_std::DDEpoch, iter: ddlog_std::DDIteration}
typedef ddlog_std::DDWeight = ddlog_std::s64
typedef ddlog_std::Either<'A,'B> = ddlog_std::Left{l: 'A} |
                                   ddlog_std::Right{r: 'B}
extern type ddlog_std::Group<'K,'V>
extern type ddlog_std::Map<'K,'V>
#[rust = "serde(from=\"::std::option::Option<A>\", into=\"::std::option::Option<A>\", bound(serialize=\"A: Clone+Serialize\"))"]
#[custom_from_record = true]
typedef ddlog_std::Option<'A> = ddlog_std::None{} |
                                ddlog_std::Some{x: 'A}
#[size = 8]
#[shared_ref = true]
extern type ddlog_std::Ref<'A>
typedef ddlog_std::Result<'V,'E> = ddlog_std::Ok{res: 'V} |
                                   ddlog_std::Err{err: 'E}
extern type ddlog_std::Set<'A>
extern type ddlog_std::Vec<'A>
#[alias = true]
typedef ddlog_std::isize = signed<64>
typedef ddlog_std::s128 = signed<128>
typedef ddlog_std::s16 = signed<16>
typedef ddlog_std::s32 = signed<32>
typedef ddlog_std::s64 = signed<64>
typedef ddlog_std::s8 = signed<8>
#[alias = true]
typedef ddlog_std::u128 = bit<128>
#[alias = true]
typedef ddlog_std::u16 = bit<16>
#[alias = true]
typedef ddlog_std::u32 = bit<32>
#[alias = true]
typedef ddlog_std::u64 = bit<64>
#[alias = true]
typedef ddlog_std::u8 = bit<8>
#[alias = true]
typedef ddlog_std::usize = bit<64>
typedef debug::DDlogOpId = (ddlog_std::u32, ddlog_std::u32, ddlog_std::u32)
typedef eth_payload_t = EthIP4{ip4: ip4_pkt_t} |
                        EthIP6{ip6: ip6_pkt_t} |
                        EthOther{}
typedef eth_pkt_t = EthPacket{src: bit<48>, dst: bit<48>, payload: eth_payload_t}
#[size = 8]
#[shared_ref = true]
extern type internment::Intern<'A>
typedef internment::istring = internment::Intern<string>
typedef ip4_addr_t = bit<32>
typedef ip4_pkt_t = IP4Pkt{ttl: bit<8>, src: ip4_addr_t, dst: ip4_addr_t, payload: ip_payload_t}
typedef ip6_addr_t = bit<128>
typedef ip6_pkt_t = IP6Pkt{ttl: bit<8>, src: ip6_addr_t, dst: ip6_addr_t, payload: ip_payload_t}
typedef ip_addr_t = IPAddr{addr: bit<32>}
typedef ip_payload_t = IPTCP{tcp: tcp_pkt_t} |
                       IPUDP{udp: udp_pkt_t} |
                       IPOther{}
typedef log::log_level_t = signed<32>
typedef log::module_t = signed<32>
typedef mac_addr_t = MACAddr{addr: bit<48>}
typedef nethost_t = NHost{ip: ip_addr_t, mac: mac_addr_t}
typedef stage = LS_IN_PRE_LB{} |
                LS_OUT_PRE_LB{}
typedef student_id = bit<64>
typedef tcp_pkt_t = TCPPkt{src: bit<16>, dst: bit<16>, flags: bit<9>}
typedef udp_pkt_t = UDPPkt{src: bit<16>, dst: bit<16>, len: bit<16>}
function __debug_22_1_best_vendor (g: ddlog_std::Group<string,('I, (string, bit<64>))>): (ddlog_std::Vec<'I>, (string, bit<64>))
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,(string, bit<64>)>)) = debug::debug_split_group(g);
     (inputs, best_vendor(original_group))}
}
function __debug_23_2_best_vendor_string (g: ddlog_std::Group<string,('I, (string, bit<64>))>): (ddlog_std::Vec<'I>, string)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,(string, bit<64>)>)) = debug::debug_split_group(g);
     (inputs, best_vendor_string(original_group))}
}
function addr_port (ip: ip_addr_t, proto: string, preferred_port: bit<16>): string
{
    {(var port: bit<16>) = match (proto) {
                               "FTP" -> 16'd20,
                               "HTTPS" -> 16'd443,
                               (_: string) -> if (preferred_port != 16'd0) {
                                                  preferred_port
                                              } else {
                                                    ((return (("" ++ (to_string: function(ip_addr_t):string)(ip)) ++ ":80")): bit<16>)
                                                }
                           };
     ((("" ++ (to_string: function(ip_addr_t):string)(ip)) ++ ":") ++ (ddlog_std::__builtin_2string: function(bit<16>):string)(port))}
}
function addr_to_tuple (addr: ip4_addr_t): (bit<8>, bit<8>, bit<8>, bit<8>)
{
    (addr[31:24], addr[23:16], addr[15:8], addr[7:0])
}
function best_vendor (g: ddlog_std::Group<'K,(string, bit<64>)>): (string, bit<64>)
{
    {(var min_vendor: string) = "";
     {(var min_price: bit<64>) = 64'd18446744073709551615;
      {for (vendor_price in g) {
           if (vendor_price.1 < min_price) {
               {min_vendor = vendor_price.0;
                {min_price = vendor_price.1;
                 ()}}
           } else {
                 ()
             }
       };
       (min_vendor, min_price)}}}
}
function best_vendor_string (g: ddlog_std::Group<string,(string, bit<64>)>): string
{
    {(var min_vendor: string) = "";
     {(var min_price: bit<64>) = 64'd18446744073709551615;
      {for (vendor_price in g) {
           if (vendor_price.1 < min_price) {
               {min_vendor = vendor_price.0;
                {min_price = vendor_price.1;
                 ()}}
           } else {
                 ()
             }
       };
       ((((("Best deal for " ++ (ddlog_std::group_key: function(ddlog_std::Group<string,(string, bit<64>)>):string)(g)) ++ ": ") ++ min_vendor) ++ ", $") ++ (ddlog_std::__builtin_2string: function(bit<64>):string)(min_price))}}}
}
extern function ddlog_std::__builtin_2string (x: 'X): string
function ddlog_std::__debug_20_1_group_min (g: ddlog_std::Group<string,('I, bit<64>)>): (ddlog_std::Vec<'I>, bit<64>)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,bit<64>>)) = debug::debug_split_group(g);
     (inputs, ddlog_std::group_min(original_group))}
}
function ddlog_std::__debug_21_1_group_max (g: ddlog_std::Group<string,('I, bit<64>)>): (ddlog_std::Vec<'I>, bit<64>)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,bit<64>>)) = debug::debug_split_group(g);
     (inputs, ddlog_std::group_max(original_group))}
}
function ddlog_std::__debug_36_1_group_max (g: ddlog_std::Group<string,('I, bit<16>)>): (ddlog_std::Vec<'I>, bit<16>)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,bit<16>>)) = debug::debug_split_group(g);
     (inputs, ddlog_std::group_max(original_group))}
}
function ddlog_std::__debug_37_1_group_max (g: ddlog_std::Group<string,('I, bit<16>)>): (ddlog_std::Vec<'I>, bit<16>)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<string,bit<16>>)) = debug::debug_split_group(g);
     (inputs, ddlog_std::group_max(original_group))}
}
function ddlog_std::__debug_38_1_group_to_vec (g: ddlog_std::Group<internment::Intern<string>,('I, bit<64>)>): (ddlog_std::Vec<'I>, ddlog_std::Vec<bit<64>>)
{
    {((var inputs: ddlog_std::Vec<'I>), (var original_group: ddlog_std::Group<internment::Intern<string>,bit<64>>)) = debug::debug_split_group(g);
     (inputs, ddlog_std::group_to_vec(original_group))}
}
function ddlog_std::append (v: mut ddlog_std::Vec<'X>, other: ddlog_std::Vec<'X>): ()
{
    (ddlog_std::vec_append: function(mut ddlog_std::Vec<'X>, ddlog_std::Vec<'X>):())(v, other)
}
extern function ddlog_std::bigint_pow32 (base: bigint, exp: bit<32>): bigint
function ddlog_std::contains (s1: string, s2: string): bool
{
    ddlog_std::string_contains(s1, s2)
}
function ddlog_std::contains (v: ddlog_std::Vec<'X>, x: 'X): bool
{
    (ddlog_std::vec_contains: function(ddlog_std::Vec<'X>, 'X):bool)(v, x)
}
function ddlog_std::contains (s: ddlog_std::Set<'X>, v: 'X): bool
{
    (ddlog_std::set_contains: function(ddlog_std::Set<'X>, 'X):bool)(s, v)
}
function ddlog_std::contains_key (m: ddlog_std::Map<'K,'V>, k: 'K): bool
{
    (ddlog_std::map_contains_key: function(ddlog_std::Map<'K,'V>, 'K):bool)(m, k)
}
function ddlog_std::count (g: ddlog_std::Group<'K,'V>): ddlog_std::usize
{
    (ddlog_std::group_count: function(ddlog_std::Group<'K,'V>):bit<64>)(g)
}
extern function ddlog_std::default (): 'T
#[return_by_ref = true]
extern function ddlog_std::deref (x: ddlog_std::Ref<'A>): 'A
function ddlog_std::difference (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
{
    (ddlog_std::set_difference: function(ddlog_std::Set<'X>, ddlog_std::Set<'X>):ddlog_std::Set<'X>)(s1, s2)
}
function ddlog_std::ends_with (s: string, suffix: string): bool
{
    ddlog_std::string_ends_with(s, suffix)
}
function ddlog_std::first (g: ddlog_std::Group<'K,'V>): 'V
{
    (ddlog_std::group_first: function(ddlog_std::Group<'K,'V>):'V)(g)
}
function ddlog_std::get (m: ddlog_std::Map<'K,'V>, k: 'K): ddlog_std::Option<'V>
{
    (ddlog_std::map_get: function(ddlog_std::Map<'K,'V>, 'K):ddlog_std::Option<'V>)(m, k)
}
extern function ddlog_std::group_count (g: ddlog_std::Group<'K,'V>): ddlog_std::usize
extern function ddlog_std::group_first (g: ddlog_std::Group<'K,'V>): 'V
extern function ddlog_std::group_key (g: ddlog_std::Group<'K,'V>): 'K
extern function ddlog_std::group_max (g: ddlog_std::Group<'K,'V>): 'V
extern function ddlog_std::group_min (g: ddlog_std::Group<'K,'V>): 'V
extern function ddlog_std::group_nth (g: ddlog_std::Group<'K,'V>, n: ddlog_std::usize): ddlog_std::Option<'V>
extern function ddlog_std::group_set_unions (g: ddlog_std::Group<'K,ddlog_std::Set<'A>>): ddlog_std::Set<'A>
extern function ddlog_std::group_setref_unions (g: ddlog_std::Group<'K,ddlog_std::Ref<ddlog_std::Set<'A>>>): ddlog_std::Ref<ddlog_std::Set<'A>>
extern function ddlog_std::group_sum (g: ddlog_std::Group<'K,'V>): 'V
extern function ddlog_std::group_to_map (g: ddlog_std::Group<'K1,('K2, 'V)>): ddlog_std::Map<'K2,'V>
extern function ddlog_std::group_to_set (g: ddlog_std::Group<'K,'V>): ddlog_std::Set<'V>
extern function ddlog_std::group_to_setmap (g: ddlog_std::Group<'K1,('K2, 'V)>): ddlog_std::Map<'K2,ddlog_std::Set<'V>>
extern function ddlog_std::group_to_vec (g: ddlog_std::Group<'K,'V>): ddlog_std::Vec<'V>
function ddlog_std::group_unzip (g: ddlog_std::Group<'K,('X, 'Y)>): (ddlog_std::Vec<'X>, ddlog_std::Vec<'Y>)
{
    {(var xs: ddlog_std::Vec<'X>) = (ddlog_std::vec_empty: function():ddlog_std::Vec<'X>)();
     {(var ys: ddlog_std::Vec<'Y>) = (ddlog_std::vec_empty: function():ddlog_std::Vec<'Y>)();
      {for (v in g) {
           {((var x: 'X), (var y: 'Y)) = v;
            {(ddlog_std::vec_push: function(mut ddlog_std::Vec<'X>, 'X):())(xs, x);
             (ddlog_std::vec_push: function(mut ddlog_std::Vec<'Y>, 'Y):())(ys, y)}}
       };
       (xs, ys)}}}
}
extern function ddlog_std::hash128 (x: 'X): bit<128>
extern function ddlog_std::hash64 (x: 'X): bit<64>
extern function ddlog_std::hex (x: 'X): string
extern function ddlog_std::htonl (x: bit<32>): bit<32>
extern function ddlog_std::htons (x: bit<16>): bit<16>
function ddlog_std::insert (m: mut ddlog_std::Map<'K,'V>, k: 'K, v: 'V): ()
{
    (ddlog_std::map_insert: function(mut ddlog_std::Map<'K,'V>, 'K, 'V):())(m, k, v)
}
function ddlog_std::insert (s: mut ddlog_std::Set<'X>, v: 'X): ()
{
    (ddlog_std::set_insert: function(mut ddlog_std::Set<'X>, 'X):())(s, v)
}
function ddlog_std::insert_imm (m: ddlog_std::Map<'K,'V>, k: 'K, v: 'V): ddlog_std::Map<'K,'V>
{
    (ddlog_std::map_insert_imm: function(ddlog_std::Map<'K,'V>, 'K, 'V):ddlog_std::Map<'K,'V>)(m, k, v)
}
function ddlog_std::insert_imm (s: ddlog_std::Set<'X>, v: 'X): ddlog_std::Set<'X>
{
    (ddlog_std::set_insert_imm: function(ddlog_std::Set<'X>, 'X):ddlog_std::Set<'X>)(s, v)
}
function ddlog_std::intersection (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
{
    (ddlog_std::set_intersection: function(ddlog_std::Set<'X>, ddlog_std::Set<'X>):ddlog_std::Set<'X>)(s1, s2)
}
function ddlog_std::is_empty (v: ddlog_std::Vec<'X>): bool
{
    (ddlog_std::vec_is_empty: function(ddlog_std::Vec<'X>):bool)(v)
}
function ddlog_std::is_empty (m: ddlog_std::Map<'K,'V>): bool
{
    (ddlog_std::map_is_empty: function(ddlog_std::Map<'K,'V>):bool)(m)
}
function ddlog_std::is_empty (s: ddlog_std::Set<'X>): bool
{
    (ddlog_std::set_is_empty: function(ddlog_std::Set<'X>):bool)(s)
}
function ddlog_std::is_err (res: ddlog_std::Result<'V,'E>): bool
{
    match (res) {
        (ddlog_std::Ok{.res=(_: 'V)}: ddlog_std::Result<'V,'E>) -> false,
        (ddlog_std::Err{.err=(_: 'E)}: ddlog_std::Result<'V,'E>) -> true
    }
}
function ddlog_std::is_none (x: ddlog_std::Option<'A>): bool
{
    match (x) {
        (ddlog_std::None{}: ddlog_std::Option<'A>) -> true,
        (_: ddlog_std::Option<'A>) -> false
    }
}
function ddlog_std::is_ok (res: ddlog_std::Result<'V,'E>): bool
{
    match (res) {
        (ddlog_std::Ok{.res=(_: 'V)}: ddlog_std::Result<'V,'E>) -> true,
        (ddlog_std::Err{.err=(_: 'E)}: ddlog_std::Result<'V,'E>) -> false
    }
}
function ddlog_std::is_some (x: ddlog_std::Option<'A>): bool
{
    match (x) {
        (ddlog_std::Some{.x=(_: 'A)}: ddlog_std::Option<'A>) -> true,
        (_: ddlog_std::Option<'A>) -> false
    }
}
function ddlog_std::join (strings: ddlog_std::Vec<string>, sep: string): string
{
    ddlog_std::string_join(strings, sep)
}
function ddlog_std::key (g: ddlog_std::Group<'K,'V>): 'K
{
    (ddlog_std::group_key: function(ddlog_std::Group<'K,'V>):'K)(g)
}
function ddlog_std::keys (m: ddlog_std::Map<'K,'V>): ddlog_std::Vec<'K>
{
    (ddlog_std::map_keys: function(ddlog_std::Map<'K,'V>):ddlog_std::Vec<'K>)(m)
}
function ddlog_std::len (s: string): ddlog_std::usize
{
    ddlog_std::string_len(s)
}
function ddlog_std::len (v: ddlog_std::Vec<'X>): ddlog_std::usize
{
    (ddlog_std::vec_len: function(ddlog_std::Vec<'X>):bit<64>)(v)
}
function ddlog_std::map (opt: ddlog_std::Option<'A>, f: function('A):'B): ddlog_std::Option<'B>
{
    match (opt) {
        (ddlog_std::None{}: ddlog_std::Option<'A>) -> (ddlog_std::None{}: ddlog_std::Option<'B>),
        (ddlog_std::Some{.x=(var x: 'A)}: ddlog_std::Option<'A>) -> (ddlog_std::Some{.x=f(x)}: ddlog_std::Option<'B>)
    }
}
function ddlog_std::map (res: ddlog_std::Result<'V1,'E>, f: function('V1):'V2): ddlog_std::Result<'V2,'E>
{
    match (res) {
        (ddlog_std::Err{.err=(var e: 'E)}: ddlog_std::Result<'V1,'E>) -> (ddlog_std::Err{.err=e}: ddlog_std::Result<'V2,'E>),
        (ddlog_std::Ok{.res=(var x: 'V1)}: ddlog_std::Result<'V1,'E>) -> (ddlog_std::Ok{.res=f(x)}: ddlog_std::Result<'V2,'E>)
    }
}
extern function ddlog_std::map_contains_key (m: ddlog_std::Map<'K,'V>, k: 'K): bool
extern function ddlog_std::map_empty (): ddlog_std::Map<'K,'V>
function ddlog_std::map_err (res: ddlog_std::Result<'V,'E1>, f: function('E1):'E2): ddlog_std::Result<'V,'E2>
{
    match (res) {
        (ddlog_std::Err{.err=(var e: 'E1)}: ddlog_std::Result<'V,'E1>) -> (ddlog_std::Err{.err=f(e)}: ddlog_std::Result<'V,'E2>),
        (ddlog_std::Ok{.res=(var x: 'V)}: ddlog_std::Result<'V,'E1>) -> (ddlog_std::Ok{.res=x}: ddlog_std::Result<'V,'E2>)
    }
}
extern function ddlog_std::map_get (m: ddlog_std::Map<'K,'V>, k: 'K): ddlog_std::Option<'V>
extern function ddlog_std::map_insert (m: mut ddlog_std::Map<'K,'V>, k: 'K, v: 'V): ()
extern function ddlog_std::map_insert_imm (m: ddlog_std::Map<'K,'V>, k: 'K, v: 'V): ddlog_std::Map<'K,'V>
extern function ddlog_std::map_is_empty (m: ddlog_std::Map<'K,'V>): bool
extern function ddlog_std::map_keys (m: ddlog_std::Map<'K,'V>): ddlog_std::Vec<'K>
extern function ddlog_std::map_remove (m: mut ddlog_std::Map<'K,'V>, k: 'K): ddlog_std::Option<'V>
extern function ddlog_std::map_singleton (k: 'K, v: 'V): ddlog_std::Map<'K,'V>
extern function ddlog_std::map_size (m: ddlog_std::Map<'K,'V>): ddlog_std::usize
extern function ddlog_std::map_union (m1: ddlog_std::Map<'K,'V>, m2: ddlog_std::Map<'K,'V>): ddlog_std::Map<'K,'V>
function ddlog_std::max (x: 'A, y: 'A): 'A
{
    if (x > y) {
        x
    } else {
          y
      }
}
function ddlog_std::max (g: ddlog_std::Group<'K,'V>): 'V
{
    (ddlog_std::group_max: function(ddlog_std::Group<'K,'V>):'V)(g)
}
function ddlog_std::min (x: 'A, y: 'A): 'A
{
    if (x < y) {
        x
    } else {
          y
      }
}
function ddlog_std::min (g: ddlog_std::Group<'K,'V>): 'V
{
    (ddlog_std::group_min: function(ddlog_std::Group<'K,'V>):'V)(g)
}
function ddlog_std::nth (g: ddlog_std::Group<'K,'V>, n: ddlog_std::usize): ddlog_std::Option<'V>
{
    (ddlog_std::group_nth: function(ddlog_std::Group<'K,'V>, bit<64>):ddlog_std::Option<'V>)(g, n)
}
function ddlog_std::nth (v: ddlog_std::Vec<'X>, n: ddlog_std::usize): ddlog_std::Option<'X>
{
    (ddlog_std::vec_nth: function(ddlog_std::Vec<'X>, bit<64>):ddlog_std::Option<'X>)(v, n)
}
function ddlog_std::nth (s: ddlog_std::Set<'X>, n: ddlog_std::usize): ddlog_std::Option<'X>
{
    (ddlog_std::set_nth: function(ddlog_std::Set<'X>, bit<64>):ddlog_std::Option<'X>)(s, n)
}
extern function ddlog_std::ntohl (x: bit<32>): bit<32>
extern function ddlog_std::ntohs (x: bit<16>): bit<16>
extern function ddlog_std::option_unwrap_or_default (opt: ddlog_std::Option<'A>): 'A
extern function ddlog_std::parse_dec_i64 (s: string): ddlog_std::Option<signed<64>>
extern function ddlog_std::parse_dec_u64 (s: string): ddlog_std::Option<bit<64>>
function ddlog_std::pow32 (base: ddlog_std::u8, exp: bit<32>): ddlog_std::u8
{
    ddlog_std::u8_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::u16, exp: bit<32>): ddlog_std::u16
{
    ddlog_std::u16_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::u32, exp: bit<32>): ddlog_std::u32
{
    ddlog_std::u32_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::u64, exp: bit<32>): ddlog_std::u64
{
    ddlog_std::u64_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::u128, exp: bit<32>): ddlog_std::u128
{
    ddlog_std::u128_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::s8, exp: bit<32>): ddlog_std::s8
{
    ddlog_std::s8_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::s16, exp: bit<32>): ddlog_std::s16
{
    ddlog_std::s16_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::s32, exp: bit<32>): ddlog_std::s32
{
    ddlog_std::s32_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::s64, exp: bit<32>): ddlog_std::s64
{
    ddlog_std::s64_pow32(base, exp)
}
function ddlog_std::pow32 (base: ddlog_std::s128, exp: bit<32>): ddlog_std::s128
{
    ddlog_std::s128_pow32(base, exp)
}
function ddlog_std::pow32 (base: bigint, exp: bit<32>): bigint
{
    ddlog_std::bigint_pow32(base, exp)
}
function ddlog_std::push (v: mut ddlog_std::Vec<'X>, x: 'X): ()
{
    (ddlog_std::vec_push: function(mut ddlog_std::Vec<'X>, 'X):())(v, x)
}
function ddlog_std::push_imm (v: ddlog_std::Vec<'X>, x: 'X): ddlog_std::Vec<'X>
{
    (ddlog_std::vec_push_imm: function(ddlog_std::Vec<'X>, 'X):ddlog_std::Vec<'X>)(v, x)
}
extern function ddlog_std::range (from: 'A, to: 'A, step: 'A): ddlog_std::Vec<'A>
extern function ddlog_std::ref_new (x: 'A): ddlog_std::Ref<'A>
function ddlog_std::remove (m: mut ddlog_std::Map<'K,'V>, k: 'K): ddlog_std::Option<'V>
{
    (ddlog_std::map_remove: function(mut ddlog_std::Map<'K,'V>, 'K):ddlog_std::Option<'V>)(m, k)
}
function ddlog_std::replace (s: string, from: string, to: string): string
{
    ddlog_std::string_replace(s, from, to)
}
function ddlog_std::resize (v: mut ddlog_std::Vec<'X>, new_len: ddlog_std::usize, value: 'X): ()
{
    (ddlog_std::vec_resize: function(mut ddlog_std::Vec<'X>, bit<64>, 'X):())(v, new_len, value)
}
extern function ddlog_std::result_unwrap_or_default (res: ddlog_std::Result<'V,'E>): 'V
function ddlog_std::reverse (s: string): string
{
    ddlog_std::string_reverse(s)
}
extern function ddlog_std::s128_pow32 (base: ddlog_std::s128, exp: bit<32>): ddlog_std::s128
extern function ddlog_std::s16_pow32 (base: ddlog_std::s16, exp: bit<32>): ddlog_std::s16
extern function ddlog_std::s32_pow32 (base: ddlog_std::s32, exp: bit<32>): ddlog_std::s32
extern function ddlog_std::s64_pow32 (base: ddlog_std::s64, exp: bit<32>): ddlog_std::s64
extern function ddlog_std::s8_pow32 (base: ddlog_std::s8, exp: bit<32>): ddlog_std::s8
extern function ddlog_std::set_contains (s: ddlog_std::Set<'X>, v: 'X): bool
extern function ddlog_std::set_difference (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
extern function ddlog_std::set_empty (): ddlog_std::Set<'X>
extern function ddlog_std::set_insert (s: mut ddlog_std::Set<'X>, v: 'X): ()
extern function ddlog_std::set_insert_imm (s: ddlog_std::Set<'X>, v: 'X): ddlog_std::Set<'X>
extern function ddlog_std::set_intersection (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
extern function ddlog_std::set_is_empty (s: ddlog_std::Set<'X>): bool
extern function ddlog_std::set_nth (s: ddlog_std::Set<'X>, n: ddlog_std::usize): ddlog_std::Option<'X>
extern function ddlog_std::set_singleton (x: 'X): ddlog_std::Set<'X>
extern function ddlog_std::set_size (s: ddlog_std::Set<'X>): ddlog_std::usize
extern function ddlog_std::set_to_vec (s: ddlog_std::Set<'A>): ddlog_std::Vec<'A>
extern function ddlog_std::set_union (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
extern function ddlog_std::set_unions (sets: ddlog_std::Vec<ddlog_std::Set<'X>>): ddlog_std::Set<'X>
function ddlog_std::setref_unions (g: ddlog_std::Group<'K,ddlog_std::Ref<ddlog_std::Set<'A>>>): ddlog_std::Ref<ddlog_std::Set<'A>>
{
    (ddlog_std::group_setref_unions: function(ddlog_std::Group<'K,ddlog_std::Ref<ddlog_std::Set<'A>>>):ddlog_std::Ref<ddlog_std::Set<'A>>)(g)
}
function ddlog_std::size (m: ddlog_std::Map<'K,'V>): ddlog_std::usize
{
    (ddlog_std::map_size: function(ddlog_std::Map<'K,'V>):bit<64>)(m)
}
function ddlog_std::size (s: ddlog_std::Set<'X>): ddlog_std::usize
{
    (ddlog_std::set_size: function(ddlog_std::Set<'X>):bit<64>)(s)
}
function ddlog_std::sort (v: mut ddlog_std::Vec<'X>): ()
{
    (ddlog_std::vec_sort: function(mut ddlog_std::Vec<'X>):())(v)
}
function ddlog_std::sort_imm (v: ddlog_std::Vec<'X>): ddlog_std::Vec<'X>
{
    (ddlog_std::vec_sort_imm: function(ddlog_std::Vec<'X>):ddlog_std::Vec<'X>)(v)
}
function ddlog_std::split (s: string, sep: string): ddlog_std::Vec<string>
{
    ddlog_std::string_split(s, sep)
}
function ddlog_std::starts_with (s: string, prefix: string): bool
{
    ddlog_std::string_starts_with(s, prefix)
}
extern function ddlog_std::str_to_lower (s: string): string
extern function ddlog_std::string_contains (s1: string, s2: string): bool
extern function ddlog_std::string_ends_with (s: string, suffix: string): bool
extern function ddlog_std::string_join (strings: ddlog_std::Vec<string>, sep: string): string
extern function ddlog_std::string_len (s: string): ddlog_std::usize
extern function ddlog_std::string_replace (s: string, from: string, to: string): string
extern function ddlog_std::string_reverse (s: string): string
extern function ddlog_std::string_split (s: string, sep: string): ddlog_std::Vec<string>
extern function ddlog_std::string_starts_with (s: string, prefix: string): bool
extern function ddlog_std::string_substr (s: string, start: ddlog_std::usize, end: ddlog_std::usize): string
extern function ddlog_std::string_to_bytes (s: string): ddlog_std::Vec<ddlog_std::u8>
extern function ddlog_std::string_to_lowercase (s: string): string
extern function ddlog_std::string_to_uppercase (s: string): string
extern function ddlog_std::string_trim (s: string): string
function ddlog_std::substr (s: string, start: ddlog_std::usize, end: ddlog_std::usize): string
{
    ddlog_std::string_substr(s, start, end)
}
function ddlog_std::swap_nth (v: mut ddlog_std::Vec<'X>, idx: ddlog_std::usize, value: mut 'X): bool
{
    (ddlog_std::vec_swap_nth: function(mut ddlog_std::Vec<'X>, bit<64>, mut 'X):bool)(v, idx, value)
}
function ddlog_std::to_bytes (s: string): ddlog_std::Vec<ddlog_std::u8>
{
    ddlog_std::string_to_bytes(s)
}
function ddlog_std::to_lowercase (s: string): string
{
    ddlog_std::string_to_lowercase(s)
}
function ddlog_std::to_map (g: ddlog_std::Group<'K1,('K2, 'V)>): ddlog_std::Map<'K2,'V>
{
    (ddlog_std::group_to_map: function(ddlog_std::Group<'K1,('K2, 'V)>):ddlog_std::Map<'K2,'V>)(g)
}
function ddlog_std::to_set (o: ddlog_std::Option<'X>): ddlog_std::Set<'X>
{
    match (o) {
        (ddlog_std::Some{.x=(var x: 'X)}: ddlog_std::Option<'X>) -> (ddlog_std::set_singleton: function('X):ddlog_std::Set<'X>)(x),
        (ddlog_std::None{}: ddlog_std::Option<'X>) -> (ddlog_std::set_empty: function():ddlog_std::Set<'X>)()
    }
}
function ddlog_std::to_set (g: ddlog_std::Group<'K,'V>): ddlog_std::Set<'V>
{
    (ddlog_std::group_to_set: function(ddlog_std::Group<'K,'V>):ddlog_std::Set<'V>)(g)
}
function ddlog_std::to_set (s: ddlog_std::Vec<'A>): ddlog_std::Set<'A>
{
    (ddlog_std::vec_to_set: function(ddlog_std::Vec<'A>):ddlog_std::Set<'A>)(s)
}
function ddlog_std::to_setmap (g: ddlog_std::Group<'K1,('K2, 'V)>): ddlog_std::Map<'K2,ddlog_std::Set<'V>>
{
    (ddlog_std::group_to_setmap: function(ddlog_std::Group<'K1,('K2, 'V)>):ddlog_std::Map<'K2,ddlog_std::Set<'V>>)(g)
}
function ddlog_std::to_string (ts: ddlog_std::DDNestedTS): string
{
    (((("(" ++ (ddlog_std::__builtin_2string: function(bit<64>):string)(ts.epoch)) ++ ",") ++ (ddlog_std::__builtin_2string: function(bit<64>):string)(ts.iter)) ++ ")")
}
function ddlog_std::to_string (x: bool): string
{
    (ddlog_std::__builtin_2string: function(bool):string)(x)
}
function ddlog_std::to_string (x: bigint): string
{
    (ddlog_std::__builtin_2string: function(bigint):string)(x)
}
function ddlog_std::to_string (x: float): string
{
    (ddlog_std::__builtin_2string: function(float):string)(x)
}
function ddlog_std::to_string (x: double): string
{
    (ddlog_std::__builtin_2string: function(double):string)(x)
}
function ddlog_std::to_string (x: ddlog_std::s8): string
{
    (ddlog_std::__builtin_2string: function(signed<8>):string)(x)
}
function ddlog_std::to_string (x: ddlog_std::s16): string
{
    (ddlog_std::__builtin_2string: function(signed<16>):string)(x)
}
function ddlog_std::to_string (x: ddlog_std::s32): string
{
    (ddlog_std::__builtin_2string: function(signed<32>):string)(x)
}
function ddlog_std::to_string (x: ddlog_std::s64): string
{
    (ddlog_std::__builtin_2string: function(signed<64>):string)(x)
}
function ddlog_std::to_string (x: ddlog_std::s128): string
{
    (ddlog_std::__builtin_2string: function(signed<128>):string)(x)
}
function ddlog_std::to_string (x: ddlog_std::u8): string
{
    (ddlog_std::__builtin_2string: function(bit<8>):string)(x)
}
function ddlog_std::to_string (x: ddlog_std::u16): string
{
    (ddlog_std::__builtin_2string: function(bit<16>):string)(x)
}
function ddlog_std::to_string (x: ddlog_std::u32): string
{
    (ddlog_std::__builtin_2string: function(bit<32>):string)(x)
}
function ddlog_std::to_string (x: ddlog_std::u64): string
{
    (ddlog_std::__builtin_2string: function(bit<64>):string)(x)
}
function ddlog_std::to_string (x: ddlog_std::u128): string
{
    (ddlog_std::__builtin_2string: function(bit<128>):string)(x)
}
function ddlog_std::to_string (x: string): string
{
    (ddlog_std::__builtin_2string: function(string):string)(x)
}
function ddlog_std::to_uppercase (s: string): string
{
    ddlog_std::string_to_uppercase(s)
}
function ddlog_std::to_vec (o: ddlog_std::Option<'X>): ddlog_std::Vec<'X>
{
    match (o) {
        (ddlog_std::Some{.x=(var x: 'X)}: ddlog_std::Option<'X>) -> (ddlog_std::vec_singleton: function('X):ddlog_std::Vec<'X>)(x),
        (ddlog_std::None{}: ddlog_std::Option<'X>) -> (ddlog_std::vec_empty: function():ddlog_std::Vec<'X>)()
    }
}
function ddlog_std::to_vec (g: ddlog_std::Group<'K,'V>): ddlog_std::Vec<'V>
{
    (ddlog_std::group_to_vec: function(ddlog_std::Group<'K,'V>):ddlog_std::Vec<'V>)(g)
}
function ddlog_std::to_vec (s: ddlog_std::Set<'A>): ddlog_std::Vec<'A>
{
    (ddlog_std::set_to_vec: function(ddlog_std::Set<'A>):ddlog_std::Vec<'A>)(s)
}
function ddlog_std::trim (s: string): string
{
    ddlog_std::string_trim(s)
}
function ddlog_std::truncate (v: mut ddlog_std::Vec<'X>, len: ddlog_std::usize): ()
{
    (ddlog_std::vec_truncate: function(mut ddlog_std::Vec<'X>, bit<64>):())(v, len)
}
extern function ddlog_std::u128_pow32 (base: ddlog_std::u128, exp: bit<32>): ddlog_std::u128
extern function ddlog_std::u16_pow32 (base: ddlog_std::u16, exp: bit<32>): ddlog_std::u16
extern function ddlog_std::u32_pow32 (base: ddlog_std::u32, exp: bit<32>): ddlog_std::u32
extern function ddlog_std::u64_pow32 (base: ddlog_std::u64, exp: bit<32>): ddlog_std::u64
extern function ddlog_std::u8_pow32 (base: ddlog_std::u8, exp: bit<32>): ddlog_std::u8
function ddlog_std::union (m1: ddlog_std::Map<'K,'V>, m2: ddlog_std::Map<'K,'V>): ddlog_std::Map<'K,'V>
{
    (ddlog_std::map_union: function(ddlog_std::Map<'K,'V>, ddlog_std::Map<'K,'V>):ddlog_std::Map<'K,'V>)(m1, m2)
}
function ddlog_std::union (s1: ddlog_std::Set<'X>, s2: ddlog_std::Set<'X>): ddlog_std::Set<'X>
{
    (ddlog_std::set_union: function(ddlog_std::Set<'X>, ddlog_std::Set<'X>):ddlog_std::Set<'X>)(s1, s2)
}
function ddlog_std::unions (sets: ddlog_std::Vec<ddlog_std::Set<'X>>): ddlog_std::Set<'X>
{
    (ddlog_std::set_unions: function(ddlog_std::Vec<ddlog_std::Set<'X>>):ddlog_std::Set<'X>)(sets)
}
function ddlog_std::unwrap_or (x: ddlog_std::Option<'A>, def: 'A): 'A
{
    match (x) {
        (ddlog_std::Some{.x=(var v: 'A)}: ddlog_std::Option<'A>) -> v,
        (ddlog_std::None{}: ddlog_std::Option<'A>) -> def
    }
}
function ddlog_std::unwrap_or (res: ddlog_std::Result<'V,'E>, def: 'V): 'V
{
    match (res) {
        (ddlog_std::Ok{.res=(var v: 'V)}: ddlog_std::Result<'V,'E>) -> v,
        (ddlog_std::Err{.err=(_: 'E)}: ddlog_std::Result<'V,'E>) -> def
    }
}
function ddlog_std::unwrap_or_default (opt: ddlog_std::Option<'A>): 'A
{
    (ddlog_std::option_unwrap_or_default: function(ddlog_std::Option<'A>):'A)(opt)
}
function ddlog_std::unwrap_or_default (res: ddlog_std::Result<'V,'E>): 'V
{
    (ddlog_std::result_unwrap_or_default: function(ddlog_std::Result<'V,'E>):'V)(res)
}
function ddlog_std::update_nth (v: mut ddlog_std::Vec<'X>, idx: ddlog_std::usize, value: 'X): bool
{
    (ddlog_std::vec_update_nth: function(mut ddlog_std::Vec<'X>, bit<64>, 'X):bool)(v, idx, value)
}
extern function ddlog_std::vec_append (v: mut ddlog_std::Vec<'X>, other: ddlog_std::Vec<'X>): ()
extern function ddlog_std::vec_contains (v: ddlog_std::Vec<'X>, x: 'X): bool
extern function ddlog_std::vec_empty (): ddlog_std::Vec<'A>
extern function ddlog_std::vec_is_empty (v: ddlog_std::Vec<'X>): bool
extern function ddlog_std::vec_len (v: ddlog_std::Vec<'X>): ddlog_std::usize
extern function ddlog_std::vec_nth (v: ddlog_std::Vec<'X>, n: ddlog_std::usize): ddlog_std::Option<'X>
extern function ddlog_std::vec_push (v: mut ddlog_std::Vec<'X>, x: 'X): ()
extern function ddlog_std::vec_push_imm (v: ddlog_std::Vec<'X>, x: 'X): ddlog_std::Vec<'X>
extern function ddlog_std::vec_resize (v: mut ddlog_std::Vec<'X>, new_len: ddlog_std::usize, value: 'X): ()
extern function ddlog_std::vec_set_nth (v: ddlog_std::Vec<'X>, n: ddlog_std::usize, value: 'X): ()
extern function ddlog_std::vec_singleton (x: 'X): ddlog_std::Vec<'X>
extern function ddlog_std::vec_sort (v: mut ddlog_std::Vec<'X>): ()
extern function ddlog_std::vec_sort_imm (v: ddlog_std::Vec<'X>): ddlog_std::Vec<'X>
extern function ddlog_std::vec_swap_nth (v: mut ddlog_std::Vec<'X>, idx: ddlog_std::usize, value: mut 'X): bool
extern function ddlog_std::vec_to_set (s: ddlog_std::Vec<'A>): ddlog_std::Set<'A>
extern function ddlog_std::vec_truncate (v: mut ddlog_std::Vec<'X>, len: ddlog_std::usize): ()
extern function ddlog_std::vec_update_nth (v: mut ddlog_std::Vec<'X>, idx: ddlog_std::usize, value: 'X): bool
extern function ddlog_std::vec_with_capacity (len: ddlog_std::usize): ddlog_std::Vec<'A>
extern function ddlog_std::vec_with_length (len: ddlog_std::usize, x: 'A): ddlog_std::Vec<'A>
extern function debug::debug_event (operator_id: debug::DDlogOpId, w: ddlog_std::DDWeight, ts: 'T1, operator_type: string, input1: 'A1, out: 'A2): ()
extern function debug::debug_event_join (operator_id: debug::DDlogOpId, w: ddlog_std::DDWeight, ts: 'T1, input1: 'A1, input2: 'A2, out: 'A3): ()
extern function debug::debug_split_group (g: ddlog_std::Group<'K,('I, 'V)>): (ddlog_std::Vec<'I>, ddlog_std::Group<'K,'V>)
function evens (vec: ddlog_std::Vec<bigint>): ddlog_std::Vec<bigint>
{
    {(var res: ddlog_std::Vec<bigint>) = (ddlog_std::vec_empty: function():ddlog_std::Vec<bigint>)();
     {for (x in vec) {
          {if ((x % 2) != 0) {
               (continue: ())
           } else {
                 ()
             };
           {(ddlog_std::vec_push: function(mut ddlog_std::Vec<bigint>, bigint):())(res, x);
            ()}}
      };
      res}}
}
function get_price_in_cents (inventory: ddlog_std::Map<string,string>, item: string): ddlog_std::Option<ddlog_std::u64>
{
    match ((ddlog_std::get: function(ddlog_std::Map<string,string>, string):ddlog_std::Option<string>)(inventory, item)) {
        (ddlog_std::None{}: ddlog_std::Option<string>) -> (ddlog_std::None{}: ddlog_std::Option<bit<64>>),
        (ddlog_std::Some{.x=(var price: string)}: ddlog_std::Option<string>) -> match (ddlog_std::parse_dec_u64(price)) {
                                                                                    (ddlog_std::None{}: ddlog_std::Option<bit<64>>) -> (ddlog_std::None{}: ddlog_std::Option<bit<64>>),
                                                                                    (ddlog_std::Some{.x=(var p: bit<64>)}: ddlog_std::Option<bit<64>>) -> (ddlog_std::Some{.x=(64'd100 * p)}: ddlog_std::Option<bit<64>>)
                                                                                }
    }
}
function get_price_in_cents_ (inventory: ddlog_std::Map<string,string>, item: string): ddlog_std::Option<ddlog_std::u64>
{
    (ddlog_std::Some{.x=(match (ddlog_std::parse_dec_u64(match ((ddlog_std::get: function(ddlog_std::Map<string,string>, string):ddlog_std::Option<string>)(inventory, item)) {
                                                             (ddlog_std::None{}: ddlog_std::Option<string>) -> ((return (ddlog_std::None{}: ddlog_std::Option<ddlog_std::u64>)): string),
                                                             (ddlog_std::Some{.x=(var __x: string)}: ddlog_std::Option<string>) -> __x
                                                         })) {
                             (ddlog_std::None{}: ddlog_std::Option<bit<64>>) -> ((return (ddlog_std::None{}: ddlog_std::Option<ddlog_std::u64>)): bit<64>),
                             (ddlog_std::Some{.x=(var __x: bit<64>)}: ddlog_std::Option<bit<64>>) -> __x
                         } * 64'd100)}: ddlog_std::Option<bit<64>>)
}
function get_price_in_cents_unwrap (inventory: ddlog_std::Map<string,string>, item: string): ddlog_std::u64
{
    ((ddlog_std::unwrap_or: function(ddlog_std::Option<bit<64>>, bit<64>):bit<64>)(ddlog_std::parse_dec_u64((ddlog_std::unwrap_or_default: function(ddlog_std::Option<string>):string)((ddlog_std::get: function(ddlog_std::Map<string,string>, string):ddlog_std::Option<string>)(inventory, item))), 64'd0) * 64'd100)
}
#[has_side_effects = true]
extern function inspect_log::log (filename: string, msg: string): ()
function internment::contains (s1: internment::istring, s2: string): bool
{
    internment::istring_contains(s1, s2)
}
function internment::ends_with (s: internment::istring, suffix: string): bool
{
    internment::istring_ends_with(s, suffix)
}
extern function internment::intern (s: 'A): internment::Intern<'A>
extern function internment::istring_contains (s1: internment::istring, s2: string): bool
extern function internment::istring_ends_with (s: internment::istring, suffix: string): bool
extern function internment::istring_join (strings: ddlog_std::Vec<internment::istring>, sep: string): string
extern function internment::istring_len (s: internment::istring): ddlog_std::usize
extern function internment::istring_replace (s: internment::istring, from: string, to: string): string
extern function internment::istring_reverse (s: internment::istring): string
extern function internment::istring_split (s: internment::istring, sep: string): ddlog_std::Vec<string>
extern function internment::istring_starts_with (s: internment::istring, prefix: string): bool
extern function internment::istring_substr (s: internment::istring, start: ddlog_std::usize, end: ddlog_std::usize): string
extern function internment::istring_to_bytes (s: internment::istring): ddlog_std::Vec<ddlog_std::u8>
extern function internment::istring_to_lowercase (s: internment::istring): string
extern function internment::istring_to_uppercase (s: internment::istring): string
extern function internment::istring_trim (s: internment::istring): string
#[return_by_ref = true]
extern function internment::ival (s: internment::Intern<'A>): 'A
function internment::join (strings: ddlog_std::Vec<internment::istring>, sep: string): string
{
    internment::istring_join(strings, sep)
}
function internment::len (s: internment::istring): ddlog_std::usize
{
    internment::istring_len(s)
}
function internment::replace (s: internment::istring, from: string, to: string): string
{
    internment::istring_replace(s, from, to)
}
function internment::reverse (s: internment::istring): string
{
    internment::istring_reverse(s)
}
function internment::split (s: internment::istring, sep: string): ddlog_std::Vec<string>
{
    internment::istring_split(s, sep)
}
function internment::starts_with (s: internment::istring, prefix: string): bool
{
    internment::istring_starts_with(s, prefix)
}
function internment::substr (s: internment::istring, start: ddlog_std::usize, end: ddlog_std::usize): string
{
    internment::istring_substr(s, start, end)
}
function internment::to_bytes (s: internment::istring): ddlog_std::Vec<ddlog_std::u8>
{
    internment::istring_to_bytes(s)
}
function internment::to_lowercase (s: internment::istring): string
{
    internment::istring_to_lowercase(s)
}
function internment::to_string (s: internment::istring): string
{
    (internment::ival: function(internment::Intern<string>):string)(s)
}
function internment::to_uppercase (s: internment::istring): string
{
    internment::istring_to_uppercase(s)
}
function internment::trim (s: internment::istring): string
{
    internment::istring_trim(s)
}
function inventory (): ddlog_std::Map<string,string>
{
    (ddlog_std::insert_imm: function(ddlog_std::Map<string,string>, string, string):ddlog_std::Map<string,string>)((ddlog_std::map_singleton: function(string, string):ddlog_std::Map<string,string>)("Falcon 9", "62000000"), "Soyuz", "180000000")
}
function ip_from_bytes (b3: bit<8>, b2: bit<8>, b1: bit<8>, b0: bit<8>): ip_addr_t
{
    (IPAddr{.addr=(((b3 ++ b2) ++ b1) ++ b0)}: ip_addr_t)
}
function is_multicast_addr (ip: ip_addr_t): bool
{
    (ip.addr[31:28] == 4'd14)
}
function is_target_audience (person: Person): bool
{
    ((person.nationality == "USA") and (person.occupation == "student"))
}
#[has_side_effects = true]
extern function log::log (module: log::module_t, level: log::log_level_t, msg: string): ()
function pkt_ip4 (pkt: eth_pkt_t): ip4_pkt_t
{
    match (pkt) {
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP4{.ip4=(var ip4: ip4_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> ip4,
        (_: eth_pkt_t) -> (IP4Pkt{.ttl=8'd0, .src=32'd0, .dst=32'd0, .payload=(IPOther{}: ip_payload_t)}: ip4_pkt_t)
    }
}
function pkt_ip4_ (pkt: eth_pkt_t): ddlog_std::Option<ip4_pkt_t>
{
    match (pkt) {
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP4{.ip4=(var ip4: ip4_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> (ddlog_std::Some{.x=ip4}: ddlog_std::Option<ip4_pkt_t>),
        (_: eth_pkt_t) -> (ddlog_std::None{}: ddlog_std::Option<ip4_pkt_t>)
    }
}
function pkt_udp_port (pkt: eth_pkt_t): bit<16>
{
    match (pkt) {
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP4{.ip4=(IP4Pkt{.ttl=(_: bit<8>), .src=(_: bit<32>), .dst=(_: bit<32>), .payload=(IPUDP{.udp=(UDPPkt{.src=(_: bit<16>), .dst=(var port: bit<16>), .len=(_: bit<16>)}: udp_pkt_t)}: ip_payload_t)}: ip4_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> port,
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP6{.ip6=(IP6Pkt{.ttl=(_: bit<8>), .src=(_: bit<128>), .dst=(_: bit<128>), .payload=(IPUDP{.udp=(UDPPkt{.src=(_: bit<16>), .dst=(var port: bit<16>), .len=(_: bit<16>)}: udp_pkt_t)}: ip_payload_t)}: ip6_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> port,
        (_: eth_pkt_t) -> 16'd0
    }
}
function pkt_udp_port2 (pkt: eth_pkt_t): ddlog_std::Option<bit<16>>
{
    match (pkt) {
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP4{.ip4=(IP4Pkt{.ttl=(_: bit<8>), .src=(_: bit<32>), .dst=(_: bit<32>), .payload=(IPUDP{.udp=(UDPPkt{.src=(_: bit<16>), .dst=(var port: bit<16>), .len=(_: bit<16>)}: udp_pkt_t)}: ip_payload_t)}: ip4_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> (ddlog_std::Some{.x=port}: ddlog_std::Option<bit<16>>),
        (EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP6{.ip6=(IP6Pkt{.ttl=(_: bit<8>), .src=(_: bit<128>), .dst=(_: bit<128>), .payload=(IPUDP{.udp=(UDPPkt{.src=(_: bit<16>), .dst=(var port: bit<16>), .len=(_: bit<16>)}: udp_pkt_t)}: ip_payload_t)}: ip6_pkt_t)}: eth_payload_t)}: eth_pkt_t) -> (ddlog_std::Some{.x=port}: ddlog_std::Option<bit<16>>),
        (_: eth_pkt_t) -> (ddlog_std::None{}: ddlog_std::Option<bit<16>>)
    }
}
function prefixBefore (vec: ddlog_std::Vec<'A>, v: 'A): ddlog_std::Vec<'A>
{
    {(var res: ddlog_std::Vec<'A>) = (ddlog_std::vec_empty: function():ddlog_std::Vec<'A>)();
     {for (x in vec) {
          {if (x == v) {
               (break: ())
           } else {
                 ()
             };
           {(ddlog_std::vec_push: function(mut ddlog_std::Vec<'A>, 'A):())(res, x);
            ()}}
      };
      res}}
}
function split_ip_list (x: string): ddlog_std::Vec<string>
{
    ddlog_std::split(x, " ")
}
extern function string_slice_unsafe (x: string, from: bit<64>, to: bit<64>): string
function tcp6_packet (ethsrc: bit<48>, ethdst: bit<48>, ipsrc: ip6_addr_t, ipdst: ip6_addr_t, srcport: bit<16>, dstport: bit<16>): eth_pkt_t
{
    (EthPacket{.src=ethsrc, .dst=ethdst, .payload=(EthIP6{.ip6=(IP6Pkt{.ttl=8'd10, .src=ipsrc, .dst=ipdst, .payload=(IPTCP{.tcp=(TCPPkt{.src=srcport, .dst=dstport, .flags=9'd0}: tcp_pkt_t)}: ip_payload_t)}: ip6_pkt_t)}: eth_payload_t)}: eth_pkt_t)
}
function test_vector_transformers (): ddlog_std::u64
{
    {(var vec: ddlog_std::Vec<ddlog_std::Vec<bit<64>>>) = {(var __vec: ddlog_std::Vec<ddlog_std::Vec<bit<64>>>) = (ddlog_std::vec_with_capacity: function(bit<64>):ddlog_std::Vec<ddlog_std::Vec<bit<64>>>)(64'd3);
                                                           {(ddlog_std::push: function(mut ddlog_std::Vec<ddlog_std::Vec<bit<64>>>, ddlog_std::Vec<bit<64>>):())(__vec, {(var __vec: ddlog_std::Vec<bit<64>>) = (ddlog_std::vec_with_capacity: function(bit<64>):ddlog_std::Vec<bit<64>>)(64'd3);
                                                                                                                                                                         {(ddlog_std::push: function(mut ddlog_std::Vec<bit<64>>, bit<64>):())(__vec, 64'd1);
                                                                                                                                                                          {(ddlog_std::push: function(mut ddlog_std::Vec<bit<64>>, bit<64>):())(__vec, 64'd2);
                                                                                                                                                                           {(ddlog_std::push: function(mut ddlog_std::Vec<bit<64>>, bit<64>):())(__vec, 64'd3);
                                                                                                                                                                            __vec}}}});
                                                            {(ddlog_std::push: function(mut ddlog_std::Vec<ddlog_std::Vec<bit<64>>>, ddlog_std::Vec<bit<64>>):())(__vec, {(var __vec: ddlog_std::Vec<bit<64>>) = (ddlog_std::vec_with_capacity: function(bit<64>):ddlog_std::Vec<bit<64>>)(64'd3);
                                                                                                                                                                          {(ddlog_std::push: function(mut ddlog_std::Vec<bit<64>>, bit<64>):())(__vec, 64'd4);
                                                                                                                                                                           {(ddlog_std::push: function(mut ddlog_std::Vec<bit<64>>, bit<64>):())(__vec, 64'd5);
                                                                                                                                                                            {(ddlog_std::push: function(mut ddlog_std::Vec<bit<64>>, bit<64>):())(__vec, 64'd6);
                                                                                                                                                                             __vec}}}});
                                                             {(ddlog_std::push: function(mut ddlog_std::Vec<ddlog_std::Vec<bit<64>>>, ddlog_std::Vec<bit<64>>):())(__vec, {(var __vec: ddlog_std::Vec<bit<64>>) = (ddlog_std::vec_with_capacity: function(bit<64>):ddlog_std::Vec<bit<64>>)(64'd1);
                                                                                                                                                                           {(ddlog_std::push: function(mut ddlog_std::Vec<bit<64>>, bit<64>):())(__vec, 64'd7);
                                                                                                                                                                            __vec}});
                                                              __vec}}}};
     (vec::fold: function(ddlog_std::Vec<bit<64>>, function(bit<64>, bit<64>):bit<64>, bit<64>):bit<64>)((vec::flatmap: function(ddlog_std::Vec<ddlog_std::Vec<bit<64>>>, function(ddlog_std::Vec<bit<64>>):ddlog_std::Vec<bit<64>>):ddlog_std::Vec<bit<64>>)((vec::filter: function(ddlog_std::Vec<ddlog_std::Vec<bit<64>>>, function(ddlog_std::Vec<bit<64>>):bool):ddlog_std::Vec<ddlog_std::Vec<bit<64>>>)(vec, (function(v: ddlog_std::Vec<bit<64>>):bool{((ddlog_std::len: function(ddlog_std::Vec<bit<64>>):bit<64>)(v) > 64'd1)})), (function(v: ddlog_std::Vec<bit<64>>):ddlog_std::Vec<bit<64>>{{(var res: ddlog_std::Vec<bit<64>>) = v;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           {(ddlog_std::truncate: function(mut ddlog_std::Vec<bit<64>>, bit<64>):())(res, 64'd2);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            res}}})), (function(acc: bit<64>, x: bit<64>):bit<64>{(acc + x)}), 64'd0)}
}
function times2 (x: ddlog_std::s64): ddlog_std::s64
{
    (x << 32'd1)
}
function to_string (ip: ip_addr_t): string
{
    ((((((("" ++ (ddlog_std::__builtin_2string: function(bit<8>):string)(ip.addr[31:24])) ++ ".") ++ (ddlog_std::__builtin_2string: function(bit<8>):string)(ip.addr[23:16])) ++ ".") ++ (ddlog_std::__builtin_2string: function(bit<8>):string)(ip.addr[15:8])) ++ ".") ++ (ddlog_std::__builtin_2string: function(bit<8>):string)(ip.addr[7:0]))
}
function to_string (mac: mac_addr_t): string
{
    ((((((((((("" ++ (ddlog_std::hex: function(bit<8>):string)(mac.addr[47:40])) ++ ":") ++ (ddlog_std::hex: function(bit<8>):string)(mac.addr[39:32])) ++ ":") ++ (ddlog_std::hex: function(bit<8>):string)(mac.addr[31:24])) ++ ":") ++ (ddlog_std::hex: function(bit<8>):string)(mac.addr[23:16])) ++ ":") ++ (ddlog_std::hex: function(bit<8>):string)(mac.addr[15:8])) ++ ":") ++ (ddlog_std::hex: function(bit<8>):string)(mac.addr[7:0]))
}
function to_string (h: nethost_t): string
{
    ((("Host: IP=" ++ (to_string: function(ip_addr_t):string)(h.ip)) ++ ", MAC=") ++ (to_string: function(mac_addr_t):string)(h.mac))
}
function vec::all (v: ddlog_std::Vec<'A>, f: function('A):bool): bool
{
    {for (x in v) {
         if (not f(x)) {
             ((return false): ())
         } else {
               ()
           }
     };
     true}
}
function vec::any (v: ddlog_std::Vec<'A>, f: function('A):bool): bool
{
    {for (x in v) {
         if f(x) {
             ((return true): ())
         } else {
               ()
           }
     };
     false}
}
function vec::count (v: ddlog_std::Vec<'A>, f: function('A):bool): ddlog_std::usize
{
    {(var cnt: bit<64>) = 64'd0;
     {for (x in v) {
          if f(x) {
              cnt = (cnt + 64'd1)
          } else {
                ()
            }
      };
      cnt}}
}
function vec::filter (v: ddlog_std::Vec<'A>, f: function('A):bool): ddlog_std::Vec<'A>
{
    {(var res: ddlog_std::Vec<'A>) = (ddlog_std::vec_empty: function():ddlog_std::Vec<'A>)();
     {for (x in v) {
          if f(x) {
              (ddlog_std::push: function(mut ddlog_std::Vec<'A>, 'A):())(res, x)
          } else {
                ()
            }
      };
      res}}
}
function vec::filter_map (v: ddlog_std::Vec<'A>, f: function('A):ddlog_std::Option<'B>): ddlog_std::Vec<'B>
{
    {(var res: ddlog_std::Vec<'B>) = (ddlog_std::vec_empty: function():ddlog_std::Vec<'B>)();
     {for (x in v) {
          match (f(x)) {
              (ddlog_std::None{}: ddlog_std::Option<'B>) -> (),
              (ddlog_std::Some{.x=(var y: 'B)}: ddlog_std::Option<'B>) -> (ddlog_std::push: function(mut ddlog_std::Vec<'B>, 'B):())(res, y)
          }
      };
      res}}
}
function vec::find (v: ddlog_std::Vec<'A>, f: function('A):bool): ddlog_std::Option<'A>
{
    {for (x in v) {
         if f(x) {
             ((return (ddlog_std::Some{.x=x}: ddlog_std::Option<'A>)): ())
         } else {
               ()
           }
     };
     (ddlog_std::None{}: ddlog_std::Option<'A>)}
}
function vec::flatmap (v: ddlog_std::Vec<'A>, f: function('A):ddlog_std::Vec<'B>): ddlog_std::Vec<'B>
{
    {(var res: ddlog_std::Vec<'B>) = (ddlog_std::vec_empty: function():ddlog_std::Vec<'B>)();
     {for (x in v) {
          (ddlog_std::append: function(mut ddlog_std::Vec<'B>, ddlog_std::Vec<'B>):())(res, f(x))
      };
      res}}
}
function vec::fold (v: ddlog_std::Vec<'A>, f: function('B, 'A):'B, initializer: 'B): 'B
{
    {(var res: 'B) = initializer;
     {for (x in v) {
          res = f(res, x)
      };
      res}}
}
function vec::map (v: ddlog_std::Vec<'A>, f: function('A):'B): ddlog_std::Vec<'B>
{
    {(var res: ddlog_std::Vec<'B>) = (ddlog_std::vec_with_capacity: function(bit<64>):ddlog_std::Vec<'B>)((ddlog_std::len: function(ddlog_std::Vec<'A>):bit<64>)(v));
     {for (x in v) {
          (ddlog_std::push: function(mut ddlog_std::Vec<'B>, 'B):())(res, f(x))
      };
      res}}
}
function vec::max_by (v: ddlog_std::Vec<'A>, f: function('A):'B): ddlog_std::Option<'A>
{
    (vec::vec_max_by: function(ddlog_std::Vec<'A>, function('A):'B):ddlog_std::Option<'A>)(v, f)
}
function vec::min_by (v: ddlog_std::Vec<'A>, f: function('A):'B): ddlog_std::Option<'A>
{
    (vec::vec_min_by: function(ddlog_std::Vec<'A>, function('A):'B):ddlog_std::Option<'A>)(v, f)
}
function vec::retain (v: mut ddlog_std::Vec<'A>, f: function('A):bool): ()
{
    {(var del: ddlog_std::s64) = 64'sd0;
     {(var len: bit<64>) = (ddlog_std::len: function(ddlog_std::Vec<'A>):bit<64>)(v);
      {for (i in (ddlog_std::range: function(signed<64>, signed<64>, signed<64>):ddlog_std::Vec<signed<64>>)(64'sd0, ((len as ddlog_std::isize) - 64'sd1), 64'sd1)) {
           {(var x: 'A) = (ddlog_std::unwrap_or_default: function(ddlog_std::Option<'A>):'A)((ddlog_std::nth: function(ddlog_std::Vec<'A>, bit<64>):ddlog_std::Option<'A>)(v, (i as ddlog_std::usize)));
            if (not f(x)) {
                del = (del + 64'sd1)
            } else {
                  if (del > 64'sd0) {
                      {(ddlog_std::update_nth: function(mut ddlog_std::Vec<'A>, bit<64>, 'A):bool)(v, ((i - del) as ddlog_std::usize), x);
                       ()}
                  } else {
                        ()
                    }
              }}
       };
       if (del > 64'sd0) {
           {(ddlog_std::truncate: function(mut ddlog_std::Vec<'A>, bit<64>):())(v, (len - (del as ddlog_std::usize)));
            ()}
       } else {
             ()
         }}}}
}
function vec::sort_by (v: mut ddlog_std::Vec<'A>, f: function('A):'B): ()
{
    (vec::vec_sort_by: function(mut ddlog_std::Vec<'A>, function('A):'B):())(v, f)
}
extern function vec::vec_max_by (v: ddlog_std::Vec<'A>, f: function('A):'B): ddlog_std::Option<'A>
extern function vec::vec_min_by (v: ddlog_std::Vec<'A>, f: function('A):'B): ddlog_std::Option<'A>
extern function vec::vec_sort_by (v: mut ddlog_std::Vec<'A>, f: function('A):'B): ()
function vector_times2 (v: ddlog_std::Vec<ddlog_std::s64>): ddlog_std::Vec<ddlog_std::s64>
{
    (vec::map: function(ddlog_std::Vec<ddlog_std::s64>, function(ddlog_std::s64):ddlog_std::s64):ddlog_std::Vec<ddlog_std::s64>)(v, times2)
}
function vector_times_n (v: ddlog_std::Vec<ddlog_std::s64>, n: ddlog_std::s64): ddlog_std::Vec<ddlog_std::s64>
{
    (vec::map: function(ddlog_std::Vec<ddlog_std::s64>, function(signed<64>):signed<64>):ddlog_std::Vec<ddlog_std::s64>)(v, (function(x: signed<64>):signed<64>{(x * n)}))
}
function vsep (strs: ddlog_std::Vec<string>): string
{
    {(var res: string) = "";
     {for (s in strs) {
          {res = ((res ++ s) ++ "\n");
           ()}
      };
      res}}
}
output relation Address [Address]
relation Arguments [Arguments]
input relation Author [Author]
output relation BestDeal [BestDeal]
output relation BestPrice [BestPrice]
output relation BestVendor [BestVendor]
input relation Blacklisted [Blacklisted]
output relation BookByAuthor [BookByAuthor]
input relation Bytes [Bytes]
relation Closures [Closures]
output relation ClosuresXArguments [ClosuresXArguments]
input relation Endpoint [Endpoint]
output relation EndpointString [EndpointString]
output relation Evens [Evens]
input relation EvensAndOdds [EvensAndOdds]
output relation First5 [First5]
output relation Flow [Flow]
output relation Flow1 [Flow1]
input relation Host [Host]
input relation HostAddress [HostAddress]
output relation HostIP [HostIP]
output relation HostIPVSep [HostIPVSep]
output relation HostInSubnet [HostInSubnet]
output relation IntranetHost [IntranetHost]
output relation IntranetHost2 [IntranetHost2]
output relation IntranetHost3 [IntranetHost3]
output relation InventoryItemName [InventoryItemName]
output relation ItemInOrders [ItemInOrders]
input relation KnownHost [KnownHost]
input relation Library [Library]
input relation Load_Balancer [Load_Balancer]
input relation Logical_Switch [Logical_Switch]
output relation MCastAddress [MCastAddress]
input multiset MSetIn [MSetIn]
output multiset MSetOut [MSetOut]
output relation MilkOrders [MilkOrders]
input relation NetHost [NetHost]
output relation NetHostString [NetHostString]
input relation Number [Number]
input relation OnlineOrder [OnlineOrder]
output relation OrderFormatted [OrderFormatted]
input relation Packet [Packet]
input relation Person [Person]
output relation Phrases [Phrases]
output relation Pow2 [Pow2]
output relation Prefix [Prefix]
input relation Price [Price]
output relation PriceInCents [PriceInCents]
output relation Product [Product]
output relation SanitizedEndpoint [SanitizedEndpoint]
input relation School [ddlog_std::Ref<School>]
input relation StoreInventory [StoreInventory]
input relation Student [ddlog_std::Ref<Student>]
relation StudentInfo [StudentInfo]
input relation Subnet [Subnet]
output relation Sum [Sum]
output relation TCPDstPort [TCPDstPort]
output relation TargetAudience [Person]
output relation TopScore [TopScore]
output relation UDPDstPort [UDPDstPort]
output relation UDPDstPort2 [UDPDstPort2]
input relation Vector [Vector]
input relation Word1 [Word1]
input relation Word2 [Word2]
output relation WorstPrice [WorstPrice]
input relation X [X]
Phrases[(Phrases{.phrase=((w1 ++ " ") ++ w2)}: Phrases)] :- Word1[(__word10@ (Word1{.word=(w1: string), .cat=(cat: Category)}: Word1))], Word2[(__word21@ (Word2{.word=(w2: string), .cat=(cat: Category)}: Word2))], Inspect debug::debug_event_join((32'd0, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __word10, __word21, (Phrases{.phrase=((w1 ++ " ") ++ w2)}: Phrases)).
Word1[(Word1{.word="Hello,", .cat=(CategoryOther{}: Category)}: Word1)].
Word2[(Word2{.word="World!", .cat=(CategoryOther{}: Category)}: Word2)].
HostInSubnet[(HostInSubnet{.host=host_id, .subnet=subnet_id}: HostInSubnet)] :- Host[(__host0@ (Host{.id=(host_id: bit<128>), .name=(_: string), .ip=(host_ip: bit<32>)}: Host))], Subnet[(__subnet1@ (Subnet{.id=(subnet_id: bit<128>), .prefix=(subnet_prefix: bit<32>), .mask=(subnet_mask: bit<32>)}: Subnet))], Inspect debug::debug_event_join((32'd3, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __host0, __subnet1, (host_id, host_ip, subnet_id, subnet_prefix, subnet_mask)), ((host_ip & subnet_mask) == subnet_prefix), Inspect debug::debug_event((32'd3, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (host_id, host_ip, subnet_id, subnet_prefix, subnet_mask), (HostInSubnet{.host=host_id, .subnet=subnet_id}: HostInSubnet)).
Pow2[(Pow2{.p=((("The square of " ++ (ddlog_std::__builtin_2string: function(bigint):string)(x)) ++ " is ") ++ (ddlog_std::__builtin_2string: function(bigint):string)((x * x)))}: Pow2)] :- Number[(__number0@ (Number{.n=(x: bigint)}: Number))], Inspect debug::debug_event((32'd4, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __number0, (Pow2{.p=((("The square of " ++ (ddlog_std::__builtin_2string: function(bigint):string)(x)) ++ " is ") ++ (ddlog_std::__builtin_2string: function(bigint):string)((x * x)))}: Pow2)).
NetHostString[(NetHostString{.id=id, .s=("" ++ (to_string: function(nethost_t):string)(h))}: NetHostString)] :- NetHost[(__nethost0@ (NetHost{.id=(id: bigint), .h=(h: nethost_t)}: NetHost))], Inspect debug::debug_event((32'd5, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __nethost0, (NetHostString{.id=id, .s=("" ++ (to_string: function(nethost_t):string)(h))}: NetHostString)).
Address[(Address{.addr=ip_from_bytes(b3, b2, b1, b0)}: Address)] :- Bytes[(__bytes0@ (Bytes{.b3=(b3: bit<8>), .b2=(b2: bit<8>), .b1=(b1: bit<8>), .b0=(b0: bit<8>)}: Bytes))], Inspect debug::debug_event((32'd6, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __bytes0, (Address{.addr=ip_from_bytes(b3, b2, b1, b0)}: Address)).
MCastAddress[(MCastAddress{.addr=a}: MCastAddress)] :- Address[(__address0@ (Address{.addr=(a: ip_addr_t)}: Address))], is_multicast_addr(a), Inspect debug::debug_event((32'd7, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __address0, (MCastAddress{.addr=a}: MCastAddress)).
EndpointString[(EndpointString{.s=addr_port(ip, proto, preferred_port)}: EndpointString)] :- Endpoint[(__endpoint0@ (Endpoint{.ip=(ip: ip_addr_t), .proto=(proto: string), .preferred_port=(preferred_port: bit<16>)}: Endpoint))], Inspect debug::debug_event((32'd8, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __endpoint0, (EndpointString{.s=addr_port(ip, proto, preferred_port)}: EndpointString)).
First5[(First5{.str=string_slice_unsafe(p, 64'd0, 64'd5)}: First5)] :- Phrases[(__phrases0@ (Phrases{.phrase=(p: string)}: Phrases))], Inspect debug::debug_event((32'd9, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __phrases0, (First5{.str=string_slice_unsafe(p, 64'd0, 64'd5)}: First5)).
Closures[(Closures{.f=(function(x: ddlog_std::u64):string{("closure1: " ++ (ddlog_std::__builtin_2string: function(bit<64>):string)(x))})}: Closures)].
Closures[(Closures{.f=(function(x: ddlog_std::u64):string{("closure2: " ++ (ddlog_std::__builtin_2string: function(bit<64>):string)(x))})}: Closures)].
ClosuresXArguments[(ClosuresXArguments{.arg=arg, .res=f(arg)}: ClosuresXArguments)] :- Closures[(__closures0@ (Closures{.f=(f: function(ddlog_std::u64):string)}: Closures))], Arguments[(__arguments1@ (Arguments{.arg=(arg: bit<64>)}: Arguments))], Inspect debug::debug_event_join((32'd12, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __closures0, __arguments1, (ClosuresXArguments{.arg=arg, .res=f(arg)}: ClosuresXArguments)).
SanitizedEndpoint[(SanitizedEndpoint{.ep=endpoint}: SanitizedEndpoint)] :- Endpoint[(__endpoint0@ (Endpoint{.ip=(ip: ip_addr_t), .proto=(proto: string), .preferred_port=(preferred_port: bit<16>)}: Endpoint))], (var endpoint: string) = addr_port(ip, proto, preferred_port), Inspect debug::debug_event((32'd13, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __endpoint0, endpoint), not Blacklisted[(Blacklisted{.ep=(endpoint: string)}: Blacklisted)], Inspect debug::debug_event((32'd13, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Antijoin", endpoint, (SanitizedEndpoint{.ep=endpoint}: SanitizedEndpoint)).
BookByAuthor[(BookByAuthor{.book=b, .author=author}: BookByAuthor)] :- Library[(__library0@ (Library{.book=(b@ (Book{.author=(author_name: string), .title=(_: string)}: Book))}: Library))], Author[(author@ (Author{.name=(author_name: string), .born=(_: bit<32>)}: Author))], Inspect debug::debug_event_join((32'd14, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __library0, author, (BookByAuthor{.book=b, .author=author}: BookByAuthor)).
HostIP[(HostIP{.host=host, .addr=addr}: HostIP)] :- HostAddress[(__hostaddress0@ (HostAddress{.host=(host: bit<64>), .addrs=(addrs: string)}: HostAddress))], var addr = FlatMap(split_ip_list(addrs)), Inspect debug::debug_event((32'd15, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Flatmap", __hostaddress0, (HostIP{.host=host, .addr=addr}: HostIP)).
HostIPVSep[(HostIPVSep{.host=host, .addrs=vaddrs}: HostIPVSep)] :- HostAddress[(__hostaddress0@ (HostAddress{.host=(host: bit<64>), .addrs=(addrs: string)}: HostAddress))], (var vaddrs: string) = vsep(split_ip_list(addrs)), Inspect debug::debug_event((32'd16, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __hostaddress0, (HostIPVSep{.host=host, .addrs=vaddrs}: HostIPVSep)).
Evens[(Evens{.evens_and_odds=vec, .evens=evens(vec)}: Evens)] :- EvensAndOdds[(__evensandodds0@ (EvensAndOdds{.vec=(vec: ddlog_std::Vec<bigint>)}: EvensAndOdds))], Inspect debug::debug_event((32'd17, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __evensandodds0, (Evens{.evens_and_odds=vec, .evens=evens(vec)}: Evens)).
Prefix[(Prefix{.vec=(prefixBefore: function(ddlog_std::Vec<string>, string):ddlog_std::Vec<string>)(vec, sep)}: Prefix)] :- Vector[(__vector0@ (Vector{.vec=(vec: ddlog_std::Vec<string>), .sep=(sep: string)}: Vector))], Inspect debug::debug_event((32'd18, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __vector0, (Prefix{.vec=(prefixBefore: function(ddlog_std::Vec<string>, string):ddlog_std::Vec<string>)(vec, sep)}: Prefix)).
Sum[(Sum{.x=x, .y=y, .sum=(x + y)}: Sum)],
Product[(Product{.x=x, .y=y, .prod=(x * y)}: Product)] :- X[(__x0@ (X{.x=(x: bit<16>)}: X))], X[(__x1@ (X{.x=(y: bit<16>)}: X))], Inspect debug::debug_event_join((32'd19, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __x0, __x1, (Sum{.x=x, .y=y, .sum=(x + y)}: Sum)), Inspect debug::debug_event_join((32'd19, 32'd1, 32'd1), ddlog_weight, ddlog_timestamp, __x0, __x1, (Product{.x=x, .y=y, .prod=(x * y)}: Product)).
BestPrice[(BestPrice{.item=item, .price=best_price}: BestPrice)] :- Price[(__price0@ (Price{.item=(item: string), .vendor=(_: string), .price=(price: bit<64>)}: Price))], var __inputs_best_price = Aggregate(item, ddlog_std::__debug_20_1_group_min((__price0, price))), Inspect debug::debug_event((32'd20, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_best_price.0, (__inputs_best_price, item)), (var best_price: bit<64>) = __inputs_best_price.1, Inspect debug::debug_event((32'd20, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_best_price, item), (BestPrice{.item=item, .price=best_price}: BestPrice)).
WorstPrice[(WorstPrice{.item=item, .price=best_price}: WorstPrice)] :- Price[(__price0@ (Price{.item=(item: string), .vendor=(_: string), .price=(price: bit<64>)}: Price))], var __inputs_best_price = Aggregate(item, ddlog_std::__debug_21_1_group_max((__price0, price))), Inspect debug::debug_event((32'd21, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_best_price.0, (__inputs_best_price, item)), (var best_price: bit<64>) = __inputs_best_price.1, Inspect debug::debug_event((32'd21, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_best_price, item), (WorstPrice{.item=item, .price=best_price}: WorstPrice)).
BestVendor[(BestVendor{.item=item, .vendor=best_vendor, .price=best_price}: BestVendor)] :- Price[(__price0@ (Price{.item=(item: string), .vendor=(vendor: string), .price=(price: bit<64>)}: Price))], var __inputs_best_vendor_price = Aggregate(item, __debug_22_1_best_vendor((__price0, (vendor, price)))), Inspect debug::debug_event((32'd22, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_best_vendor_price.0, (__inputs_best_vendor_price, item)), (var best_vendor_price: (string, bit<64>)) = __inputs_best_vendor_price.1, ((var best_vendor: string), (var best_price: bit<64>)) = best_vendor_price, Inspect debug::debug_event((32'd22, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (item, best_vendor_price), (BestVendor{.item=item, .vendor=best_vendor, .price=best_price}: BestVendor)).
BestDeal[(BestDeal{.best=best}: BestDeal)] :- Price[(__price0@ (Price{.item=(item: string), .vendor=(vendor: string), .price=(price: bit<64>)}: Price))], Inspect inspect_log::log("../tutorial.log", (((((((((("ts:" ++ (ddlog_std::__builtin_2string: function(bit<64>):string)(ddlog_timestamp)) ++ ", w:") ++ (ddlog_std::__builtin_2string: function(signed<64>):string)(ddlog_weight)) ++ ": Price(item=\"") ++ item) ++ "\", vendor=\"") ++ vendor) ++ "\", price=") ++ (ddlog_std::__builtin_2string: function(bit<64>):string)(price)) ++ ")")), Inspect debug::debug_event((32'd23, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Inspect", __price0, (__price0, item, vendor, price)), var __inputs_best = Aggregate(item, __debug_23_2_best_vendor_string(((__price0, item, vendor, price), (vendor, price)))), Inspect debug::debug_event((32'd23, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_best.0, (__inputs_best, item)), (var best: string) = __inputs_best.1, Inspect debug::debug_event((32'd23, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_best, item), (item, best)), Inspect inspect_log::log("../tutorial.log", (((((((("ts:" ++ (ddlog_std::__builtin_2string: function(bit<64>):string)(ddlog_timestamp)) ++ ", w:") ++ (ddlog_std::__builtin_2string: function(signed<64>):string)(ddlog_weight)) ++ ": best(\"") ++ item) ++ "\")=\"") ++ best) ++ "\"")), Inspect debug::debug_event((32'd23, 32'd3, 32'd0), ddlog_weight, ddlog_timestamp, "Inspect", (item, best), (BestDeal{.best=best}: BestDeal)).
MSetOut[(MSetOut{.x=x}: MSetOut)] :- MSetIn[(__msetin0@ (MSetIn{.x=(x: bit<32>)}: MSetIn))], Inspect debug::debug_event((32'd24, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __msetin0, (MSetOut{.x=x}: MSetOut)).
TCPDstPort[(TCPDstPort{.port=port}: TCPDstPort)] :- Packet[(__packet0@ (Packet{.pkt=(EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP4{.ip4=(IP4Pkt{.ttl=(_: bit<8>), .src=(_: bit<32>), .dst=(_: bit<32>), .payload=(IPTCP{.tcp=(TCPPkt{.src=(_: bit<16>), .dst=(port: bit<16>), .flags=(_: bit<9>)}: tcp_pkt_t)}: ip_payload_t)}: ip4_pkt_t)}: eth_payload_t)}: eth_pkt_t)}: Packet))], Inspect debug::debug_event((32'd25, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __packet0, (TCPDstPort{.port=port}: TCPDstPort)).
TCPDstPort[(TCPDstPort{.port=port}: TCPDstPort)] :- Packet[(__packet0@ (Packet{.pkt=(EthPacket{.src=(_: bit<48>), .dst=(_: bit<48>), .payload=(EthIP6{.ip6=(IP6Pkt{.ttl=(_: bit<8>), .src=(_: bit<128>), .dst=(_: bit<128>), .payload=(IPTCP{.tcp=(TCPPkt{.src=(_: bit<16>), .dst=(port: bit<16>), .flags=(_: bit<9>)}: tcp_pkt_t)}: ip_payload_t)}: ip6_pkt_t)}: eth_payload_t)}: eth_pkt_t)}: Packet))], Inspect debug::debug_event((32'd26, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __packet0, (TCPDstPort{.port=port}: TCPDstPort)).
UDPDstPort[(UDPDstPort{.port=port}: UDPDstPort)] :- Packet[(__packet0@ (Packet{.pkt=(pkt: eth_pkt_t)}: Packet))], (var port: bit<16>) = pkt_udp_port(pkt), (port != 16'd0), Inspect debug::debug_event((32'd27, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", port, (UDPDstPort{.port=port}: UDPDstPort)).
UDPDstPort2[(UDPDstPort2{.port=port}: UDPDstPort2)] :- Packet[(__packet0@ (Packet{.pkt=(pkt: eth_pkt_t)}: Packet))], (ddlog_std::Some{.x=(var port: bit<16>)}: ddlog_std::Option<bit<16>>) = pkt_udp_port2(pkt), Inspect debug::debug_event((32'd28, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __packet0, (UDPDstPort2{.port=port}: UDPDstPort2)).
IntranetHost[(IntranetHost{.addr=addr}: IntranetHost)] :- KnownHost[(__knownhost0@ (KnownHost{.addr=(addr: bit<32>)}: KnownHost))], ((var b3: bit<8>), (var b2: bit<8>), (_: bit<8>), (_: bit<8>)) = addr_to_tuple(addr), (b3 == 8'd192), (b2 == 8'd168), Inspect debug::debug_event((32'd29, 32'd3, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (addr, b2), (IntranetHost{.addr=addr}: IntranetHost)).
IntranetHost2[(IntranetHost2{.addr=addr}: IntranetHost2)] :- KnownHost[(__knownhost0@ (KnownHost{.addr=(addr: bit<32>)}: KnownHost))], (8'd192, 8'd168, (_: bit<8>), (_: bit<8>)) = addr_to_tuple(addr), Inspect debug::debug_event((32'd30, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __knownhost0, (IntranetHost2{.addr=addr}: IntranetHost2)).
IntranetHost3[(IntranetHost3{.addr=addr}: IntranetHost3)] :- KnownHost[(__knownhost0@ (KnownHost{.addr=(addr: bit<32>)}: KnownHost))], (var t: (bit<8>, bit<8>, bit<8>, bit<8>)) = addr_to_tuple(addr), (t.0 == 8'd192), (t.1 == 8'd168), Inspect debug::debug_event((32'd31, 32'd3, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (addr, t), (IntranetHost3{.addr=addr}: IntranetHost3)).
PriceInCents[(PriceInCents{.item="Falcon 9", .price1=get_price_in_cents(inventory(), "Falcon 9"), .price2=get_price_in_cents_unwrap(inventory(), "Falcon 9"), .price3=get_price_in_cents_(inventory(), "Falcon 9")}: PriceInCents)].
PriceInCents[(PriceInCents{.item="Atlantis", .price1=get_price_in_cents(inventory(), "Atlantis"), .price2=get_price_in_cents_unwrap(inventory(), "Atlantis"), .price3=get_price_in_cents_(inventory(), "Atlantis")}: PriceInCents)].
TargetAudience[person] :- Person[(__person0@ (person: Person))], is_target_audience(person), Inspect debug::debug_event((32'd34, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __person0, person).
StudentInfo[(StudentInfo{.student=student, .school=school}: StudentInfo)] :- Student[(student@ ((&(Student{.id=(_: bit<64>), .name=(_: string), .school=(school_name: string), .sat_score=(_: bit<16>)}: Student)): ddlog_std::Ref<Student>))], School[(school@ ((&(School{.name=(school_name: string), .address=(_: string)}: School)): ddlog_std::Ref<School>))], Inspect debug::debug_event_join((32'd35, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, student, school, (StudentInfo{.student=student, .school=school}: StudentInfo)).
TopScore[(TopScore{.school=school, .top_score=top_score}: TopScore)] :- StudentInfo[(__studentinfo0@ (StudentInfo{.student=((&(Student{.id=(_: bit<64>), .name=(_: string), .school=(_: string), .sat_score=(sat: bit<16>)}: Student)): ddlog_std::Ref<Student>), .school=((&(School{.name=(school: string), .address=(_: string)}: School)): ddlog_std::Ref<School>)}: StudentInfo))], var __inputs_top_score = Aggregate(school, ddlog_std::__debug_36_1_group_max((__studentinfo0, sat))), Inspect debug::debug_event((32'd36, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_top_score.0, (__inputs_top_score, school)), (var top_score: bit<16>) = __inputs_top_score.1, Inspect debug::debug_event((32'd36, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_top_score, school), (TopScore{.school=school, .top_score=top_score}: TopScore)).
TopScore[(TopScore{.school=school, .top_score=top_score}: TopScore)] :- StudentInfo[(__studentinfo0@ (StudentInfo{.student=(student: ddlog_std::Ref<Student>), .school=((&(School{.name=(school: string), .address=(_: string)}: School)): ddlog_std::Ref<School>)}: StudentInfo))], var __inputs_top_score = Aggregate(school, ddlog_std::__debug_37_1_group_max((__studentinfo0, student.sat_score))), Inspect debug::debug_event((32'd37, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_top_score.0, (__inputs_top_score, school)), (var top_score: bit<16>) = __inputs_top_score.1, Inspect debug::debug_event((32'd37, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_top_score, school), (TopScore{.school=school, .top_score=top_score}: TopScore)).
ItemInOrders[(ItemInOrders{.item=(internment::ival: function(internment::Intern<string>):string)(item), .orders=orders}: ItemInOrders)] :- OnlineOrder[(__onlineorder0@ (OnlineOrder{.order_id=(order: bit<64>), .item=(item: internment::Intern<string>)}: OnlineOrder))], var __inputs_orders = Aggregate(item, ddlog_std::__debug_38_1_group_to_vec((__onlineorder0, order))), Inspect debug::debug_event((32'd38, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Aggregate", __inputs_orders.0, (__inputs_orders, item)), (var orders: ddlog_std::Vec<bit<64>>) = __inputs_orders.1, Inspect debug::debug_event((32'd38, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (__inputs_orders, item), (ItemInOrders{.item=(internment::ival: function(internment::Intern<string>):string)(item), .orders=orders}: ItemInOrders)).
OrderFormatted[(OrderFormatted{.order=formatted}: OrderFormatted)] :- OnlineOrder[(__onlineorder0@ (OnlineOrder{.order_id=(order: bit<64>), .item=(item: internment::Intern<string>)}: OnlineOrder))], (var formatted: string) = ((("order: " ++ (ddlog_std::__builtin_2string: function(bit<64>):string)(order)) ++ ", item: ") ++ (internment::ival: function(internment::Intern<string>):string)(item)), Inspect debug::debug_event((32'd39, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __onlineorder0, (OrderFormatted{.order=formatted}: OrderFormatted)).
MilkOrders[(MilkOrders{.order=order}: MilkOrders)] :- OnlineOrder[(__onlineorder0@ (OnlineOrder{.order_id=(order: bit<64>), .item=(internment::intern: function(string):internment::Intern<string>)("milk")}: OnlineOrder))], Inspect debug::debug_event((32'd40, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __onlineorder0, (MilkOrders{.order=order}: MilkOrders)).
InventoryItemName[(InventoryItemName{.name=name}: InventoryItemName)] :- StoreInventory[(__storeinventory0@ (StoreInventory{.item=(item: internment::Intern<StoreItem>)}: StoreInventory))], (var name: string) = (internment::ival: function(internment::Intern<StoreItem>):StoreItem)(item).name, Inspect debug::debug_event((32'd41, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", __storeinventory0, (InventoryItemName{.name=name}: InventoryItemName)).
Flow[(Flow{.lr=ls, .stage=(LS_IN_PRE_LB{}: stage), .prio=100, .matchStr=("ip4.dst == " ++ addresses), .actionStr="{ reg0[0] = 1; next; }"}: Flow)] :- Load_Balancer[(__load_balancer0@ (Load_Balancer{.lb=(_: bigint), .ls=(ls: bigint), .ip_addresses=(addresses: string), .protocol=(ddlog_std::Some{.x=(_: string)}: ddlog_std::Option<string>), .name=(_: string)}: Load_Balancer))], Inspect debug::debug_event((32'd42, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, "Map", __load_balancer0, (Flow{.lr=ls, .stage=(LS_IN_PRE_LB{}: stage), .prio=100, .matchStr=("ip4.dst == " ++ addresses), .actionStr="{ reg0[0] = 1; next; }"}: Flow)).
Flow[(Flow{.lr=ls, .stage=(LS_OUT_PRE_LB{}: stage), .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }"}: Flow)] :- Logical_Switch[(__logical_switch0@ (Logical_Switch{.ls=(ls: bigint)}: Logical_Switch))], Load_Balancer[(__load_balancer1@ (Load_Balancer{.lb=(_: bigint), .ls=(ls: bigint), .ip_addresses=(_: string), .protocol=(_: ddlog_std::Option<string>), .name=(_: string)}: Load_Balancer))], Inspect debug::debug_event_join((32'd43, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __logical_switch0, __load_balancer1, (Flow{.lr=ls, .stage=(LS_OUT_PRE_LB{}: stage), .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }"}: Flow)).
Flow1[(Flow1{.lr=lb.ls, .stage=(LS_IN_PRE_LB{}: stage), .prio=100, .matchStr=("ip4.dst == " ++ a), .actionStr="{ reg0[0] = 1; next; }"}: Flow1)] :- Load_Balancer[(lb@ (Load_Balancer{.lb=(_: bigint), .ls=(_: bigint), .ip_addresses=(_: string), .protocol=(_: ddlog_std::Option<string>), .name=(_: string)}: Load_Balancer))], (var a: string) = lb.ip_addresses, match (lb.protocol) {
                                                                                                                                                                                                                                                                                                                                                                          (ddlog_std::Some{.x=(_: string)}: ddlog_std::Option<string>) -> true,
                                                                                                                                                                                                                                                                                                                                                                          (ddlog_std::None{}: ddlog_std::Option<string>) -> false
                                                                                                                                                                                                                                                                                                                                                                      }, Inspect debug::debug_event((32'd44, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (lb, a), (Flow1{.lr=lb.ls, .stage=(LS_IN_PRE_LB{}: stage), .prio=100, .matchStr=("ip4.dst == " ++ a), .actionStr="{ reg0[0] = 1; next; }"}: Flow1)).
Flow1[(Flow1{.lr=ls.ls, .stage=(LS_OUT_PRE_LB{}: stage), .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }"}: Flow1)] :- Logical_Switch[(ls@ (Logical_Switch{.ls=(_: bigint)}: Logical_Switch))], Load_Balancer[(lb@ (Load_Balancer{.lb=(_: bigint), .ls=(_: bigint), .ip_addresses=(_: string), .protocol=(_: ddlog_std::Option<string>), .name=(_: string)}: Load_Balancer))], Inspect debug::debug_event_join((32'd45, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, ls, lb, (ls, lb)), (lb.ls == ls.ls), Inspect debug::debug_event((32'd45, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, "Condition", (ls, lb), (Flow1{.lr=ls.ls, .stage=(LS_OUT_PRE_LB{}: stage), .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }"}: Flow1)).

