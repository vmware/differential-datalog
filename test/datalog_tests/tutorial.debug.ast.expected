typedef Address = Address{addr: ip_addr_t}
typedef Author = Author{name: string, born: std.u32}
typedef BestDeal = BestDeal{best: string}
typedef BestPrice = BestPrice{item: string, price: bit<64>}
typedef BestVendor = BestVendor{item: string, vendor: string, price: bit<64>}
typedef Blacklisted = Blacklisted{ep: string}
typedef Book = Book{author: string, title: string}
typedef BookByAuthor = BookByAuthor{book: Book, author: Author}
typedef Bytes = Bytes{b3: bit<8>, b2: bit<8>, b1: bit<8>, b0: bit<8>}
typedef Category = CategoryStarWars{} | CategoryOther{}
typedef Endpoint = Endpoint{ip: ip_addr_t, proto: string, preferred_port: bit<16>}
typedef EndpointString = EndpointString{s: string}
typedef Evens = Evens{evens_and_odds: std.Vec<bigint>, evens: std.Vec<bigint>}
typedef EvensAndOdds = EvensAndOdds{vec: std.Vec<bigint>}
typedef First5 = First5{str: string}
typedef Flow = Flow{lr: bigint, stage: stage, prio: bigint, matchStr: string, actionStr: string}
typedef Flow1 = Flow1{lr: bigint, stage: stage, prio: bigint, matchStr: string, actionStr: string}
typedef Host = Host{id: UUID, name: string, ip: IP4}
typedef HostAddress = HostAddress{host: bit<64>, addrs: string}
typedef HostIP = HostIP{host: bit<64>, addr: string}
typedef HostIPVSep = HostIPVSep{host: bit<64>, addrs: string}
typedef HostInSubnet = HostInSubnet{host: UUID, subnet: UUID}
typedef IP4 = bit<32>
typedef IStoreItem = internment.Intern<StoreItem>
typedef IntranetHost = IntranetHost{addr: ip4_addr_t}
typedef IntranetHost2 = IntranetHost2{addr: ip4_addr_t}
typedef IntranetHost3 = IntranetHost3{addr: ip4_addr_t}
typedef InventoryItemName = InventoryItemName{name: string}
typedef ItemInOrders = ItemInOrders{item: string, orders: std.Vec<std.u64>}
typedef KnownHost = KnownHost{addr: ip4_addr_t}
typedef Library = Library{book: Book}
typedef Load_Balancer = Load_Balancer{lb: bigint, ls: bigint, ip_addresses: string, protocol: std.Option<string>, name: string}
typedef Logical_Switch = Logical_Switch{ls: bigint}
typedef MCastAddress = MCastAddress{addr: ip_addr_t}
typedef MilkOrders = MilkOrders{order: std.u64}
typedef NetHost = NetHost{id: bigint, h: nethost_t}
typedef NetHostString = NetHostString{id: bigint, s: string}
typedef NetMask = bit<32>
typedef Number = Number{n: bigint}
typedef OnlineOrder = OnlineOrder{order_id: std.u64, item: internment.istring}
typedef OrderFormatted = OrderFormatted{order: string}
typedef Packet = Packet{pkt: eth_pkt_t}
typedef Person = Person{name: string, nationality: string, occupation: string}
typedef Phrases = Phrases{phrase: string}
typedef Pow2 = Pow2{p: string}
typedef Prefix = Prefix{vec: std.Vec<string>}
typedef Price = Price{item: string, vendor: string, price: bit<64>}
typedef Product = Product{x: bit<16>, y: bit<16>, prod: bit<16>}
typedef SanitizedEndpoint = SanitizedEndpoint{ep: string}
typedef School = School{name: string, address: string}
typedef StoreInventory = StoreInventory{item: IStoreItem}
typedef StoreItem = StoreItem{name: string, description: internment.istring}
typedef Student = Student{id: student_id, name: string, school: string, sat_score: bit<16>}
typedef StudentInfo = StudentInfo{student: std.Ref<Student>, school: std.Ref<School>}
typedef Subnet = Subnet{id: UUID, prefix: IP4, mask: NetMask}
typedef Sum = Sum{x: bit<16>, y: bit<16>, sum: bit<16>}
typedef TCPDstPort = TCPDstPort{port: bit<16>}
typedef TopScore = TopScore{school: string, top_score: bit<16>}
typedef UDPDstPort = UDPDstPort{port: bit<16>}
typedef UDPDstPort2 = UDPDstPort2{port: bit<16>}
typedef UUID = bit<128>
typedef Vector = Vector{vec: std.Vec<string>, sep: string}
typedef Word1 = Word1{word: string, cat: Category}
typedef Word2 = Word2{word: string, cat: Category}
typedef WorstPrice = WorstPrice{item: string, price: bit<64>}
typedef X = X{x: bit<16>}
typedef eth_payload_t = EthIP4{ip4: ip4_pkt_t} | EthIP6{ip6: ip6_pkt_t} | EthOther{}
typedef eth_pkt_t = EthPacket{src: bit<48>, dst: bit<48>, payload: eth_payload_t}
#[size = 8]
#[shared_ref = true]
extern type internment.Intern<'A>
typedef internment.istring = internment.Intern<string>
typedef ip4_addr_t = bit<32>
typedef ip4_pkt_t = IP4Pkt{ttl: bit<8>, src: ip4_addr_t, dst: ip4_addr_t, payload: ip_payload_t}
typedef ip6_addr_t = bit<128>
typedef ip6_pkt_t = IP6Pkt{ttl: bit<8>, src: ip6_addr_t, dst: ip6_addr_t, payload: ip_payload_t}
typedef ip_addr_t = IPAddr{addr: bit<32>}
typedef ip_payload_t = IPTCP{tcp: tcp_pkt_t} | IPUDP{udp: udp_pkt_t} | IPOther{}
typedef log.log_level_t = signed<32>
typedef log.module_t = signed<32>
typedef mac_addr_t = MACAddr{addr: bit<48>}
typedef nethost_t = NHost{ip: ip_addr_t, mac: mac_addr_t}
typedef stage = LS_IN_PRE_LB{} | LS_OUT_PRE_LB{}
typedef std.DDEpoch = std.u64
typedef std.DDIteration = std.u64
typedef std.DDNestedTS = std.DDNestedTS{epoch: std.DDEpoch, iter: std.DDIteration}
typedef std.DDWeight = std.s64
typedef std.Either<'A,'B> = std.Left{l: 'A} | std.Right{r: 'B}
extern type std.Group<'K,'V>
extern type std.Map<'K,'V>
#[rust = "serde(from=\"Option<A>\", into=\"Option<A>\", bound(serialize=\"A: Clone+Serialize\"))"]
#[custom_from_record = true]
typedef std.Option<'A> = std.None{} | std.Some{x: 'A}
#[size = 8]
#[shared_ref = true]
extern type std.Ref<'A>
typedef std.Result<'V,'E> = std.Ok{res: 'V} | std.Err{err: 'E}
extern type std.Set<'A>
extern type std.Vec<'A>
typedef std.s128 = signed<128>
typedef std.s16 = signed<16>
typedef std.s32 = signed<32>
typedef std.s64 = signed<64>
typedef std.s8 = signed<8>
typedef std.u128 = bit<128>
typedef std.u16 = bit<16>
typedef std.u32 = bit<32>
typedef std.u64 = bit<64>
typedef std.u8 = bit<8>
typedef std.usize = std.u64
typedef student_id = bit<64>
typedef tcp_pkt_t = TCPPkt{src: bit<16>, dst: bit<16>, flags: bit<9>}
typedef udp_pkt_t = UDPPkt{src: bit<16>, dst: bit<16>, len: bit<16>}
function __debug_17_1_std.group_min (g: std.Group<string,('I, bit<64>)>): (std.Vec<'I>, bit<64>)
{
    ((var inputs, var original_group) = debug.debug_split_group(g);
     (inputs, std.group_min(original_group)))
}
function __debug_18_1_std.group_max (g: std.Group<string,('I, bit<64>)>): (std.Vec<'I>, bit<64>)
{
    ((var inputs, var original_group) = debug.debug_split_group(g);
     (inputs, std.group_max(original_group)))
}
function __debug_19_1_best_vendor (g: std.Group<string,('I, (string, bit<64>))>): (std.Vec<'I>, (string, bit<64>))
{
    ((var inputs, var original_group) = debug.debug_split_group(g);
     (inputs, best_vendor(original_group)))
}
function __debug_20_2_best_vendor_string (g: std.Group<string,('I, (string, bit<64>))>): (std.Vec<'I>, string)
{
    ((var inputs, var original_group) = debug.debug_split_group(g);
     (inputs, best_vendor_string(original_group)))
}
function __debug_30_1_std.group_max (g: std.Group<string,('I, bit<16>)>): (std.Vec<'I>, bit<16>)
{
    ((var inputs, var original_group) = debug.debug_split_group(g);
     (inputs, std.group_max(original_group)))
}
function __debug_31_1_std.group_max (g: std.Group<string,('I, bit<16>)>): (std.Vec<'I>, bit<16>)
{
    ((var inputs, var original_group) = debug.debug_split_group(g);
     (inputs, std.group_max(original_group)))
}
function __debug_32_1_std.group2vec (g: std.Group<internment.istring,('I, bit<64>)>): (std.Vec<'I>, std.Vec<bit<64>>)
{
    ((var inputs, var original_group) = debug.debug_split_group(g);
     (inputs, std.group2vec(original_group)))
}
function addr_port (ip: ip_addr_t, proto: string, preferred_port: bit<16>): string
{
    ((var port: bit<16>) = match (proto) {
                               "FTP" -> 16'd20,
                               "HTTPS" -> 16'd443,
                               _ -> if (preferred_port != 16'd0) {
                                        preferred_port
                                    } else {
                                          return (("" ++ ip_addr_t2string(ip)) ++ ":80")
                                      }
                           };
     ((("" ++ ip_addr_t2string(ip)) ++ ":") ++ std.__builtin_2string(port)))
}
function addr_to_tuple (addr: ip4_addr_t): (bit<8>, bit<8>, bit<8>, bit<8>)
{
    (addr[31:24], addr[23:16], addr[15:8], addr[7:0])
}
function best_vendor (g: std.Group<'K,(string, bit<64>)>): (string, bit<64>)
{
    (var min_vendor = "";
     ((var min_price: bit<64>) = 64'd18446744073709551615;
      (for (vendor_price in g) {
           if (vendor_price.1 < min_price) {
               (min_vendor = vendor_price.0;
                min_price = vendor_price.1)
           } else {
                 ()
             }
       };
       (min_vendor, min_price))))
}
function best_vendor_string (g: std.Group<string,(string, bit<64>)>): string
{
    (var min_vendor = "";
     ((var min_price: bit<64>) = 64'd18446744073709551615;
      (for (vendor_price in g) {
           if (vendor_price.1 < min_price) {
               (min_vendor = vendor_price.0;
                min_price = vendor_price.1)
           } else {
                 ()
             }
       };
       ((((("Best deal for " ++ std.group_key(g)) ++ ": ") ++ min_vendor) ++ ", $") ++ std.__builtin_2string(min_price)))))
}
extern function debug.debug_event (operator_id: (std.u32, std.u32, std.u32), w: std.DDWeight, ts: 'T1, input1: 'A1, out: 'A2): ()
extern function debug.debug_event_join (operator_id: (std.u32, std.u32, std.u32), w: std.DDWeight, ts: 'T1, input1: 'A1, input2: 'A2, out: 'A3): ()
extern function debug.debug_split_group (g: std.Group<'K,('I, 'V)>): (std.Vec<'I>, std.Group<'K,'V>)
function evens (vec: std.Vec<bigint>): std.Vec<bigint>
{
    ((var res: std.Vec<bigint>) = std.vec_empty();
     (for (x in vec) {
          (if ((x % 2) != 0) {
               continue
           } else {
                 ()
             };
           std.vec_push(res, x))
      };
      res))
}
#[has_side_effects = true]
extern function inspect_log.log (filename: string, msg: string): ()
extern function internment.intern (s: 'A): internment.Intern<'A>
extern function internment.istring_contains (s1: internment.istring, s2: string): bool
extern function internment.istring_ends_with (s: internment.istring, suffix: string): bool
extern function internment.istring_join (strings: std.Vec<internment.istring>, sep: string): string
extern function internment.istring_len (s: internment.istring): std.usize
extern function internment.istring_replace (s: internment.istring, from: string, to: string): string
extern function internment.istring_reverse (s: internment.istring): string
extern function internment.istring_split (s: internment.istring, sep: string): std.Vec<string>
extern function internment.istring_starts_with (s: internment.istring, prefix: string): bool
extern function internment.istring_substr (s: internment.istring, start: std.usize, end: std.usize): string
extern function internment.istring_to_bytes (s: internment.istring): std.Vec<std.u8>
extern function internment.istring_to_lowercase (s: internment.istring): string
extern function internment.istring_to_uppercase (s: internment.istring): string
extern function internment.istring_trim (s: internment.istring): string
#[return_by_ref = true]
extern function internment.ival (s: internment.Intern<'A>): 'A
function ip_addr_t2string (ip: ip_addr_t): string
{
    ((((((("" ++ std.__builtin_2string(ip.addr[31:24])) ++ ".") ++ std.__builtin_2string(ip.addr[23:16])) ++ ".") ++ std.__builtin_2string(ip.addr[15:8])) ++ ".") ++ std.__builtin_2string(ip.addr[7:0]))
}
function ip_from_bytes (b3: bit<8>, b2: bit<8>, b1: bit<8>, b0: bit<8>): ip_addr_t
{
    IPAddr{.addr=(((b3 ++ b2) ++ b1) ++ b0)}
}
function is_multicast_addr (ip: ip_addr_t): bool
{
    (ip.addr[31:28] == 4'd14)
}
function is_target_audience (person: Person): bool
{
    ((person.nationality == "USA") and (person.occupation == "student"))
}
#[has_side_effects = true]
extern function log.log (module: log.module_t, level: log.log_level_t, msg: string): ()
function mac_addr_t2string (mac: mac_addr_t): string
{
    ((((((((((("" ++ std.hex(mac.addr[47:40])) ++ ":") ++ std.hex(mac.addr[39:32])) ++ ":") ++ std.hex(mac.addr[31:24])) ++ ":") ++ std.hex(mac.addr[23:16])) ++ ":") ++ std.hex(mac.addr[15:8])) ++ ":") ++ std.hex(mac.addr[7:0]))
}
function nethost_t2string (h: nethost_t): string
{
    ((("Host: IP=" ++ ip_addr_t2string(h.ip)) ++ ", MAC=") ++ mac_addr_t2string(h.mac))
}
function pkt_ip4 (pkt: eth_pkt_t): ip4_pkt_t
{
    match (pkt) {
        EthPacket{.src=_, .dst=_, .payload=EthIP4{.ip4=var ip4}} -> ip4,
        _ -> IP4Pkt{.ttl=8'd0, .src=32'd0, .dst=32'd0, .payload=IPOther{}}
    }
}
function pkt_ip4_ (pkt: eth_pkt_t): std.Option<ip4_pkt_t>
{
    match (pkt) {
        EthPacket{.src=_, .dst=_, .payload=EthIP4{.ip4=var ip4}} -> std.Some{.x=ip4},
        _ -> std.None{}
    }
}
function pkt_udp_port (pkt: eth_pkt_t): bit<16>
{
    match (pkt) {
        EthPacket{.src=_, .dst=_, .payload=EthIP4{.ip4=IP4Pkt{.ttl=_, .src=_, .dst=_, .payload=IPUDP{.udp=UDPPkt{.src=_, .dst=var port, .len=_}}}}} -> port,
        EthPacket{.src=_, .dst=_, .payload=EthIP6{.ip6=IP6Pkt{.ttl=_, .src=_, .dst=_, .payload=IPUDP{.udp=UDPPkt{.src=_, .dst=var port, .len=_}}}}} -> port,
        _ -> 16'd0
    }
}
function pkt_udp_port2 (pkt: eth_pkt_t): std.Option<bit<16>>
{
    match (pkt) {
        EthPacket{.src=_, .dst=_, .payload=EthIP4{.ip4=IP4Pkt{.ttl=_, .src=_, .dst=_, .payload=IPUDP{.udp=UDPPkt{.src=_, .dst=var port, .len=_}}}}} -> std.Some{.x=port},
        EthPacket{.src=_, .dst=_, .payload=EthIP6{.ip6=IP6Pkt{.ttl=_, .src=_, .dst=_, .payload=IPUDP{.udp=UDPPkt{.src=_, .dst=var port, .len=_}}}}} -> std.Some{.x=port},
        _ -> std.None{}
    }
}
function prefixBefore (vec: std.Vec<'A>, v: 'A): std.Vec<'A>
{
    ((var res: std.Vec<'A>) = std.vec_empty();
     (for (x in vec) {
          (if (x == v) {
               break
           } else {
                 ()
             };
           std.vec_push(res, x))
      };
      res))
}
extern function split (s: string, sep: string): std.Vec<string>
function split_ip_list (x: string): std.Vec<string>
{
    split(x, " ")
}
extern function std.__builtin_2string (x: 'X): string
function std.dDNestedTS2string (ts: std.DDNestedTS): string
{
    (((("(" ++ std.__builtin_2string(ts.epoch)) ++ ",") ++ std.__builtin_2string(ts.iter)) ++ ")")
}
#[return_by_ref = true]
extern function std.deref (x: std.Ref<'A>): 'A
extern function std.group2map (g: std.Group<'K1,('K2, 'V)>): std.Map<'K2,'V>
extern function std.group2set (g: std.Group<'K,'V>): std.Set<'V>
extern function std.group2setmap (g: std.Group<'K1,('K2, 'V)>): std.Map<'K2,std.Set<'V>>
extern function std.group2vec (g: std.Group<'K,'V>): std.Vec<'V>
extern function std.group_count (g: std.Group<'K,'V>): std.usize
extern function std.group_first (g: std.Group<'K,'V>): 'V
extern function std.group_key (g: std.Group<'K,'V>): 'K
extern function std.group_max (g: std.Group<'K,'V>): 'V
extern function std.group_min (g: std.Group<'K,'V>): 'V
extern function std.group_nth (g: std.Group<'K,'V>, n: std.usize): std.Option<'V>
extern function std.group_set_unions (g: std.Group<'K,std.Set<'A>>): std.Set<'A>
extern function std.group_setref_unions (g: std.Group<'K,std.Ref<std.Set<'A>>>): std.Ref<std.Set<'A>>
extern function std.group_sum (g: std.Group<'K,'V>): 'V
function std.group_unzip (g: std.Group<'K,('X, 'Y)>): (std.Vec<'X>, std.Vec<'Y>)
{
    ((var xs: std.Vec<'X>) = std.vec_empty();
     ((var ys: std.Vec<'Y>) = std.vec_empty();
      (for (v in g) {
           ((var x, var y) = v;
            (std.vec_push(xs, x);
             std.vec_push(ys, y)))
       };
       (xs, ys))))
}
extern function std.hash128 (x: 'X): bit<128>
extern function std.hash64 (x: 'X): bit<64>
extern function std.hex (x: 'X): string
extern function std.htonl (x: bit<32>): bit<32>
extern function std.htons (x: bit<16>): bit<16>
function std.is_err (res: std.Result<'V,'E>): bool
{
    match (res) {
        std.Ok{.res=_} -> false,
        std.Err{.err=_} -> true
    }
}
function std.is_none (x: std.Option<'A>): bool
{
    match (x) {
        std.None{} -> true,
        _ -> false
    }
}
function std.is_ok (res: std.Result<'V,'E>): bool
{
    match (res) {
        std.Ok{.res=_} -> true,
        std.Err{.err=_} -> false
    }
}
function std.is_some (x: std.Option<'A>): bool
{
    match (x) {
        std.Some{.x=_} -> true,
        _ -> false
    }
}
extern function std.map_contains_key (m: std.Map<'K,'V>, k: 'K): bool
extern function std.map_empty (): std.Map<'K,'V>
extern function std.map_get (m: std.Map<'K,'V>, k: 'K): std.Option<'V>
extern function std.map_insert (m: mut std.Map<'K,'V>, k: 'K, v: 'V): ()
extern function std.map_insert_imm (m: std.Map<'K,'V>, k: 'K, v: 'V): std.Map<'K,'V>
extern function std.map_is_empty (m: std.Map<'K,'V>): bool
extern function std.map_remove (m: mut std.Map<'K,'V>, k: 'K): ()
extern function std.map_singleton (k: 'K, v: 'V): std.Map<'K,'V>
extern function std.map_size (m: std.Map<'K,'V>): std.usize
extern function std.map_union (m1: std.Map<'K,'V>, m2: std.Map<'K,'V>): std.Map<'K,'V>
function std.max (x: 'A, y: 'A): 'A
{
    if (x > y) {
        x
    } else {
          y
      }
}
function std.min (x: 'A, y: 'A): 'A
{
    if (x < y) {
        x
    } else {
          y
      }
}
extern function std.ntohl (x: bit<32>): bit<32>
extern function std.ntohs (x: bit<16>): bit<16>
function std.option2set (o: std.Option<'X>): std.Set<'X>
{
    match (o) {
        std.Some{.x=var x} -> std.set_singleton(x),
        std.None{} -> std.set_empty()
    }
}
function std.option2vec (o: std.Option<'X>): std.Vec<'X>
{
    match (o) {
        std.Some{.x=var x} -> std.vec_singleton(x),
        std.None{} -> std.vec_empty()
    }
}
function std.option_unwrap_or (x: std.Option<'A>, def: 'A): 'A
{
    match (x) {
        std.Some{.x=var v} -> v,
        std.None{} -> def
    }
}
extern function std.option_unwrap_or_default (opt: std.Option<'A>): 'A
extern function std.parse_dec_i64 (s: string): std.Option<signed<64>>
extern function std.parse_dec_u64 (s: string): std.Option<bit<64>>
extern function std.pow32 (base: 'A, exp: bit<32>): 'A
extern function std.range (from: 'A, to: 'A, step: 'A): std.Vec<'A>
extern function std.ref_new (x: 'A): std.Ref<'A>
function std.result_unwrap_or (res: std.Result<'V,'E>, def: 'V): 'V
{
    match (res) {
        std.Ok{.res=var v} -> v,
        std.Err{.err=_} -> def
    }
}
extern function std.result_unwrap_or_default (res: std.Result<'V,'E>): 'V
extern function std.set2vec (s: std.Set<'A>): std.Vec<'A>
extern function std.set_contains (s: std.Set<'X>, v: 'X): bool
extern function std.set_difference (s1: std.Set<'X>, s2: std.Set<'X>): std.Set<'X>
extern function std.set_empty (): std.Set<'X>
extern function std.set_insert (s: mut std.Set<'X>, v: 'X): ()
extern function std.set_insert_imm (s: std.Set<'X>, v: 'X): std.Set<'X>
extern function std.set_intersection (s1: std.Set<'X>, s2: std.Set<'X>): std.Set<'X>
extern function std.set_is_empty (s: std.Set<'X>): bool
extern function std.set_nth (s: std.Set<'X>, n: std.usize): std.Option<'X>
extern function std.set_singleton (x: 'X): std.Set<'X>
extern function std.set_size (s: std.Set<'X>): std.usize
extern function std.set_union (s1: std.Set<'X>, s2: std.Set<'X>): std.Set<'X>
extern function std.set_unions (sets: std.Vec<std.Set<'X>>): std.Set<'X>
extern function std.str_to_lower (s: string): string
extern function std.string_contains (s1: string, s2: string): bool
extern function std.string_ends_with (s: string, suffix: string): bool
extern function std.string_join (strings: std.Vec<string>, sep: string): string
extern function std.string_len (s: string): std.usize
extern function std.string_replace (s: string, from: string, to: string): string
extern function std.string_reverse (s: string): string
extern function std.string_split (s: string, sep: string): std.Vec<string>
extern function std.string_starts_with (s: string, prefix: string): bool
extern function std.string_substr (s: string, start: std.usize, end: std.usize): string
extern function std.string_to_bytes (s: string): std.Vec<std.u8>
extern function std.string_to_lowercase (s: string): string
extern function std.string_to_uppercase (s: string): string
extern function std.string_trim (s: string): string
extern function std.vec2set (s: std.Vec<'A>): std.Set<'A>
extern function std.vec_append (v: mut std.Vec<'X>, other: std.Vec<'X>): ()
extern function std.vec_contains (v: std.Vec<'X>, x: 'X): bool
extern function std.vec_empty (): std.Vec<'A>
extern function std.vec_is_empty (v: std.Vec<'X>): bool
extern function std.vec_len (v: std.Vec<'X>): std.usize
extern function std.vec_nth (v: std.Vec<'X>, n: std.usize): std.Option<'X>
extern function std.vec_push (v: mut std.Vec<'X>, x: 'X): ()
extern function std.vec_push_imm (v: std.Vec<'X>, x: 'X): std.Vec<'X>
extern function std.vec_singleton (x: 'X): std.Vec<'X>
extern function std.vec_sort (v: std.Vec<'X>): ()
extern function std.vec_sort_imm (v: std.Vec<'X>): std.Vec<'X>
extern function std.vec_with_capacity (len: std.usize): std.Vec<'A>
extern function std.vec_with_length (len: std.usize, x: 'A): std.Vec<'A>
extern function string_slice_unsafe (x: string, from: bit<64>, to: bit<64>): string
function tcp6_packet (ethsrc: bit<48>, ethdst: bit<48>, ipsrc: ip6_addr_t, ipdst: ip6_addr_t, srcport: bit<16>, dstport: bit<16>): eth_pkt_t
{
    EthPacket{.src=ethsrc, .dst=ethdst, .payload=EthIP6{.ip6=IP6Pkt{.ttl=8'd10, .src=ipsrc, .dst=ipdst, .payload=IPTCP{.tcp=TCPPkt{.src=srcport, .dst=dstport, .flags=9'd0}}}}}
}
function vsep (strs: std.Vec<string>): string
{
    (var res = "";
     (for (s in strs) {
          res = ((res ++ s) ++ "\n")
      };
      res))
}
output relation Address [Address]
input relation Author [Author]
output relation BestDeal [BestDeal]
output relation BestPrice [BestPrice]
output relation BestVendor [BestVendor]
input relation Blacklisted [Blacklisted]
output relation BookByAuthor [BookByAuthor]
input relation Bytes [Bytes]
input relation Endpoint [Endpoint]
output relation EndpointString [EndpointString]
output relation Evens [Evens]
input relation EvensAndOdds [EvensAndOdds]
output relation First5 [First5]
output relation Flow [Flow]
output relation Flow1 [Flow1]
input relation Host [Host]
input relation HostAddress [HostAddress]
output relation HostIP [HostIP]
output relation HostIPVSep [HostIPVSep]
output relation HostInSubnet [HostInSubnet]
output relation IntranetHost [IntranetHost]
output relation IntranetHost2 [IntranetHost2]
output relation IntranetHost3 [IntranetHost3]
output relation InventoryItemName [InventoryItemName]
output relation ItemInOrders [ItemInOrders]
input relation KnownHost [KnownHost]
input relation Library [Library]
input relation Load_Balancer [Load_Balancer]
input relation Logical_Switch [Logical_Switch]
output relation MCastAddress [MCastAddress]
output relation MilkOrders [MilkOrders]
input relation NetHost [NetHost]
output relation NetHostString [NetHostString]
input relation Number [Number]
input relation OnlineOrder [OnlineOrder]
output relation OrderFormatted [OrderFormatted]
input relation Packet [Packet]
input relation Person [Person]
output relation Phrases [Phrases]
output relation Pow2 [Pow2]
output relation Prefix [Prefix]
input relation Price [Price]
output relation Product [Product]
output relation SanitizedEndpoint [SanitizedEndpoint]
input relation School [std.Ref<School>]
input relation StoreInventory [StoreInventory]
input relation Student [std.Ref<Student>]
relation StudentInfo [StudentInfo]
input relation Subnet [Subnet]
output relation Sum [Sum]
output relation TCPDstPort [TCPDstPort]
output relation TargetAudience [Person]
output relation TopScore [TopScore]
output relation UDPDstPort [UDPDstPort]
output relation UDPDstPort2 [UDPDstPort2]
input relation Vector [Vector]
input relation Word1 [Word1]
input relation Word2 [Word2]
output relation WorstPrice [WorstPrice]
input relation X [X]
Phrases(.phrase=((w1 ++ " ") ++ w2)) :- Word1[(__word10@ Word1{.word=w1, .cat=cat})], Word2[(__word21@ Word2{.word=w2, .cat=cat})], Inspect debug.debug_event_join((32'd0, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __word10, __word21, Phrases{.phrase=((w1 ++ " ") ++ w2)}).
Word1(.word="Hello,", .cat=CategoryOther{}).
Word2(.word="World!", .cat=CategoryOther{}).
HostInSubnet(.host=host_id, .subnet=subnet_id) :- Host[(__host0@ Host{.id=host_id, .name=_, .ip=host_ip})], Subnet[(__subnet1@ Subnet{.id=subnet_id, .prefix=subnet_prefix, .mask=subnet_mask})], Inspect debug.debug_event_join((32'd3, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __host0, __subnet1, (host_id, host_ip, subnet_id, subnet_prefix, subnet_mask)), ((host_ip & subnet_mask) == subnet_prefix), Inspect debug.debug_event((32'd3, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, (host_id, host_ip, subnet_id, subnet_prefix, subnet_mask), HostInSubnet{.host=host_id, .subnet=subnet_id}).
Pow2(.p=((("The square of " ++ std.__builtin_2string(x)) ++ " is ") ++ std.__builtin_2string((x * x)))) :- Number[(__number0@ Number{.n=x})], Inspect debug.debug_event((32'd4, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, __number0, Pow2{.p=((("The square of " ++ std.__builtin_2string(x)) ++ " is ") ++ std.__builtin_2string((x * x)))}).
NetHostString(.id=id, .s=("" ++ nethost_t2string(h))) :- NetHost[(__nethost0@ NetHost{.id=id, .h=h})], Inspect debug.debug_event((32'd5, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, __nethost0, NetHostString{.id=id, .s=("" ++ nethost_t2string(h))}).
Address(.addr=ip_from_bytes(b3, b2, b1, b0)) :- Bytes[(__bytes0@ Bytes{.b3=b3, .b2=b2, .b1=b1, .b0=b0})], Inspect debug.debug_event((32'd6, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, __bytes0, Address{.addr=ip_from_bytes(b3, b2, b1, b0)}).
MCastAddress(.addr=a) :- Address[(__address0@ Address{.addr=a})], is_multicast_addr(a), Inspect debug.debug_event((32'd7, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __address0, MCastAddress{.addr=a}).
EndpointString(.s=addr_port(ip, proto, preferred_port)) :- Endpoint[(__endpoint0@ Endpoint{.ip=ip, .proto=proto, .preferred_port=preferred_port})], Inspect debug.debug_event((32'd8, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, __endpoint0, EndpointString{.s=addr_port(ip, proto, preferred_port)}).
First5(.str=string_slice_unsafe(p, 64'd0, 64'd5)) :- Phrases[(__phrases0@ Phrases{.phrase=p})], Inspect debug.debug_event((32'd9, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, __phrases0, First5{.str=string_slice_unsafe(p, 64'd0, 64'd5)}).
SanitizedEndpoint(.ep=endpoint) :- Endpoint[(__endpoint0@ Endpoint{.ip=ip, .proto=proto, .preferred_port=preferred_port})], var endpoint = addr_port(ip, proto, preferred_port), Inspect debug.debug_event((32'd10, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __endpoint0, endpoint), not Blacklisted(.ep=endpoint), Inspect debug.debug_event((32'd10, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, endpoint, SanitizedEndpoint{.ep=endpoint}).
BookByAuthor(.book=b, .author=author) :- Library[(__library0@ Library{.book=(b@ Book{.author=author_name, .title=_})})], Author[(author@ Author{.name=author_name, .born=_})], Inspect debug.debug_event_join((32'd11, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __library0, author, BookByAuthor{.book=b, .author=author}).
HostIP(.host=host, .addr=addr) :- HostAddress[(__hostaddress0@ HostAddress{.host=host, .addrs=addrs})], var addr = FlatMap(split_ip_list(addrs)), Inspect debug.debug_event((32'd12, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __hostaddress0, HostIP{.host=host, .addr=addr}).
HostIPVSep(.host=host, .addrs=vaddrs) :- HostAddress[(__hostaddress0@ HostAddress{.host=host, .addrs=addrs})], var vaddrs = vsep(split_ip_list(addrs)), Inspect debug.debug_event((32'd13, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __hostaddress0, HostIPVSep{.host=host, .addrs=vaddrs}).
Evens(.evens_and_odds=vec, .evens=evens(vec)) :- EvensAndOdds[(__evensandodds0@ EvensAndOdds{.vec=vec})], Inspect debug.debug_event((32'd14, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, __evensandodds0, Evens{.evens_and_odds=vec, .evens=evens(vec)}).
Prefix(.vec=prefixBefore(vec, sep)) :- Vector[(__vector0@ Vector{.vec=vec, .sep=sep})], Inspect debug.debug_event((32'd15, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, __vector0, Prefix{.vec=prefixBefore(vec, sep)}).
Sum(.x=x, .y=y, .sum=(x + y)),
Product(.x=x, .y=y, .prod=(x * y)) :- X[(__x0@ X{.x=x})], X[(__x1@ X{.x=y})], Inspect debug.debug_event_join((32'd16, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __x0, __x1, Sum{.x=x, .y=y, .sum=(x + y)}), Inspect debug.debug_event_join((32'd16, 32'd1, 32'd1), ddlog_weight, ddlog_timestamp, __x0, __x1, Product{.x=x, .y=y, .prod=(x * y)}).
BestPrice(.item=item, .price=best_price) :- Price[(__price0@ Price{.item=item, .vendor=_, .price=price})], var __inputs_best_price = Aggregate((item), __debug_17_1_std.group_min((__price0, price))), Inspect debug.debug_event((32'd17, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __inputs_best_price.0, (__inputs_best_price, item)), var best_price = __inputs_best_price.1, Inspect debug.debug_event((32'd17, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, (__inputs_best_price, item), BestPrice{.item=item, .price=best_price}).
WorstPrice(.item=item, .price=best_price) :- Price[(__price0@ Price{.item=item, .vendor=_, .price=price})], var __inputs_best_price = Aggregate((item), __debug_18_1_std.group_max((__price0, price))), Inspect debug.debug_event((32'd18, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __inputs_best_price.0, (__inputs_best_price, item)), var best_price = __inputs_best_price.1, Inspect debug.debug_event((32'd18, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, (__inputs_best_price, item), WorstPrice{.item=item, .price=best_price}).
BestVendor(.item=item, .vendor=best_vendor, .price=best_price) :- Price[(__price0@ Price{.item=item, .vendor=vendor, .price=price})], var __inputs_best_vendor_price = Aggregate((item), __debug_19_1_best_vendor((__price0, (vendor, price)))), Inspect debug.debug_event((32'd19, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __inputs_best_vendor_price.0, (__inputs_best_vendor_price, item)), var best_vendor_price = __inputs_best_vendor_price.1, (var best_vendor, var best_price) = best_vendor_price, Inspect debug.debug_event((32'd19, 32'd3, 32'd0), ddlog_weight, ddlog_timestamp, (item, best_vendor_price), BestVendor{.item=item, .vendor=best_vendor, .price=best_price}).
BestDeal(.best=best) :- Price[(__price0@ Price{.item=item, .vendor=vendor, .price=price})], Inspect inspect_log.log("../tutorial.log", (((((((((("ts:" ++ std.__builtin_2string(ddlog_timestamp)) ++ ", w:") ++ std.__builtin_2string(ddlog_weight)) ++ ": Price(item=\"") ++ item) ++ "\", vendor=\"") ++ vendor) ++ "\", price=") ++ std.__builtin_2string(price)) ++ ")")), Inspect debug.debug_event((32'd20, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __price0, (__price0, item, vendor, price)), var __inputs_best = Aggregate((item), __debug_20_2_best_vendor_string(((__price0, item, vendor, price), (vendor, price)))), Inspect debug.debug_event((32'd20, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, __inputs_best.0, (__inputs_best, item)), var best = __inputs_best.1, Inspect debug.debug_event((32'd20, 32'd3, 32'd0), ddlog_weight, ddlog_timestamp, (__inputs_best, item), (item, best)), Inspect inspect_log.log("../tutorial.log", (((((((("ts:" ++ std.__builtin_2string(ddlog_timestamp)) ++ ", w:") ++ std.__builtin_2string(ddlog_weight)) ++ ": best(\"") ++ item) ++ "\")=\"") ++ best) ++ "\"")), Inspect debug.debug_event((32'd20, 32'd4, 32'd0), ddlog_weight, ddlog_timestamp, (item, best), BestDeal{.best=best}).
TCPDstPort(.port=port) :- Packet[(__packet0@ Packet{.pkt=EthPacket{.src=_, .dst=_, .payload=EthIP4{.ip4=IP4Pkt{.ttl=_, .src=_, .dst=_, .payload=IPTCP{.tcp=TCPPkt{.src=_, .dst=port, .flags=_}}}}}})], Inspect debug.debug_event((32'd21, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, __packet0, TCPDstPort{.port=port}).
TCPDstPort(.port=port) :- Packet[(__packet0@ Packet{.pkt=EthPacket{.src=_, .dst=_, .payload=EthIP6{.ip6=IP6Pkt{.ttl=_, .src=_, .dst=_, .payload=IPTCP{.tcp=TCPPkt{.src=_, .dst=port, .flags=_}}}}}})], Inspect debug.debug_event((32'd22, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, __packet0, TCPDstPort{.port=port}).
UDPDstPort(.port=port) :- Packet[(__packet0@ Packet{.pkt=pkt})], var port = pkt_udp_port(pkt), (port != 16'd0), Inspect debug.debug_event((32'd23, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, port, UDPDstPort{.port=port}).
UDPDstPort2(.port=port) :- Packet[(__packet0@ Packet{.pkt=pkt})], std.Some{.x=var port} = pkt_udp_port2(pkt), Inspect debug.debug_event((32'd24, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __packet0, UDPDstPort2{.port=port}).
IntranetHost(.addr=addr) :- KnownHost[(__knownhost0@ KnownHost{.addr=addr})], (var b3, var b2, _, _) = addr_to_tuple(addr), (b3 == 8'd192), (b2 == 8'd168), Inspect debug.debug_event((32'd25, 32'd3, 32'd0), ddlog_weight, ddlog_timestamp, (addr, b2), IntranetHost{.addr=addr}).
IntranetHost2(.addr=addr) :- KnownHost[(__knownhost0@ KnownHost{.addr=addr})], (8'd192, 8'd168, _, _) = addr_to_tuple(addr), Inspect debug.debug_event((32'd26, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __knownhost0, IntranetHost2{.addr=addr}).
IntranetHost3(.addr=addr) :- KnownHost[(__knownhost0@ KnownHost{.addr=addr})], var t = addr_to_tuple(addr), (t.0 == 8'd192), (t.1 == 8'd168), Inspect debug.debug_event((32'd27, 32'd3, 32'd0), ddlog_weight, ddlog_timestamp, (addr, t), IntranetHost3{.addr=addr}).
TargetAudience[person] :- Person[(__person0@ person)], is_target_audience(person), Inspect debug.debug_event((32'd28, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __person0, person).
StudentInfo(.student=student, .school=school) :- Student[(student@ (&Student{.id=_, .name=_, .school=school_name, .sat_score=_}))], School[(school@ (&School{.name=school_name, .address=_}))], Inspect debug.debug_event_join((32'd29, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, student, school, StudentInfo{.student=student, .school=school}).
TopScore(.school=school, .top_score=top_score) :- StudentInfo[(__studentinfo0@ StudentInfo{.student=(&Student{.id=_, .name=_, .school=_, .sat_score=sat}), .school=(&School{.name=school, .address=_})})], var __inputs_top_score = Aggregate((school), __debug_30_1_std.group_max((__studentinfo0, sat))), Inspect debug.debug_event((32'd30, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __inputs_top_score.0, (__inputs_top_score, school)), var top_score = __inputs_top_score.1, Inspect debug.debug_event((32'd30, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, (__inputs_top_score, school), TopScore{.school=school, .top_score=top_score}).
TopScore(.school=school, .top_score=top_score) :- StudentInfo[(__studentinfo0@ StudentInfo{.student=student, .school=(&School{.name=school, .address=_})})], var __inputs_top_score = Aggregate((school), __debug_31_1_std.group_max((__studentinfo0, student.sat_score))), Inspect debug.debug_event((32'd31, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __inputs_top_score.0, (__inputs_top_score, school)), var top_score = __inputs_top_score.1, Inspect debug.debug_event((32'd31, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, (__inputs_top_score, school), TopScore{.school=school, .top_score=top_score}).
ItemInOrders(.item=internment.ival(item), .orders=orders) :- OnlineOrder[(__onlineorder0@ OnlineOrder{.order_id=order, .item=item})], var __inputs_orders = Aggregate((item), __debug_32_1_std.group2vec((__onlineorder0, order))), Inspect debug.debug_event((32'd32, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __inputs_orders.0, (__inputs_orders, item)), var orders = __inputs_orders.1, Inspect debug.debug_event((32'd32, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, (__inputs_orders, item), ItemInOrders{.item=internment.ival(item), .orders=orders}).
OrderFormatted(.order=formatted) :- OnlineOrder[(__onlineorder0@ OnlineOrder{.order_id=order, .item=item})], (var formatted: string) = ((("order: " ++ std.__builtin_2string(order)) ++ ", item: ") ++ internment.ival(item)), Inspect debug.debug_event((32'd33, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __onlineorder0, OrderFormatted{.order=formatted}).
MilkOrders(.order=order) :- OnlineOrder[(__onlineorder0@ OnlineOrder{.order_id=order, .item=internment.intern("milk")})], Inspect debug.debug_event((32'd34, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, __onlineorder0, MilkOrders{.order=order}).
InventoryItemName(.name=name) :- StoreInventory[(__storeinventory0@ StoreInventory{.item=item})], var name = internment.ival(item).name, Inspect debug.debug_event((32'd35, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __storeinventory0, InventoryItemName{.name=name}).
Flow(.lr=ls, .stage=LS_IN_PRE_LB{}, .prio=100, .matchStr=("ip4.dst == " ++ addresses), .actionStr="{ reg0[0] = 1; next; }") :- Load_Balancer[(__load_balancer0@ Load_Balancer{.lb=_, .ls=ls, .ip_addresses=addresses, .protocol=std.Some{.x=_}, .name=_})], Inspect debug.debug_event((32'd36, 32'd0, 32'd0), ddlog_weight, ddlog_timestamp, __load_balancer0, Flow{.lr=ls, .stage=LS_IN_PRE_LB{}, .prio=100, .matchStr=("ip4.dst == " ++ addresses), .actionStr="{ reg0[0] = 1; next; }"}).
Flow(.lr=ls, .stage=LS_OUT_PRE_LB{}, .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }") :- Logical_Switch[(__logical_switch0@ Logical_Switch{.ls=ls})], Load_Balancer[(__load_balancer1@ Load_Balancer{.lb=_, .ls=ls, .ip_addresses=_, .protocol=_, .name=_})], Inspect debug.debug_event_join((32'd37, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, __logical_switch0, __load_balancer1, Flow{.lr=ls, .stage=LS_OUT_PRE_LB{}, .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }"}).
Flow1(.lr=lb.ls, .stage=LS_IN_PRE_LB{}, .prio=100, .matchStr=("ip4.dst == " ++ a), .actionStr="{ reg0[0] = 1; next; }") :- Load_Balancer[(lb@ Load_Balancer{.lb=_, .ls=_, .ip_addresses=_, .protocol=_, .name=_})], var a = lb.ip_addresses, match (lb.protocol) {
                                                                                                                                                                                                                                                 std.Some{.x=_} -> true,
                                                                                                                                                                                                                                                 std.None{} -> false
                                                                                                                                                                                                                                             }, Inspect debug.debug_event((32'd38, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, (lb, a), Flow1{.lr=lb.ls, .stage=LS_IN_PRE_LB{}, .prio=100, .matchStr=("ip4.dst == " ++ a), .actionStr="{ reg0[0] = 1; next; }"}).
Flow1(.lr=ls.ls, .stage=LS_OUT_PRE_LB{}, .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }") :- Logical_Switch[(ls@ Logical_Switch{.ls=_})], Load_Balancer[(lb@ Load_Balancer{.lb=_, .ls=_, .ip_addresses=_, .protocol=_, .name=_})], Inspect debug.debug_event_join((32'd39, 32'd1, 32'd0), ddlog_weight, ddlog_timestamp, ls, lb, (ls, lb)), (lb.ls == ls.ls), Inspect debug.debug_event((32'd39, 32'd2, 32'd0), ddlog_weight, ddlog_timestamp, (ls, lb), Flow1{.lr=ls.ls, .stage=LS_OUT_PRE_LB{}, .prio=100, .matchStr="ip4", .actionStr="{ reg0[0] = 1; next; }"}).

