typedef set<'A>
typedef stage = LS_IN_ACL{} | LS_OUT_ACL{} | LR_IN_ADMISSION{} | LR_IN_IP_INPUT{} | LR_IN_UNSNAT{} | LR_OUT_SNAT{} | LR_IN_DNAT{} | LR_IN_ARP_RESOLVE{}
function __builtin_2string (x: 'X): string
for (lr in Logical_Router)
    {
        Flow ( lr, LR_IN_ADMISSION{}, 100, "vlan.present || eth.src[40]", "{ drop; }" )
    }
for (lrp in Logical_Router_Port if lrp.enabled)
    {
        let p = lrp.name, e = lrp.mac in
            {
                Flow ( lrp.lr, LR_IN_ADMISSION{}, 50, (((("inport == " ++ p) ++ " && (eth.mcast || eth.dst == ") ++ e) ++ ")"), "{ next; }" )
            }
    }
for (lr in Logical_Router)
    {
        Flow ( lr, LR_IN_IP_INPUT{}, 100, "ip4.mcast ||\n           ip4.src == 255.255.255.255 ||\n           ip4.src == 127.0.0.0/8 ||\n           ip4.dst == 127.0.0.0/8 ||\n           ip4.src == 0.0.0.0/8 ||\n           ip4.dst == 0.0.0.0/8)", "{ drop; }" );
        Flow ( lr, LR_IN_IP_INPUT{}, 90, "arp.op == 2", "put_arp(inport, arp.spa, arp.sha);" );
        Flow ( lr, LR_IN_IP_INPUT{}, 50, "eth.bcast", "{ drop; }" );
        Flow ( lr, LR_IN_IP_INPUT{}, 30, "ip4 && ip.ttl == {0, 1}", "{ drop; }" );
        Flow ( lr, LR_IN_IP_INPUT{}, 90, "nd_na", "{ put_nd(inport, nd.target, nd.tll); }" );
        Flow ( lr, LR_IN_IP_INPUT{}, 80, "nd_na", "{ put_nd(inport, ip6.src, nd.sll); }" );
        Flow ( lr, LR_IN_IP_INPUT{}, 0, "1", "{ next; }" )
    }
for (lr in Logical_Router)
    {
        Flow ( lr, LR_IN_DEFRAG{}, 0, "1", "{ next; }" );
        Flow ( lr, LR_IN_UNSNAT{}, 0, "1", "{ next; }" );
        Flow ( lr, LR_OUT_SNAT{}, 0, "1", "{ next; }" );
        Flow ( lr, LR_IN_DNAT{}, 0, "1", "{ next; }" )
    }
for (lr in Logical_Router)
    {
        Flow ( lr, LR_IN_ARP_RESOLVE{}, 0, "ip4", "{ get_arp(outport, reg0); next; }" );
        Flow ( lr, LR_IN_ARP_RESOLVE{}, 0, "ip6", "{ get_nd(outport, xxreg0); next; }" )
    }
for (lr in Logical_Router)
    {
        Flow ( lr, LR_IN_ARP_REQUEST{}, 100, "eth.dst == 00:00:00:00:00:00", "{\n        arp {\n            eth.dst = ff:ff:ff:ff:ff:ff;\n            arp.spa = reg1;\n            arp.tpa = reg0;\n            arp.op = 1;  /* ARP request */\n            output;\n        }\n    }" );
        Flow ( lr, LR_IN_ARP_REQUEST{}, 0, "1", "{ output; }" )
    }
for (lrp in Logical_Router_Port if lrp.enabled)
    {
        let p = lrp.name in
            {
                Flow ( lrp.lr, LR_OUT_DELIVERY{}, 100, (("outport == " ++ p) ++ ""), "{ output; }" )
            }
    }
for (ls in Logical_Switch)
    {
        Flow ( ls, LS_IN_ACL{}, 0, "1", "next;" );
        Flow ( ls, LS_OUT_ACL{}, 0, "1", "next;" )
    }
for (ls in Logical_Switch if ls.has_stateful_acl)
    {
        Flow ( ls, LS_IN_ACL{}, 1, "ip && (!ct.est || (ct.est && ct_label.blocked))", "{ reg0[1] = 1; next; }" );
        Flow ( ls, LS_OUT_ACL{}, 1, "ip && (!ct.est || (ct.est && ct_label.blocked))", "{ reg0[1] = 1; next; }" );
        Flow ( ls, LS_IN_ACL{}, 65535, "ct.inv || (ct.est && ct.rpl && ct_label.blocked)", "{ drop; }" );
        Flow ( ls, LS_OUT_ACL{}, 65535, "ct.inv || (ct.est && ct.rpl && ct_label.blocked)", "{ drop; };" );
        Flow ( ls, LS_IN_ACL{}, 65535, "(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && !ct_label.blocked)", "{ next; }" );
        Flow ( ls, LS_OUT_ACL{}, 65535, "(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && !ct_label.blocked)", "{ next; }" );
        Flow ( ls, LS_IN_ACL{}, 65535, "!ct.est && ct.rel && !ct.new && !ct.inv && !ct_label.blocked", "{ next; }" );
        Flow ( ls, LS_OUT_ACL{}, 65535, "!ct.est && ct.rel && !ct.new && !ct.inv && !ct_label.blocked", "{ next; }" );
        Flow ( ls, LS_IN_ACL{}, 65535, "nd", "{ next; }" );
        Flow ( ls, LS_OUT_ACL{}, 65535, "nd", "{ next; }" )
    }
for (ls in Logical_Switch)
    {
        Flow ( ls, LS_IN_LB{}, 0, "1", "{ next; }" );
        Flow ( ls, LS_OUT_LB{}, 0, "1", "{ next; }" );
        if (ls.has_load_balancer)
            {
                Flow ( ls, LS_IN_LB{}, 65535, "ct.est && !ct.rel && !ct.new && !ct.inv", "\n            reg0[0] = 1;\n            next;\n        };" );
                Flow ( ls, LS_OUT_LB{}, 65535, "ct.est && !ct.rel && !ct.new && !ct.inv", "\n            reg0[0] = 1;\n            next;\n        };" )
            }
    }
for (ls in Logical_Switch)
    {
        Flow ( ls, LS_IN_PRE_ACL{}, 0, "1", "{ next; }" );
        Flow ( ls, LS_OUT_PRE_ACL{}, 0, "1", "{ next; }" )
    }
for (ls in Logical_Switch if ls.has_stateful_acl)
    {
        Flow ( ls, LS_IN_PRE_ACL{}, 110, "nd", "{ next; }" );
        Flow ( ls, LS_OUT_PRE_ACL{}, 110, "nd", "{ next; }" );
        Flow ( ls, LS_IN_PRE_ACL{}, 100, "ip", "{ reg0[0] = 1; next; }" );
        Flow ( ls, LS_OUT_PRE_ACL{}, 100, "ip", "{ reg0[0] = 1; next; }" )
    }
for (lb in Load_Balancer)
    {
        let a = lb.ip_addresses in
            Flow ( lb.ls, LS_IN_PRE_LB{}, 100, "ip4.dst == ${a}", "{ reg0[0] = 1; next; }" )
    }
for (ls in Logical_Switch)
    {
        if (ls.has_load_balancer)
            {
                Flow ( ls, LS_OUT_PRE_LB{}, 100, "ip4", "{ reg0[0] = 1; next; }" )
            }
    }
for (ls in Logical_Switch)
    {
        Flow ( ls, LS_IN_PRE_LB{}, 0, "1", "{ next; }" );
        Flow ( ls, LS_OUT_PRE_LB{}, 0, "1", "{ next; }" )
    }
for (ls in Logical_Switch)
    {
        Flow ( ls, LS_IN_PRE_STATEFUL{}, 0, "1", "{ next; }" );
        Flow ( ls, LS_OUT_PRE_STATEFUL{}, 0, "1", "{ next; }" );
        Flow ( ls, LS_IN_PRE_STATEFUL{}, 100, "reg0[0] /* conntrack.defrag */", "{ ct_next; }" );
        Flow ( ls, LS_OUT_PRE_STATEFUL{}, 100, "reg0[0] /* conntrack.defrag */", "{ ct_next; }" )
    }
for (ls in Logical_Switch)
    {
        Flow ( ls, LS_IN_STATEFUL{}, 0, "1", "{ next; }" );
        Flow ( ls, LS_OUT_STATEFUL{}, 0, "1", "{ next; }" );
        Flow ( ls, LS_IN_STATEFUL{}, 100, "reg0[1] == 1", "{\n        ct_commit(ct_label=0/1);\n        next;\n    }" );
        Flow ( ls, LS_OUT_STATEFUL{}, 100, "reg0[1] == 1", "{\n        ct_commit(ct_label=0/1);\n        next;\n    }" );
        Flow ( ls, LS_IN_STATEFUL{}, 100, "reg0[2] == 1", "{ ct_lb; }" );
        Flow ( ls, LS_OUT_STATEFUL{}, 100, "reg0[2] == 1", "{ ct_lb; }" )
    }
for (lsp in Logical_Switch_Port)
    {
        Flow ( lsp.ls, LS_IN_PORT_SEC_L2{}, 100, "vlan.present", "{ drop; }" );
        Flow ( lsp.ls, LS_IN_PORT_SEC_L2{}, 100, "eth.src[40]", "{ drop; }" )
    }
for (lsp in Logical_Switch_Port if lsp.enabled)
    {
        let p = lsp.name, l2 = lsp.port_security_l2, ip = lsp.port_security_ip_ingress, nd = lsp.port_security_nd in
            {
                if (lsp.port_security.not_empty)
                    {
                        Flow ( lsp.ls, LS_IN_PORT_SEC_L2{}, 50, (((("inport == \"" ++ p) ++ "\" && eth.src == ") ++ l2) ++ ""), "{ next; }" );
                        Flow ( lsp.ls, LS_IN_PORT_SEC_IP{}, 90, (((("inport == \"" ++ p) ++ "\" && (") ++ ip) ++ "))"), "{ next; }" );
                        Flow ( lsp.ls, LS_IN_PORT_SEC_IP{}, 80, (((("inport == \"" ++ p) ++ "\" && ip && eth.src == ") ++ l2) ++ ""), "{ drop; }" );
                        Flow ( lsp.ls, LS_IN_PORT_SEC_ND{}, 90, (((("inport == \"" ++ p) ++ "\" && (") ++ nd) ++ ")"), "{ next; }" );
                        Flow ( lsp.ls, LS_IN_PORT_SEC_ND{}, 80, (("inport == \"" ++ p) ++ "\" && (arp || nd)"), "{ drop; }" )
                    }
                else
                    {
                        Flow ( lsp.ls, LS_IN_PORT_SEC_L2{}, 50, (("inport == \"" ++ p) ++ "\""), "{ next; }" )
                    }
            }
    }
for (lsp in Logical_Switch_Port)
    {
        Flow ( lsp.ls, LS_IN_PORT_SEC_ND{}, 0, "1", "{ next; }" );
        Flow ( lsp.ls, LS_IN_PORT_SEC_IP{}, 0, "1", "{ next; }" )
    }
for (lsp in Logical_Switch_Port)
    if ((lsp.type == "localnet"))
        {
            let p = lsp.name in
                Flow ( lsp.ls, LS_IN_ARP_RSP{}, 100, (("inport == \"" ++ p) ++ "\""), "{ next; }" )
        }
for (ls in Logical_Switch)
    Flow ( ls, LS_IN_ARP_RSP{}, 0, "1", "{ next; }" )
for (lspip in Logical_Switch_Port_IP if lspip.lsp.up)
    {
        let e = lspip.mac, a = lspip.ip, p = lspip.lsp.name in
            {
                if ((lspip.ip_version == 4))
                    {
                        Flow ( lspip.lsp.ls, LS_IN_ARP_RSP{}, "50", (((((((("\n                arp.tpa == " ++ a) ++ " && arp.op == 1) {\n                eth.dst = eth.src;\n                eth.src = ") ++ e) ++ ";\n                arp.op = 2;     /* ARP reply */\n                arp.tha = arp.sha;\n                arp.sha = ") ++ e) ++ ";\n                arp.tpa = arp.spa;\n                arp.spa = ") ++ a) ++ ";\n                outport = inport;\n                flags.loopback = 1;\n                output;\n            };") );
                        Flow ( lspip.lsp.ls, LS_IN_ARP_RSP{}, 100, (((("arp.tpa == " ++ a) ++ " && arp.op == 1 && inport == \"") ++ p) ++ "\""), "{ next; }" )
                    }
                else
                    {
                        let s = lspip.sn_ip in
                            {
                                Flow ( lspip.lsp.ls, LS_IN_ARP_RSP{}, 50, (((((("nd_ns && ip6.dst == {" ++ a) ++ ", ") ++ s) ++ "} && nd.target == ") ++ a) ++ ""), (((((((("{\n                     nd_na {\n                        eth.src = " ++ e) ++ ";\n                        ip6.src = ") ++ a) ++ ";\n                        nd.target = ") ++ a) ++ ";\n                        nd.tll = ") ++ e) ++ ";\n                        outport = inport;\n                        flags.loopback = 1;\n                        output;\n                    };\n                }") );
                                Flow ( lspip.lsp.ls, LS_IN_ARP_RSP{}, 100, " nd_ns && ip6.dst == {${a}, ${s}} && nd.target == ${a}\n                     && inport == \\\"${p}\\\"", "{ next; }" )
                            }
                    }
            }
    }
for (ls in Logical_Switch)
    {
        Flow ( ls, LS_IN_DHCP_OPTIONS{}, 0, "1", "{ next; }" );
        Flow ( ls, LS_IN_DHCP_RESPONSE{}, 0, "1", "{ next; }" )
    }
for (lspip in Logical_Switch_Port_IP if (lspip.lsp.enabled and (lspip.lsp.type != "router")))
    {
        let p = lspip.lsp.name, a = lspip.ip, e = lspip.mac in
            {
                if ((lspip.ip_version == 4))
                    {
                        if (lspip.lsb.has_dhcpv4_options)
                            {
                                let m = lspip.lsp.dhcpv4_options.netmask, o = lspip.lsp.dhcpv4_options.option_args, sm = lspip.lsp.dhcpv4_options.server_mac, si = lspip.lsp.dhcpv4_options.server_ip in
                                    {
                                        Flow ( lspip.lsp.ls, LS_IN_DHCP_OPTIONS{}, 100, " inport == \"${p}\" && eth.src == ${e}\n                         && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255\n                         && udp.src == 68 && udp.dst == 67", "{\n                        reg0[3] = put_dhcp_opts(offerip = ${a},\n                                                netmask = ${m},\n                                                ${o}); next; }" );
                                        Flow ( lspip.lsp.ls, LS_IN_DHCP_RESPONSE{}, 100, "inport == \"${p}\" && eth.src == ${e}\n                         && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255\n                         && udp.src == 68 && udp.dst == 67\n                         && reg0[3]", "{\n                        eth.dst = eth.src;\n                        eth.src = ${sm};\n                        ip4.dst = ${a};\n                        ip4.src = ${si};\n                        udp.src = 67;\n                        udp.dst = 68;\n                        outport = inport;\n                        flags.loopback = 1;\n                        output;\n                    };" )
                                    }
                            }
                    }
                else
                    {
                        let o = lspip.lsp.dhcpv6_options.option_args, sm = lspip.lsp.dhcpv6_options.server_mac, si = lspip.lsp.dhcpv6_options.server_ip in
                            {
                                if (lspip.lsp.dhcpv6_options.stateful)
                                    {
                                        Flow ( lspip.lsp.ls, LS_IN_DHCP_OPTIONS{}, 100, "inport == \"${p}\" && eth.src == ${e}\n                         && ip6.dst == ff02::1:2\n                         && udp.src == 546 && udp.dst == 547)", "{\n                        reg0[3] = put_dhcpv6_opts(ia_addr = ${a}, ${o});\n                        next;\n                    }" )
                                    }
                                else
                                    {
                                        Flow ( lspip.lsp.ls, LS_IN_DHCP_OPTIONS{}, 100, "inport == \"${p}\" && eth.src == ${e}\n                         && ip6.dst == ff02::1:2\n                         && udp.src == 546 && udp.dst == 547)", "{\n                        reg0[3] = put_dhcpv6_opts(${o});\n                        next;\n                    }" )
                                    };
                                Flow ( lspip.lsp.ls, LS_IN_DHCP_RESPONSE{}, 100, "inport == \"${p}\" && eth.src == ${e}\n                     && ip6.dst == ff02::1:2\n                     && udp.src == 546 && udp.dst == 547\n                     && reg0[3]", "{\n                    eth.dst = eth.src;\n                    eth.src = ${sm};\n                    ip6.dst = ip6.src;\n                    ip6.src = ${si};\n                    udp.src = 547;\n                    udp.dst = 546;\n                    outport = inport;\n                    flags.loopback = 1;\n                    output;\n                };" )
                            }
                    }
            }
    }
for (ls in Logical_Switch)
    {
        Flow ( ls, LS_IN_L2_LKUP{}, 100, "eth.mcast", "{\n        outport = \"_MC_flood\";\n        output;\n    };" )
    }
for (lsp in Logical_Switch_Port)
    {
        if ((lsp.macs != ""))
            {
                let P = lsp.name, M = lsp.macs in
                    {
                        Flow ( lsp.ls, LS_IN_L2_LKUP{}, 50, (("eth.dst == {" ++ M{}) ++ "}"), "{\n                outport = \"${P}\";\n                output;\n            }" )
                    }
            }
    }
for (ls in Logical_Switch)
    {
        Flow ( ls, LS_IN_L2_LKUP{}, 0, "1", "{\n        outport = \"_MC_unknown\";\n        output;\n    }" )
    }
for (lsp in Logical_Switch_Port)
    {
        let p = lsp.name, l2 = lsp.port_security_l2, ip = lsp.port_security_ip_egress in
            {
                if (lsp.has_port_security)
                    {
                        Flow ( lsp.ls, LS_OUT_PORT_SEC_IP{}, 90, (((("\"outport == \"" ++ p) ++ "\" && (") ++ ip) ++ ")"), "{ next; }" );
                        Flow ( lsp.ls, LS_OUT_PORT_SEC_IP{}, 80, (((("\"outport == \"" ++ p) ++ "\" && ip && eth.dst == ") ++ l2) ++ ""), "{ drop; }" )
                    };
                if (lsp.enabled)
                    {
                        Flow ( lsp.ls, LS_OUT_PORT_SEC_L2{}, 50, (((("outport == \"" ++ p) ++ "\" && eth.dst == ") ++ l2) ++ ""), "{ output; }" )
                    }
                else
                    {
                        Flow ( lsp.ls, LS_OUT_PORT_SEC_L2{}, 150, (("outport == \"" ++ p) ++ "\""), "{ drop; }" )
                    }
            }
    }
for (ls in Logical_Switch)
    {
        Flow ( ls, LS_OUT_PORT_SEC_IP{}, 0, "1", "{ next; }" );
        Flow ( ls, LS_OUT_PORT_SEC_L2{}, 100, "eth.mcast", "{ output; }" )
    }
