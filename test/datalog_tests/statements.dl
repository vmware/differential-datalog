ground relation X(field: int)
relation Z(field: int)

relation W(f1: int, f2: int, f3: int)

for (a in X)
   skip

for (a in X)
   Z(a.field)
// equivalent to
Z(a.field) :- X[a].

for (a in X)
   match (a.field) {
      1 -> Z(a.field),
      2 -> Z(a.field+1),
      _ -> Z(a.field-1)
   }

for (X{a} in X)
   match (a) {
      1 -> Z(a),
      2 -> Z(a+1),
      _ -> Z(a-1)
   }
// both are equivalent to
Z(a) :- X(a), match(a) { 1 -> true, _ -> false }.
Z(a+1) :- X(a), match(a) { 1-> false, 2 -> true, _ -> false }.
Z(a-1) :- X(a), match(a) { 1 -> false, 2 -> false, _ -> true }.

for (a in X if true)
   skip
// equivalent to
for (a in X)
   if (true)
       skip

for (a in X) {
   skip;
   skip
}

for (a in X if (a.field % 2) == 0)
    Z(a.field)
// equivalent to
for (a in X)
    if (a.field % 2 == 0)
         Z(a.field)
// equivalent to
Z(a) :- X(a), ((a % 2) == 0).

for (a in X) {
    if (a.field == 2)
        skip
}

for (a in X) {
    if (a.field == 2)
        skip
    else
        skip
}

for (a in X) {
    if (a.field == 2)
        Z(a.field+1)
    else
        Z(a.field)
}
// equivalent to
Z(a+1) :- X(a), a == 2.
Z(a) :- X(a), a != 1.

for (a in X)
    if (a.field >= 2)
        if (a.field > 2) {
            Z(a.field);
            Z(a.field+2)
        }
// equivalent to
Z(a) :- X(a), a>=2, a > 2.
Z(a+2) :- X(a), a>=2, a > 2.

for (a in X) {
    for (b in X)
        Z(a.field+b.field);
    for (c in X)
        Z(a.field+c.field)
}
// equivalent to
Z(a+b) :- X(a), X(b).
Z(a+c) :- X(a), X(c).
// Equivalent to
Z(a+b), Z(a+c) :- X(a), X(b), X(c).

for (a in X)
   let b = a.field+2 in
       skip

for (a in X)
   let b = a.field+2 in
       Z(a.field+b)
// equivalent to
Z(a+b) :- X(a), var b = a+2.

for (a in X)
   let b = a.field+2, c = b+a.field in
       W(a.field, b, c)
// equivalent to
W(a, b, c) :- X(a), var b = a+2, var c = b+a.
