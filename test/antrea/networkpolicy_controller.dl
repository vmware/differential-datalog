/*
 * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).
 */

import intern
import k8spolicy as k8s
import types
import klog as klog

/* In DDlog, we split the AppliedToGroup struct into three relations:
 * AppliedToGroupDescr: stores group name, id, and GroupSelector
 * AppliedToGroupPodsByNode: stores the node-to-pods mapping.
 * AppliedToGroupSpan: group span (nodes where the group must be sent).
 */

relation AppliedToGroupDescr (
    // UID is generated from the hash value of GroupSelector.NormalizedName.
    uid: k8s.UID,
    // Name of this group, currently it's same as UID.
    name: string,
    // Selector describes how the group selects pods.
    selector: GroupSelector
)

// PodsByNode is a mapping from nodeName to a set of Pods on the Node.
relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.PodReference>>)

// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.
relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<string>)

output relation AppliedToGroup (
    descr: AppliedToGroupDescr,
    podsByNode: Map<string, Set<k8s.PodReference>>,
    span: Set<string>
)

AppliedToGroup(descr, podsByNode, span) :-
    descr in AppliedToGroupDescr(),
    AppliedToGroupPodsByNode(descr.uid, podsByNode),
    AppliedToGroupSpan(descr.uid, span).

/* In DDlog, we split the AddressGroup struct into three relations:
 * AddressGroupDescr: stores group name, id, and GroupSelector
 * AddressGroupAddress: stores addresses of nodes that match the group selector.
 * AddressGroupSpan: group span (nodes where the group must be sent).
 */

// AddressGroupDescr describes a set of addresses used as source or destination of Network Policy rules.
relation AddressGroupDescr (
    // UID is generated from the hash value of GroupSelector.NormalizedName.
    uid: k8s.UID,
    // Name of this group, currently it's same as UID.
    name: string,
    // Selector describes how the group selects pods to get their addresses.
    selector: GroupSelector
)

// Addresses is a set of IP addresses selected by this group.
relation AddressGroupAddress(addressGroup: k8s.UID, address: string)

// Aggregate all addresses for an address group in one record.
relation AddressGroupAddresses(addressGroup: k8s.UID, addresses: Set<string>)
AddressGroupAddresses(addressGroup, addresses) :-
    AddressGroupAddress(addressGroup, address),
    var addresses = Aggregate((addressGroup), group2set(address)).

// Handle the case when the group is empty.
AddressGroupAddresses(gid, set_empty()) :-
    AddressGroupDescr(.uid = gid),
    not AddressGroupAddress(.addressGroup = gid).

// AddressGroupSpan: set of node names that this AddressGroup should be sent to.
relation AddressGroupSpan(addressGroup: k8s.UID, span: Set<string>)

output relation AddressGroup (
    descr: AddressGroupDescr,
    addresses: Set<string>,
    span: Set<string>
)

AddressGroup(descr, addresses, span) :-
    descr in AddressGroupDescr(),
    AddressGroupAddresses(descr.uid, addresses),
    AddressGroupSpan(descr.uid, span).

// NetworkPolicy describes what network traffic is allowed for a set of Pods.
relation NetworkPolicyDescr (
    // UID of the original K8s Network Policy.
    uid: k8s.UID,
    // Name of the original K8s Network Policy.
    name: string,
    // Namespace of the original K8s Network Policy.
    namespace: string,
    // Rules is a list of rules to be applied to the selected Pods.
    rules: Vec<NetworkPolicyRule>,
    // AppliedToGroups is a list of names of AppliedToGroups to which this policy applies.
    appliedToGroups: Vec<string>
)

// NetworkPolicySpan: set of node names that this NetworkPolicyDescr should be sent to.
relation NetworkPolicySpan(policy: k8s.UID, span: Set<string>)

output relation NetworkPolicy(
    descr: NetworkPolicyDescr,
    span: Set<string>)

NetworkPolicy(descr, span) :-
    descr in NetworkPolicyDescr(),
    NetworkPolicySpan(descr.uid, span).

// createAppliedToGroup creates an AppliedToGroupDescr object.
function createAppliedToGroup(np: k8s.NetworkPolicy): AppliedToGroupDescr =
{
    klog.info("createAppliedToGroup ${np.name}");
    var groupSelector = toGroupSelector(np.namespace, Some{np.spec.podSelector}, None);
    var appliedToGroupUID = getNormalizedUID(groupSelector.normalizedName);
    // Construct a new AppliedToGroupDescr.
    AppliedToGroupDescr {
        .name       = appliedToGroupUID,
        .uid        = k8s.UID{appliedToGroupUID},
        .selector   = groupSelector
    }
}

function toAntreaPeer(peers: Vec<k8s.NetworkPolicyPeer>, np: k8s.NetworkPolicy): (NetworkPolicyPeer, Vec<AddressGroupDescr>) =
{
    // Empty NetworkPolicyPeer is supposed to match all addresses.
    // See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-ingress-traffic.
    // It's treated as an IPBlock "0.0.0.0/0".
    if (vec_is_empty(peers)) {
        (matchAllPeer(), vec_empty())
    } else {
        var ipBlocks: Vec<IPBlock> = vec_empty();
        var addressGroupNames: Vec<string> = vec_empty();
        var addressGroups: Vec<AddressGroupDescr> = vec_empty();

        for (peer in peers) {
            // A networking.NetworkPolicyPeer will either have an IPBlock or a
            // podSelector and/or namespaceSelector set.
            match (peer.ipBlock) {
                Some{peerIPBlock} -> {
                    match (toAntreaIPBlock(peerIPBlock)) {
                        Err{err} -> {
                            klog.error("Failure processing NetworkPolicy ${np.namespace}/${np.name} IPBlock ${peerIPBlock}: ${err}");
                            ()
                        },
                        Ok{ipBlock} -> {
                            vec_push(ipBlocks, ipBlock)
                        }
                    }
                },
                None -> {
                    var addressGroup = createAddressGroup(peer, np);
                    vec_push(addressGroups, addressGroup);
                    vec_push(addressGroupNames, addressGroup.name)
                }
            }
        };
        var nppeer = NetworkPolicyPeer {
            .addressGroups  = addressGroupNames,
            .ipBlocks       = ipBlocks
        };
        (nppeer, addressGroups)
    }
}

// toAntreaProtocol converts a v1.Protocol object to an Antrea Protocol object.
function toAntreaProtocol(npProtocol: Option<k8s.Protocol>): Protocol =
{
    // If Protocol is unset, it must default to TCP protocol.
    match (npProtocol) {
        None -> protocolTCP(),
        Some{proto} -> proto
    }
}

// toAntreaServices converts a networkingv1.NetworkPolicyPort object to an
// Antrea Service object.
function toAntreaServices(npPorts: Vec<k8s.NetworkPolicyPort>): Vec<Service> =
{
    var antreaServices: Vec<Service> = vec_empty();
    for (npPort in npPorts) {
        var antreaService = Service {
            .protocol   = toAntreaProtocol(npPort.protocol),
            .port       = match (npPort.port) {
                None    -> None: Option<signed<32>>,
                // TODO(abhiraut): Retrieve ports for named ports.
                Some{p} -> Some{ k8s.intOrStringIntValue(p) }
            }
        };
        vec_push(antreaServices, antreaService)
    };
    antreaServices
}

// toAntreaIPBlock converts a networkingv1.IPBlock to an Antrea IPBlock.
function toAntreaIPBlock(ipBlock: k8s.IPBlock): Result<IPBlock,string> =
{
    // Convert the allowed IPBlock to networkpolicy.IPNet.
    match (cidrStrToIPNet(ipBlock.cidr)) {
        Err{err} -> Err{err},
        Ok{ipNet} -> {
            var exceptNets: Vec<IPNet> = vec_empty();
            for (exc in ipBlock.except) {
                // Convert the except IPBlock to networkpolicy.IPNet.
                match (cidrStrToIPNet(exc)) {
                    Err{e} -> {
                        return Err{e}
                    },
                    Ok{exceptNet} -> {
                        vec_push(exceptNets, exceptNet)
                    }
                }
            };
            Ok { IPBlock { .cidr   = ipNet, .except = exceptNets } }
        }
    }
}

// createAddressGroup creates an AddressGroupDescr object corresponding to a
// NetworkPolicyPeer object in NetworkPolicyRule. This function simply
// creates the object without actually populating the PodAddresses as the
// affected Pods are calculated during sync process.
function createAddressGroup(peer: k8s.NetworkPolicyPeer, np: k8s.NetworkPolicy): AddressGroupDescr =
{
    var groupSelector = toGroupSelector(np.namespace, peer.podSelector, peer.namespaceSelector);
    var normalizedUID = getNormalizedUID(groupSelector.normalizedName);

    // Create an AddressGroupDescr object per Peer object.
    AddressGroupDescr{
        .uid        = k8s.UID{normalizedUID},
        .name       = normalizedUID,
        .selector   = groupSelector
    }
}

// processNetworkPolicy creates an internal NetworkPolicy instance corresponding
// to the networkingv1.NetworkPolicy object. This method does not commit the
// internal NetworkPolicy in store, instead returns an instance to the caller
// wherein, it will be either stored as a new Object in case of ADD event or
// modified and store the updated instance, in case of an UPDATE event.
function processNetworkPolicy(np: k8s.NetworkPolicy): (NetworkPolicyDescr, AppliedToGroupDescr, Vec<AddressGroupDescr>) =
{
    var appliedToGroup = createAppliedToGroup(np);
    var rules: Vec<NetworkPolicyRule> = vec_empty();
    var addressGroups: Vec<AddressGroupDescr> = vec_empty();
    var ingressRuleExists = false;
    var egressRuleExists  = false;

    // Compute NetworkPolicyRule for Ingress Rule.
    for (ingressRule in np.spec.ingress) {
        ingressRuleExists = true;
        (var from, var agroups) = toAntreaPeer(ingressRule.from, np);
        vec_append(addressGroups, agroups);
        vec_push(rules, NetworkPolicyRule{
            .direction = DirectionIn,
            .from      = from,
            .to        = networkPolicyPeerEmpty(),
            .services  = toAntreaServices(ingressRule.ports)
        })
    };
    // Compute NetworkPolicyRule for Egress Rule.
    for (egressRule in np.spec.egress) {
        egressRuleExists = true;
        (var to, var agroups) = toAntreaPeer(egressRule.to, np);
        vec_append(addressGroups, agroups);
        vec_push(rules, NetworkPolicyRule {
            .direction = DirectionOut,
            .from      = networkPolicyPeerEmpty(),
            .to        = to,
            .services  = toAntreaServices(egressRule.ports)
        })
    };

    // Traffic in a direction must be isolated if Spec.PolicyTypes specify it explicitly.
    var ingressIsolated = false;
    var egressIsolated = false;
    for (policyType in np.spec.policyTypes) {
        match (policyType) {
            k8s.PolicyTypeIngress -> ingressIsolated = true,
            k8s.PolicyTypeEgress  -> egressIsolated = true
        }
    };

    // If ingress isolation is specified explicitly and there's no ingress rule, append a deny-all ingress rule.
    // See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-traffic
    if (ingressIsolated and (not ingressRuleExists)) {
        vec_push(rules, denyAllIngressRule())
    };
    // If egress isolation is specified explicitly and there's no egress rule, append a deny-all egress rule.
    // See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-egress-traffic
    if (egressIsolated and (not egressRuleExists)) {
        vec_push(rules, denyAllEgressRule())
    };

    var policy = NetworkPolicyDescr {
        .name               = np.name,
        .namespace          = np.namespace,
        .uid                = np.uid,
        .appliedToGroups    = vec_singleton(appliedToGroup.name),
        .rules              = rules
    };

    (policy, appliedToGroup, addressGroups)
}

// Intermediate relation that stores policy and all associated address groups.
// This relation does not get indexed and therefore should not take any memory.
relation NetworkPolicyExt(
    policy: NetworkPolicyDescr,
    addressGroups: Vec<AddressGroupDescr>
)

NetworkPolicyExt(internalPolicy, addrGroups),
AppliedToGroupDescr[appliedTo] :-
    k8s.NetworkPolicy[policy],
    (var internalPolicy, var appliedTo, var addrGroups) = processNetworkPolicy(policy).

NetworkPolicyDescr[policy] :- NetworkPolicyExt(policy, _).

AddressGroupDescr[group] :-
    NetworkPolicyExt(_, groups),
    var group = FlatMap(groups).

AddressGroupAddress(addressGroup.uid, pod.status.podIP) :-
    // Namespace presence indicates Pods must be selected from the same Namespace.
    addressGroup in AddressGroupDescr(.selector = GroupSelector{.nsSelector = NSSelectorNS{ns}}),
    pod in k8s.Pod(.namespace = ns),
    pod.status.podIP != "",
    k8s.labelSelectorMatches(addressGroup.selector.podSelector, pod.labels).

AddressGroupAddress(addressGroup.uid, pod.status.podIP) :-
    // Pods must be selected from Namespaces matching nsSelector.
    addressGroup in AddressGroupDescr(.selector = GroupSelector{.nsSelector = NSSelectorLS{namespaceSelector}, .podSelector = podSelector}),
    namespace in k8s.Namespace(),
    k8s.labelSelectorMatches(Some{namespaceSelector}, namespace.labels),
    pod in k8s.Pod(.namespace = namespace.name),
    pod.status.podIP != "",
    is_none(podSelector) or k8s.labelSelectorMatches(podSelector, pod.labels).

// NetworkPolicyAddressGroup: stores all address groups that a network policy references;
// used to compute AddressGroupSpan.
relation NetworkPolicyAddressGroup(np: k8s.UID, addressGroup: string)

NetworkPolicyAddressGroup(np, addressGroup) :-
    NetworkPolicyDescr(.uid = np, .rules = rules),
    var addressGroups = {
        var addressGroups: Vec<string> = vec_empty();
        for (rule in rules) {
            vec_append(addressGroups, rule.from.addressGroups);
            vec_append(addressGroups, rule.to.addressGroups)
        };
        addressGroups
    },
    var addressGroup = FlatMap(addressGroups).

AddressGroupSpan(k8s.UID{addressGroup}, span) :-
    AddressGroupDescr(.uid = k8s.UID{addressGroup}),
    // Get all internal NetworkPolicy objects that refers this AddressGroupDescr.
    NetworkPolicyAddressGroup(np, addressGroup),
    NetworkPolicySpan(np, npSpan),
    var span = Aggregate((addressGroup), group_set_unions(npSpan)).

// Handle the case when the address group is not refered to by any NetworkPolicy
// objects.
AddressGroupSpan(k8s.UID{addressGroup}, set_empty()) :-
    AddressGroupDescr(.uid = k8s.UID{addressGroup}),
    not NetworkPolicyAddressGroup(.addressGroup = addressGroup).

// AppliedToGroupPod: pods that belong to a group along with nodes
// where the pod is scheduled;
// used to compute AppliedToGroupPodsByNode and AppliedToGroupSpan.
relation AppliedToGroupPod(appliedToGroup: k8s.UID, pod: k8s.PodReference, nodeName: string)

AppliedToGroupPod(appliedToGroup, k8s.PodReference{pod.name, pod.namespace}, pod.spec.nodeName) :-
    // TODO(leonid): Is it correct that we only consider selectors with namespace name set?
    AppliedToGroupDescr(.uid = appliedToGroup,
                        .selector = GroupSelector{.nsSelector = NSSelectorNS{namespace}, .podSelector = podSelector}),
    // Retrieve all Pods matching the podSelector.
    pod in k8s.Pod(.namespace = namespace),
    // No need to process Pod when it's not scheduled.
    pod.spec.nodeName != "",
    k8s.labelSelectorMatches(podSelector, pod.labels).

AppliedToGroupPodsByNode(appliedToGroup, podsByNode) :-
    AppliedToGroupPod(appliedToGroup, pod, nodeName),
    var podsOnNode = Aggregate((appliedToGroup, nodeName), group2set(pod)),
    var podsByNode = Aggregate((appliedToGroup), group2map((nodeName, podsOnNode))).

AppliedToGroupSpan(appliedToGroup, span) :-
    AppliedToGroupPod(appliedToGroup, _, nodeName),
    var span = Aggregate((appliedToGroup), group2set(nodeName)).

// Handle the case when there are no pods in the group.
AppliedToGroupSpan(uid, set_empty()),
AppliedToGroupPodsByNode(uid, map_empty()) :-
    AppliedToGroupDescr(.uid = uid),
    not AppliedToGroupPod(.appliedToGroup = uid).

NetworkPolicySpan(policy, span) :-
    NetworkPolicyDescr(.uid = policy, .appliedToGroups = appliedToGroups),
    var appliedToGroup = FlatMap(appliedToGroups),
    AppliedToGroupSpan(k8s.UID{appliedToGroup}, groupSpan),
    var span = Aggregate((policy), group_set_unions(groupSpan)).

// Handle the case when `apliedToGroups` is empty.
NetworkPolicySpan(policy, set_empty()) :-
    NetworkPolicyDescr(.uid = policy, .appliedToGroups = vec_empty()).
