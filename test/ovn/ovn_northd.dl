import OVN_Northbound as nb
import OVN_Southbound as sb
import ovsdb
import allocate
import ovn

/* Meter_Band table */
for (mb in nb.Meter_Band) {
    sb.Out_Meter_Band(.uuid_name = uuid2str(mb._uuid),
                      .action = mb.action,
                      .rate = mb.rate,
                      .burst_size = mb.burst_size)
}

/* Meter table */
for (meter in nb.Meter) {
    sb.Out_Meter(.name = meter.name,
                 .unit = meter.unit,
                 .bands = set_map_uuid2str(meter.bands))
}

/* Datapath_Binding table */
sb.Out_Datapath_Binding(uuid_str, 0, external_ids) :-
    nb.Logical_Switch(._uuid = uuid, .name = name, .external_ids = ids),
    var uuid_str = uuid2str(uuid),
    var external_ids = {
        var eids: Map<string, string> = map_empty();
        map_insert(eids, "logical-switch", uuid_str);
        map_insert(eids, "name", name);
        match (map_get(ids, "neutron:network_name")) {
            None -> (),
            Some{nnn} -> map_insert(eids, "name2", nnn)
        };
        eids
    }.

sb.Out_Datapath_Binding(uuid_str, 0, external_ids) :-
    nb.Logical_Router(._uuid = uuid, .name = name, .external_ids = ids),
    var uuid_str = uuid2str(uuid),
    var external_ids = {
        var eids: Map<string, string> = map_empty();
        map_insert(eids, "logical-router", uuid_str);
        map_insert(eids, "name", name);
        match (map_get(ids, "neutron:router_name")) {
            None -> (),
            Some{nnn} -> map_insert(eids, "name2", nnn)
        };
        eids
    }.

sb.OutProxy_Datapath_Binding(uuid_str, tunkey, external_ids) :-
    sb.Out_Datapath_Binding(uuid_str, _, external_ids),
    TunKeyAllocation(uuid_str, tunkey).



/* Port_Binding table

relation Out_Port_Binding (
    uuid_name: string,
    logical_port: string,
    __type: string,
    gateway_chassis: Set<string>,
    options: Map<string,string>,
    datapath: string,
    tunnel_key: integer,
    parent_port: Set<string>,
    tag: Set<integer>,
    chassis: Set<uuid>,
    mac: Set<string>,
    nat_addresses: Set<string>,
    external_ids: Map<string,string>
)
*/

/* map logical ports to logical switches */
relation LogicalPortSwitch(lport: uuid, lswitch: uuid)

LogicalPortSwitch(lport, lswitch) :-
    nb.Logical_Switch(._uuid = lswitch, .ports = ports),
    var lport = FlatMap(ports).

relation LogicalPortRouter(lport: uuid, lrouter: uuid)

LogicalPortRouter(lport, lrouter) :-
    nb.Logical_Router(._uuid = lrouter, .ports = ports),
    var lport = FlatMap(ports).


/* Case 1: Create a Port_Binding per logical switch port that is not of type "router" */
sb.Out_Port_Binding(.uuid_name          = uuid_name,
                    .logical_port       = lsp.name,
                    .__type             = lsp.__type,
                    .gateway_chassis    = set_empty(),
                    .options            = lsp.options,
                    .datapath           = uuid2str(lswitch_uuid),
                    .tunnel_key         = 0,
                    .parent_port        = lsp.parent_name,
                    .tag                = set_empty(),
                    .mac                = lsp.addresses,
                    .nat_addresses      = set_empty(),
                    .external_ids       = eids) :-
    nb.Logical_Switch_Port[lsp],
    lsp.__type != "router",
    var uuid_name = uuid2str(lsp._uuid),
    LogicalPortSwitch(lsp._uuid, lswitch_uuid),
    var eids = {
        var eids = lsp.external_ids;
        match (map_get(lsp.external_ids, "neutron:port_name")) {
            None -> (),
            Some{name} -> map_insert(eids, "name", name)
        };
        eids
    }.


/* Case 2: Create a Port_Binding per logical switch port of type "router" */
sb.Out_Port_Binding(.uuid_name          = uuid_name,
                    .logical_port       = lsp.name,
                    .__type             = __type,
                    .gateway_chassis    = set_empty(),
                    .options            = options,
                    .datapath           = uuid2str(lswitch_uuid),
                    .tunnel_key         = 0,
                    .parent_port        = lsp.parent_name,
                    .tag                = set_empty(),
                    .mac                = lsp.addresses,
                    .nat_addresses      = nat_addresses,
                    .external_ids       = eids) :-
    nb.Logical_Switch_Port[lsp],
    lsp.__type == "router",
    var uuid_name = uuid2str(lsp._uuid),
    LogicalPortSwitch(lsp._uuid, lswitch_uuid),
    var eids = {
        var eids = lsp.external_ids;
        match (map_get(lsp.external_ids, "neutron:port_name")) {
            None -> (),
            Some{name} -> map_insert(eids, "name", name)
        };
        eids
    },
    Some{var router_port} = map_get(lsp.options, "router-port"),
    nb.Logical_Router_Port(.name = router_port, ._uuid = lport_uuid),
    LogicalPortRouter(lport_uuid, lrouter_uuid),
    nb.Logical_Router(._uuid = lrouter_uuid, .options = lroptions),
    (var __type, var options, var nat_addresses) = {
        match (map_get(lroptions, "chassis")) {
            None -> {
                ("patch", map_empty(): Map<string, string>, set_empty(): Set<string>/*TODO*/)
            },
            Some{chassis} -> {
                var options: Map<string, string> = map_empty();
                map_insert(options, "peer", router_port);
                map_insert(options, "l3gateway-chassis", chassis);
                ("l3gateway", options, set_empty(): Set<string>/*TODO*/)
            }
        }
    }.

/* Case 3: Port_Binding per logical router port */
sb.Out_Port_Binding(.uuid_name          = uuid_name,
                    .logical_port       = lrp.name,
                    .__type             = __type,
                    .gateway_chassis    = set_empty(),
                    .options            = map_union(options1, options2),
                    .datapath           = uuid2str(lrouter_uuid),
                    .tunnel_key         = 0,
                    .parent_port        = set_empty(),
                    .tag                = set_empty(), // always empty for router ports
                    .mac                = set_singleton(set_space_sep(set_insert_imm(lrp.networks, lrp.mac))),
                    .nat_addresses      = set_empty(),
                    .external_ids       = lrp.external_ids) :-
    nb.Logical_Router_Port[lrp],
    var uuid_name = uuid2str(lrp._uuid),
    LogicalPortRouter(lrp._uuid, lrouter_uuid),
    nb.Logical_Router(._uuid = lrouter_uuid, .options = lroptions),
    (var __type, var options1) = match (map_get(lroptions, "chassis")) {
        /* TODO: derived ports */
        None -> ("patch", map_empty(): Map<string, string>),
        Some{lrchassis} -> ("l3gateway", map_singleton("l3gateway-chassis", lrchassis))
    },
    var options2 = match (map_get(lrp.options, "peer")) {
        None -> map_empty(): Map<string, string>,
        Some{peer} -> map_singleton("peer", peer)
    },
    var eids = {
        var eids = lrp.external_ids;
        match (map_get(lrp.external_ids, "neutron:port_name")) {
            None -> (),
            Some{name} -> map_insert(eids, "name", name)
        };
        eids
    }.

/*
 * Create derived port for Logical_Router_Ports with non-empty 'gateway_chassis' column.
 */

/* ChassisRedirectPort -- an intermediate table of router ports for which derived ports
   must be created in SB. */
relation ChassisRedirectPort(lrp: nb.Logical_Router_Port, lr_uuid: uuid)

ChassisRedirectPort(lrp1, lr._uuid) :-
    // For each router, find router ports with non-empty gateway_chassis or a "redirect-chassis" option.
    nb.Logical_Router[lr],
    LogicalPortRouter(lrp_uuid, lr._uuid),
    lrp in nb.Logical_Router_Port(._uuid = lrp_uuid),
        (not set_is_empty(lrp.gateway_chassis)) or map_contains_key(lrp.options, "redirect-chassis"),
    // if both gateway_chassis and options:redirect-chassis are present, log a warning and
    // ignore options:redirect-chassis.
    // (here we just log the warning; subsequent rules will ignore options:redirect-chassis)
    if ((not set_is_empty(lrp.gateway_chassis)) and map_contains_key(lrp.options, "redirect-chassis")) {
        warn($"logical router port ${lrp.name} has both options:" ++
              "redirect-chassis and gateway_chassis populated "   ++
              "redirect-chassis will be ignored in favour of gateway chassis");
        true
    } else { true },
    // It is an error if lrp.options:chassis exists.
    match (map_get(lrp.options, "chassis")) {
        Some{_} -> {
            warn("Bad configuration: redirect-chassis configured on port ${lrp.name} on L3 gateway router");
            false
        },
        _ -> true
    },
    // It is an error if a given Logical_Router has more than one such Logical_Router_Port.
    // If that happens, select an arbitrary one and log a warning.
    Aggregate((lr), lrps = group2set(lrp)),
    Some{var lrp1: nb.Logical_Router_Port} = match (set_size(lrps)) {
        0 -> None,
        1 -> set_nth(lrps,0),
        _ -> {
            warn($"Bad configuration: multiple ports with redirect-chassis on same logical router ${lr.name}");
            set_nth(lrps,0)
        }
    }.

/* Create derived ports */
sb.Out_Port_Binding(.uuid_name          = "cr" ++ uuid2str(lrp._uuid),
                    .logical_port       = lrp.name,
                    .__type             = "chassisredirect",
                    .gateway_chassis    = gateway_chassis,
                    .options            = map_singleton("distributed-port", "cr-" ++ lrp.name),
                    .datapath           = uuid2str(lr_uuid),
                    .tunnel_key         = 0,
                    .parent_port        = set_empty(),
                    .tag                = set_empty(),  //always empty for router ports
                    .mac                = set_singleton(set_space_sep(set_insert_imm(lrp.networks, lrp.mac))),
                    .nat_addresses      = set_empty(),
                    .external_ids       = lrp.external_ids) :-
    ChassisRedirectPort(lrp, lr_uuid),
    var gateway_chassis = if (not set_is_empty(lrp.gateway_chassis)) {
        set_map_uuid2str(lrp.gateway_chassis)
    } else {
        set_singleton(uuid2str(lr_uuid))
    }.

/* Create sb.Gateway_Chassis for derived ports.
 * - For derived ports with non-empty gateway_chassis, clone nb.Gateway_Chassis to
 *   sb.Gateway_Chassis, replacing chassis_name's with matching sb.Chassis uuid's.
 * - For derived ports with options:redirect-chassis, synthesize a fresh Gateway_Chassis
 */
sb.Out_Gateway_Chassis(.uuid_name       = uuid2str(gateway_chassis_uuid),
                       .name            = gw_chassis.name,
                       .chassis         = set_singleton(chassis_uuid),
                       .priority        = gw_chassis.priority,
                       .external_ids    = gw_chassis.external_ids,
                       .options         = gw_chassis.options) :-
    ChassisRedirectPort(lrp, lr_uuid),
    var gateway_chassis_uuid = FlatMap(lrp.gateway_chassis),
    gw_chassis in nb.Gateway_Chassis(._uuid = gateway_chassis_uuid),
    sb.Chassis(._uuid = chassis_uuid, .name = gw_chassis.chassis_name).

sb.Out_Gateway_Chassis(.uuid_name       = uuid2str(lr_uuid),
                       .name            = $"${lrp.name}_${redirect_chassis}",
                       .chassis         = set_singleton(chassis_uuid),
                       .priority        = 0,
                       .external_ids    = lrp.external_ids,
                       .options         = map_empty()) :-
    ChassisRedirectPort(lrp, lr_uuid),
    set_is_empty(lrp.gateway_chassis),
    Some{var redirect_chassis} = map_get(lrp.options, "redirect-chassis"),
    sb.Chassis(._uuid = chassis_uuid, .name = redirect_chassis).

/* Add allocated qdisc_queue_id and tunnel key to Port_Binding.
 */
sb.OutProxy_Port_Binding(.uuid_name          = pbinding.uuid_name,
                         .logical_port       = pbinding.logical_port,
                         .__type             = pbinding.__type,
                         .gateway_chassis    = pbinding.gateway_chassis,
                         .options            = options,
                         .datapath           = pbinding.datapath,
                         .tunnel_key         = tunkey,
                         .parent_port        = pbinding.parent_port,
                         .tag                = pbinding.tag,
                         .mac                = pbinding.mac,
                         .nat_addresses      = pbinding.nat_addresses,
                         .external_ids       = pbinding.external_ids) :-
    sb.Swizzled_Port_Binding[pbinding],
    PortTunKeyAllocation(pbinding.uuid_name, tunkey),
    QueueIDAllocation(pbinding.uuid_name, qid),
    var options = match (qid) {
        None -> pbinding.options,
        Some{id} -> map_insert_imm(pbinding.options, "qdisc_queue_id", $"${id}")
    }.

/*
 * SB_Global copy nb_cfg and options from NB
 */
for (nb_global in nb.NB_Global) {
    sb.Out_SB_Global(.nb_cfg         = nb_global.nb_cfg,
                     .external_ids   = nb_global.external_ids,
                     .connections    = nb_global.connections,
                     .ssl            = nb_global.ssl,
                     .options        = nb_global.options)
}

/*
 * Address_Set: copy from NB + additional records generated from NB Port_Group (two records for each
 * Port_Group for IPv4 and IPv6 addresses).
 *
 * There can be name collisions between the two types of Address_Set records.  User-defined records
 * take precedence.
 */
for (nb_as in nb.Address_Set) {
    sb.Out_Address_Set(.name      = nb_as.name,
                       .addresses = nb_as.addresses)
}

// TODO: link to C implementation
function is_dynamic_lsp_address(addr: string): bool = false
function split_addresses(addr: string): (Set<string>, Set<string>) = (set_empty(), set_empty())

/* PortStaticAddresses: static IP addresses associated with each Logical_Switch_Port */
relation PortStaticAddresses(lsport: uuid, ip4addrs: Set<string>, ip6addrs: Set<string>)

/* PortDynamicAddresses: dynamic IP addresses associated with each Logical_Switch_Port */
relation PortDynamicAddresses(lsport: uuid, ip4addrs: Set<string>, ip6addrs: Set<string>)

PortStaticAddresses(.lsport     = port_uuid,
                    .ip4addrs   = set_unions(ip4_addrs),
                    .ip6addrs   = set_unions(ip6_addrs)) :-
    nb.Logical_Switch_Port(._uuid = port_uuid, .addresses = addresses),
    var address = FlatMap(if set_is_empty(addresses) set_singleton("") else addresses),
    (var ip4addrs: Set<string>, var ip6addrs: Set<string>) = if (not is_dynamic_lsp_address(address)) {
        split_addresses(address)
    } else { (set_empty(), set_empty()) },
    Aggregate((port_uuid), static_addrs = group_unzip((ip4addrs, ip6addrs))),
    (var ip4_addrs, var ip6_addrs) = static_addrs.

PortDynamicAddresses(.lsport     = port_uuid,
                     .ip4addrs   = set_unions(ip4_addrs),
                     .ip6addrs   = set_unions(ip6_addrs)) :-
    nb.Logical_Switch_Port(._uuid = port_uuid, .dynamic_addresses = addresses),
    var address = FlatMap(if set_is_empty(addresses) set_singleton("") else addresses),
    (var ip4_addrs, var ip6_addrs) = split_addresses(address),
    Aggregate((port_uuid), dyn_addrs = group_unzip((ip4_addrs, ip6_addrs))),
    (var ip4_addrs, var ip6_addrs) = dyn_addrs.


sb.Out_Address_Set(as_name, set_unions(pg_ip4addrs)) :-
    nb.Port_Group(.ports = pg_ports, .name = pg_name),
    var as_name = pg_name ++ "_ip4",
    // avoid name collisions with user-defined Address_Sets
    not nb.Address_Set(.name = as_name),
    var port_uuid = FlatMap(pg_ports),
    PortStaticAddresses(.lsport = port_uuid, .ip4addrs = stat),
    PortDynamicAddresses(.lsport = port_uuid, .ip4addrs = dynamic),
    var port_ip4addrs: Set<string> = set_union(stat, dynamic),
    Aggregate((as_name), pg_ip4addrs = group2vec(port_ip4addrs)).

sb.Out_Address_Set(as_name, set_empty()) :-
    nb.Port_Group(.ports = set_empty(), .name = pg_name),
    var as_name = pg_name ++ "_ip4",
    // avoid name collisions with user-defined Address_Sets
    not nb.Address_Set(.name = as_name).

sb.Out_Address_Set(as_name, set_unions(pg_ip6addrs)) :-
    nb.Port_Group(.ports = pg_ports, .name = pg_name),
    var as_name = pg_name ++ "_ip6",
    // avoid name collisions with user-defined Address_Sets
    not nb.Address_Set(.name = as_name),
    var port_uuid = FlatMap(pg_ports),
    PortStaticAddresses(.lsport = port_uuid, .ip6addrs = stat),
    PortDynamicAddresses(.lsport = port_uuid, .ip6addrs = dynamic),
    var port_ip6addrs = set_union(stat, dynamic),
    Aggregate((as_name), pg_ip6addrs = group2vec(port_ip6addrs)).

sb.Out_Address_Set(as_name, set_empty()) :-
    nb.Port_Group(.ports = set_empty(), .name = pg_name),
    var as_name = pg_name ++ "_ip6",
    // avoid name collisions with user-defined Address_Sets
    not nb.Address_Set(.name = as_name).


/*
 * Port_Group: copy from NB, but replace UUIDs with logical port names
 */
sb.Out_Port_Group(.name = pg_name, .ports = port_names) :-
    nb.Port_Group(.name = pg_name, .ports = pg_ports),
    var port_uuid = FlatMap(pg_ports),
    nb.Logical_Switch_Port(._uuid = port_uuid, .name = port_name),
    Aggregate((pg_name), port_names = group2set(port_name)).

sb.Out_Port_Group(.name = pg_name, .ports = set_empty()) :-
    nb.Port_Group(.name = pg_name, .ports = set_empty()).


/*
 * Multicast_Group: two rows per logical switch, one for flooding and one for packets with unknown
 * destinations.
 */

// TODO: check that Multicast_Group.ports should not include derived ports
sb.Out_Multicast_Group (.datapath   = datapath,
                        .name       = "_MC_flood",
                        .tunnel_key = 65535,
                        .ports      = ports),
sb.Out_Multicast_Group (.datapath   = datapath,
                        .name       = "_MC_unknown",
                        .tunnel_key = 65534,
                        .ports      = ports) :-
    nb.Logical_Switch[ls],
    var datapath = uuid2str(ls._uuid),
    var ports = set_map_uuid2str(ls.ports).

/*
 * MAC binding: records inserted by hypervisors; northd removes records for deleted logical ports
 */
sb.Out_MAC_Binding (.logical_port =   mb.logical_port,
                    .ip           =   mb.ip,
                    .mac          =   mb.mac,
                    .datapath     =   datapath_name) :-
    sb.MAC_Binding[mb],
    sb.UUIDMap_Datapath_Binding(datapath_name, Left{mb.datapath}).


/*
 * DHCP options: fixed table
 */
sb.Out_DHCP_Options (
    .name   = "offerip",
    .code   = 0,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "netmask",
    .code   = 1,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "router",
    .code   = 3,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "dns_server",
    .code   = 6,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "log_server",
    .code   = 7,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "lpr_server",
    .code   = 9,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "swap_server",
    .code   = 16,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "policy_filter",
    .code   = 21,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "router_solicitation",
    .code   = 32,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "nis_server",
    .code   = 41,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "ntp_server",
    .code   = 42,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "server_id",
    .code   = 54,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "tftp_server",
    .code   = 66,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "classless_static_route",
    .code   = 121,
    .__type = "static_routes"
).

sb.Out_DHCP_Options (
    .name   = "ms_classless_static_route",
    .code   = 249,
    .__type = "static_routes"
).

sb.Out_DHCP_Options (
    .name   = "ip_forward_enable",
    .code   = 19,
    .__type = "bool"
).

sb.Out_DHCP_Options (
    .name   = "router_discovery",
    .code   = 31,
    .__type = "bool"
).

sb.Out_DHCP_Options (
    .name   = "ethernet_encap",
    .code   = 36,
    .__type = "bool"
).

sb.Out_DHCP_Options (
    .name   = "default_ttl",
    .code   = 23,
    .__type = "uint8"
).

sb.Out_DHCP_Options (
    .name   = "tcp_ttl",
    .code   = 37,
    .__type = "uint8"
).

sb.Out_DHCP_Options (
    .name   = "mtu",
    .code   = 26,
    .__type = "uint16"
).

sb.Out_DHCP_Options (
    .name   = "lease_time",
    .code   = 51,
    .__type = "uint32"
).

sb.Out_DHCP_Options (
    .name   = "T1",
    .code   = 58,
    .__type = "uint32"
).

sb.Out_DHCP_Options (
    .name   = "T2",
    .code   = 59,
    .__type = "uint32"
).

sb.Out_DHCP_Options (
    .name   = "wpad",
    .code   = 252,
    .__type = "str"
).


/*
 * DHCPv6 options: fixed table
 */
sb.Out_DHCPv6_Options (
    .name   = "server_id",
    .code   = 2,
    .__type = "mac"
).

sb.Out_DHCPv6_Options (
    .name   = "ia_addr",
    .code   = 5,
    .__type = "ipv6"
).

sb.Out_DHCPv6_Options (
    .name   = "dns_server",
    .code   = 23,
    .__type = "ipv6"
).

sb.Out_DHCPv6_Options (
    .name   = "domain_search",
    .code   = 24,
    .__type = "str"
).


/*
 * DNS: copied from NB + datapaths column pointer to LS datapaths that use the record
 */

relation LogicalSwitchDNS(ls_uuid: uuid, dns_uuid: uuid)

/* Flatten the list of dns_records in Logical_Switch */
LogicalSwitchDNS(ls._uuid, dns_uuid) :-
    nb.Logical_Switch[ls],
    var dns_uuid = FlatMap(ls.dns_records).

sb.Out_DNS(.records      = nbdns.records,
           .datapaths    = datapaths,
           .external_ids = nbdns.external_ids) :-
    nb.DNS[nbdns],
    LogicalSwitchDNS(ls_uuid, nbdns._uuid),
    Aggregate((nbdns), datapaths = group2set(uuid2str(ls_uuid))).

sb.Out_DNS(.records      = nbdns.records,
           .datapaths    = set_empty(),
           .external_ids = nbdns.external_ids) :-
    nb.DNS[nbdns],
    not LogicalSwitchDNS(_, nbdns._uuid).

/*
 * RBAC_Permission: fixed
 */

sb.Out_RBAC_Permission (
    .uuid_name      = "7df3749a-1754-4a78-afa4-3abf526fe510",
    .table          = "Chassis",
    .authorization  = set_singleton("name"),
    .insert_delete  = true,
    .update         = {
            var s: Set<string> = set_empty();
            set_insert(s, "nb_cfg");
            set_insert(s, "external_ids");
            set_insert(s, "encaps");
            set_insert(s, "vtep_logical_switches");
            s
        }
).

sb.Out_RBAC_Permission (
    .uuid_name      = "94bec860-431e-4d95-82e7-3b75d8997241",
    .table          = "Encap",
    .authorization  = set_singleton("chassis_name"),
    .insert_delete  = true,
    .update         = {
            var s: Set<string> = set_empty();
            set_insert(s, "type");
            set_insert(s, "options");
            set_insert(s, "ip");
            s
        }
).

sb.Out_RBAC_Permission (
    .uuid_name      = "d8ceff1a-2b11-48bd-802f-4a991aa4e908",
    .table          = "Port_Binding",
    .authorization  = set_singleton(""),
    .insert_delete  = false,
    .update         = set_singleton("chassis")
).

sb.Out_RBAC_Permission (
    .uuid_name      = "6ffdc696-8bfb-4d82-b620-a00d39270b2f",
    .table          = "MAC_Binding",
    .authorization  = set_singleton(""),
    .insert_delete  = true,
    .update         = {
            var s: Set<string> = set_empty();
            set_insert(s, "logical_port");
            set_insert(s, "ip");
            set_insert(s, "mac");
            set_insert(s, "datapath");
            s
        }
).

/*
 * RBAC_Role: fixed
 */
sb.Out_RBAC_Role (
    .name        = "ovn-controller",
    .permissions = {
            var m: Map<string, string> = map_empty();
            map_insert(m, "Chassis"     , "7df3749a-1754-4a78-afa4-3abf526fe510");
            map_insert(m, "Encap"       , "94bec860-431e-4d95-82e7-3b75d8997241");
            map_insert(m, "Port_Binding", "d8ceff1a-2b11-48bd-802f-4a991aa4e908");
            map_insert(m, "MAC_Binding" , "6ffdc696-8bfb-4d82-b620-a00d39270b2f");
            m
        }
).

typedef Direction = IN | OUT

typedef PipelineStage = PORT_SEC_L2
                      | PORT_SEC_IP
                      | PORT_SEC_ND
                      | PRE_ACL
                      | PRE_LB
                      | PRE_STATEFUL
                      | ACL
                      | QOS_MARK
                      | QOS_METER
                      | LB
                      | STATEFUL
                      | ARP_ND_RSP
                      | DHCP_OPTIONS
                      | DHCP_RESPONSE
                      | DNS_LOOKUP
                      | DNS_RESPONSE
                      | L2_LKUP
                      | ADMISSION
                      | IP_INPUT
                      | DEFRAG
                      | UNSNAT
                      | DNAT
                      | ND_RA_OPTIONS
                      | ND_RA_RESPONSE
                      | IP_ROUTING
                      | ARP_RESOLVE
                      | GW_REDIRECT
                      | ARP_REQUEST
                      | UNDNAT
                      | SNAT
                      | EGR_LOOP
                      | DELIVERY

function switch_stage(direction: Direction, stage: PipelineStage): integer =
{
    match ((direction, stage)) {
        (IN,  PORT_SEC_L2)   -> 0,
        (IN,  PORT_SEC_IP)   -> 1,
        (IN,  PORT_SEC_ND)   -> 2,
        (IN,  PRE_ACL)       -> 3,
        (IN,  PRE_LB)        -> 4,
        (IN,  PRE_STATEFUL)  -> 5,
        (IN,  ACL)           -> 6,
        (IN,  QOS_MARK)      -> 7,
        (IN,  QOS_METER)     -> 8,
        (IN,  LB)            -> 9,
        (IN,  STATEFUL)      -> 10,
        (IN,  ARP_ND_RSP)    -> 11,
        (IN,  DHCP_OPTIONS)  -> 12,
        (IN,  DHCP_RESPONSE) -> 13,
        (IN,  DNS_LOOKUP)    -> 14,
        (IN,  DNS_RESPONSE)  -> 15,
        (IN,  L2_LKUP)       -> 16,
        (OUT, PRE_LB)        -> 0,
        (OUT, PRE_ACL)       -> 1,
        (OUT, PRE_STATEFUL)  -> 2,
        (OUT, LB)            -> 3,
        (OUT, ACL)           -> 4,
        (OUT, QOS_MARK)      -> 5,
        (OUT, QOS_METER)     -> 6,
        (OUT, STATEFUL)      -> 7,
        (OUT, PORT_SEC_IP)   -> 8,
        (OUT, PORT_SEC_L2)   -> 9,
        _                    -> 64'hffffffffffffffff /* alternatively crash? */
    }
}

function router_stage(direction: Direction, stage: PipelineStage): integer =
{
    match ((direction, stage)) {
        (IN,  ADMISSION)     -> 0,
        (IN,  IP_INPUT)      -> 1,
        (IN,  DEFRAG)        -> 2,
        (IN,  UNSNAT)        -> 3,
        (IN,  DNAT)          -> 4,
        (IN,  ND_RA_OPTIONS) -> 5,
        (IN,  ND_RA_RESPONSE)-> 6,
        (IN,  IP_ROUTING)    -> 7,
        (IN,  ARP_RESOLVE)   -> 8,
        (IN,  GW_REDIRECT)   -> 9,
        (IN,  ARP_REQUEST)   -> 10,
        (OUT, UNDNAT)        -> 0,
        (OUT, SNAT)          -> 1,
        (OUT, EGR_LOOP)      -> 2,
        (OUT, DELIVERY)      -> 3,
        _                    -> 64'hffffffffffffffff /* alternatively crash? */
    }
}

/*
 * Logical_Flow
   relation Out_Logical_Flow (
        logical_datapath: string,
        pipeline: string,
        table_id: integer,
        priority: integer,
        __match: string,
        actions: string,
        external_ids: Map<string,string>)
 */



/* Logical switch ingress table 0: admission control framework (priority 100) */
for (ls in nb.Logical_Switch) {
    var lsname = uuid2str(ls._uuid) in {
        /* Logical VLANs not supported */
        sb.Out_Logical_Flow(.logical_datapath = lsname,
                            .pipeline         = "ingress",
                            .table_id         = switch_stage(IN, PORT_SEC_L2),
                            .priority         = 100,
                            .__match          = "vlan.present",
                            .actions          = "drop;",
                            .external_ids     = map_empty() /*TODO: check*/);

        /* Broadcast/multicast source address is invalid */
        sb.Out_Logical_Flow(.logical_datapath = lsname,
                            .pipeline         = "ingress",
                            .table_id         = switch_stage(IN, PORT_SEC_L2),
                            .priority         = 100,
                            .__match          = "eth.src[40]",
                            .actions          = "drop;",
                            .external_ids     = map_empty() /*TODO: check*/)
    }
    /* Port security flows have priority 50 (see below) and will continue to the next table
       if packet source is acceptable. */
}

/* Logical port is enabled if it does not have an enabled flag or the flag is true */
function is_enabled(s: Set<bool>): bool = {
    set_nth(s, 0) != Some{false}
}

/* extract Ethernet addresses only */
function port_security_eth_addresses(ps: Set<string>): Set<string> = {
    // TODO: write proper implementation
    ps
}

// space-separated vector of strings
function vec_space_sep(items: Vec<string>): string = {
    string_join(items, " ")
}

// space-separated set of strings
function set_space_sep(items: Set<string>): string = {
    vec_space_sep(set2vec(items))
}

/* Logical switch ingress table 0: ingress port security - L2 (priority 50)
                  ingress table 1: ingress port security - IP (priority 90 and 80)
                  ingress table 2: ingress port security - ND (priority 90 and 80) */

/* Logical VLANs not supported */
for (lsp in nb.Logical_Switch_Port if is_enabled(lsp.enabled)) {
    for (lps in LogicalPortSwitch(.lport = lsp._uuid)) {
        var lsname = uuid2str(lps.lswitch) in
        var __match = if (set_is_empty(lsp.port_security)) {
                $"inport == ${lsp.name}"
            } else {
                $"inport == ${lsp.name} && eth.src == {${set_space_sep(port_security_eth_addresses(lsp.port_security))}}"
            } in
        var actions = match (map_get(pbinding.options, "qdisc_queue_id")) {
                None -> "next;",
                Some{id} -> $"set_queue(${id}); next;"
            } in
        for (pbinding in sb.OutProxy_Port_Binding(.logical_port = lsp.name)) {
            sb.Out_Logical_Flow(
                .logical_datapath = lsname,
                .pipeline         = "ingress",
                .table_id         = switch_stage(IN, PORT_SEC_L2),
                .priority         = 50,
                .__match          = __match,
                .actions          = actions,
                .external_ids     = map_empty())
        }
    }
}

/*
 * Datapath tunnel key allocation:
 *
 * Allocates a globally unique tunnel id in the range 1...2**24-1 for
 * each Logical_Switch and Logical_Router.
 */

// all tunnel keys already in use in the Realized table
relation AllocatedTunKeys(keys: Set<integer>)

AllocatedTunKeys(keys) :-
    sb.Datapath_Binding(.tunnel_key = tunkey),
    Aggregate((), keys = group2set(tunkey)).

// Datapath_Binding's not yet in the Realized table
relation NotYetAllocatedTunKeys(datapaths: Vec<string>)

NotYetAllocatedTunKeys(datapaths) :-
    sb.UUIDMap_Datapath_Binding(.uuid_name = datapath,
                                .id = Right{_}),
    datapath != "",
    Aggregate((), datapaths = group2vec(datapath)).

// Perform the allocation
relation TunKeyAllocation(datapath: string, tunkey: integer)

// transfer existing allocations from the realized table
TunKeyAllocation(datapath, tunkey) :-
     sb.UUIDMap_Datapath_Binding(.uuid_name = datapath,
                                 .id = Left{uuid}),
     sb.Datapath_Binding(._uuid = uuid,
                         .tunnel_key = tunkey).

// Case 1: AllocatedTunKeys relation is not empty (i.e., contains
// a single record that stores a set of allocated keys)
TunKeyAllocation(datapath, tunkey) :-
    NotYetAllocatedTunKeys(unallocated),
    AllocatedTunKeys(allocated),
    var allocation = FlatMap(allocate_u64(allocated, unallocated, 64'hfffffffff)),
    (var datapath, var tunkey) = allocation.

// Case 2: AllocatedTunKeys relation is empty
TunKeyAllocation(datapath, tunkey) :-
    NotYetAllocatedTunKeys(unallocated),
    not AllocatedTunKeys(_),
    var allocation = FlatMap(allocate_u64(set_empty(), unallocated, 64'hfffffffff)),
    (var datapath, var tunkey) = allocation.

/*
 * Port id allocation:
 *
 * Port IDs in a per-datapath space in the range 1...2**15-1
 */

// all tunnel keys already in use in the Realized table
relation AllocatedPortTunKeys(datapath: string, keys: Set<integer>)

AllocatedPortTunKeys(datapath_name, keys) :-
    sb.Port_Binding(.datapath = datapath_uuid, .tunnel_key = tunkey),
    sb.UUIDMap_Datapath_Binding(datapath_name, Left{datapath_uuid}),
    Aggregate((datapath_name), keys = group2set(tunkey)).

// Port_Binding's not yet in the Realized table
relation NotYetAllocatedPortTunKeys(datapath: string, all_logical_ids: Vec<string>)

NotYetAllocatedPortTunKeys(datapath, all_names) :-
    sb.Out_Port_Binding(.uuid_name = uuid_name, .datapath = datapath),
    sb.UUIDMap_Port_Binding(.uuid_name = uuid_name,
                            .id = Right{_}),
    Aggregate((datapath), all_names = group2vec(uuid_name)).

// Perform the allocation
relation PortTunKeyAllocation(port: string, tunkey: integer)

// transfer existing allocations from the realized table
PortTunKeyAllocation(port, tunkey) :-
     sb.UUIDMap_Port_Binding(.uuid_name = port,
                             .id = Left{uuid}),
     sb.Port_Binding(._uuid = uuid,
                     .tunnel_key = tunkey).

// Case 1: AllocatedPortTunKeys(datapath) is not empty (i.e., contains
// a single record that stores a set of allocated keys)
PortTunKeyAllocation(port, tunkey) :-
    AllocatedPortTunKeys(datapath, allocated),
    NotYetAllocatedPortTunKeys(datapath, unallocated),
    var allocation = FlatMap(allocate_u64(allocated, unallocated, 64'hffff)),
    (var port, var tunkey) = allocation.

// Case 2: PortAllocatedTunKeys(datapath) relation is empty
PortTunKeyAllocation(port, tunkey) :-
    NotYetAllocatedPortTunKeys(datapath, unallocated),
    not AllocatedPortTunKeys(datapath, _),
    var allocation = FlatMap(allocate_u64(set_empty(), unallocated, 64'hffff)),
    (var port, var tunkey) = allocation.

/*
 * Queue ID allocation
 *
 * Queue IDs on a chassis, for routers that have QoS enabled, in a per-chassis
 * space in the range 1...0xf000.  It looks to me like there'd only be a small
 * number of these per chassis, and probably a small number overall, in case it
 * matters.
 *
 * Queue ID may also need to be deallocated if port loses QoS attributes
 *
 * This logic only applies to ports with chassis attribute, i.e., they must be
 * in sb.Port_Binding.
 */

function port_has_qos_params(opts: Map<string, string>): bool = {
    map_contains_key(opts, "qos_max_rate") or
    map_contains_key(opts, "qos_burst")
}


// ports in Out_Port_Binding that require queue ID on chassis
relation PortRequiresQID(port: string, chassis: uuid)

PortRequiresQID(pb.uuid_name, chassis) :-
    sb.Out_Port_Binding[pb],
    port_has_qos_params(pb.options),
    sb.UUIDMap_Port_Binding(pb.uuid_name, Left{uuid}),
    sb.Port_Binding(._uuid = uuid, .chassis = chassis_set),
    Some{var chassis} = set_nth(chassis_set, 0).

relation AggPortRequiresQID(chassis: uuid, ports: Vec<string>)

AggPortRequiresQID(chassis, ports) :-
    PortRequiresQID(port, chassis),
    Aggregate((chassis), ports = group2vec(port)).

relation AllocatedQIDs(chassis: uuid, allocated_ids: Map<string, integer>)

AllocatedQIDs(chassis, allocated_ids) :-
    sb.Port_Binding[pb],
    Some{var chassis} = set_nth(pb.chassis, 0),
    Some{var qid_str} = map_get(pb.options, "qdisc_queue_id"),
    Some{var qid: bit<64>} = parse_dec_u64(qid_str),
    sb.UUIDMap_Port_Binding(port, Left{pb._uuid}),
    Aggregate((chassis), allocated_ids = group2map((port, qid))).

// allocate queueue IDs to ports
relation QueueIDAllocation(port: string, qids: Option<integer>)

// None for ports that do not require a queue
QueueIDAllocation(port, None) :-
    sb.Out_Port_Binding(.uuid_name = port),
    not PortRequiresQID(port, _).

QueueIDAllocation(port, Some{qid}) :-
    AggPortRequiresQID(chassis, ports),
    AllocatedQIDs(chassis, allocated_ids),
    var allocations = FlatMap(adjust_allocation_u64(allocated_ids, ports, 64'hf000)),
    (var port, var qid) = allocations.

QueueIDAllocation(port, Some{qid}) :-
    AggPortRequiresQID(chassis, ports),
    not AllocatedQIDs(chassis, _),
    var allocations = FlatMap(adjust_allocation_u64(map_empty(): Map<string, integer>, ports, 64'hf000)),
    (var port, var qid) = allocations.
