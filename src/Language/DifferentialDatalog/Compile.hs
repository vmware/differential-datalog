{-
Copyright (c) 2018 VMware, Inc.
SPDX-License-Identifier: MIT

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-}

{-# LANGUAGE RecordWildCards, FlexibleContexts, LambdaCase, TupleSections, OverloadedStrings #-}

{- | 
Module     : Compile
Description: Compile 'DatalogProgram' to Rust.  See program.rs for corresponding Rust declarations.
-}

module Language.DifferentialDatalog.Compile (
    compile
) where

-- TODO: 
-- Generate functions
-- ??? Generate callback function prototypes, but don't overwrite existing implementations.

import Control.Monad.State
import Text.PrettyPrint
import Data.Tuple
import Data.Maybe
import Data.List
import Data.Int
import Data.Word
import qualified Data.Set as S
import qualified Data.Map as M
import qualified Data.Graph.Inductive as G
import qualified Data.Graph.Inductive.Query.DFS as G

import Language.DifferentialDatalog.PP
import Language.DifferentialDatalog.Name
import Language.DifferentialDatalog.Syntax
import Language.DifferentialDatalog.NS
import Language.DifferentialDatalog.Expr
import Language.DifferentialDatalog.DatalogProgram

-- TODO: generate code to fill relations with initial values
-- (corresponding to rules with empty bodies)

{- The following types model corresponding entities in program.rs -}

data Arrangement = Arrangement {
    arngKey   :: Expr,
    arngValue :: Expr
}

-- Relation is a function that takes a list of arrangements and produces a Doc containing Rust 
-- code for the relation (since we won't know all required arrangements till we finish scanning 
-- the program)
type ProgRel = (String, [Doc] -> Doc)

data ProgNode = SCCNode [ProgRel]
              | RelNode ProgRel

{- State accumulated by the compiler as it traverses the program -}
type CompilerMonad = State CompilerState

type RelId = Int

data CompilerState = CompilerState {
    cTypes        :: S.Set Type,
    cRels         :: M.Map String RelId,
    cArrangements :: M.Map String (M.Map Arrangement Int)
}

emptyCompilerState :: CompilerState
emptyCompilerState = CompilerState {
    cTypes        = S.empty,
    cRels         = M.empty,
    cArrangements = M.empty
}

getRelId :: String -> CompilerMonad RelId
getRelId rname = gets $ (M.! rname) . cRels

-- | Compile Datalog program into Rust code that creates 'struct Program' representing 
-- the program for the Rust Datalog library
compile :: DatalogProgram -> Doc
compile d =  valtype $+$ prog
    where
    -- Transform away rules with multiple heads
    d' = progExpandMultiheadRules d
    -- Compute ordered SCCs of the dependency graph.  These will define the
    -- structure of the program.
    depgraph = progDependencyGraph d'
    sccs = G.topsort' $ G.condensation depgraph
    -- Assign RelId's
    relids = M.fromList $ map swap $ G.labNodes depgraph
    -- Compile SCCs
    (nodes, cstate) = runState (mapM (compileSCC d' depgraph) sccs) 
                               $ emptyCompilerState{cRels = relids}
    -- Assemble results
    valtype = mkValType $ cTypes cstate
    prog = mkProg (cArrangements cstate) nodes
    
-- Generate Value type
mkValType :: S.Set Type -> Doc
mkValType types = undefined

-- Generate Rust struct for ProgNode
compileSCC :: DatalogProgram -> DepGraph -> [G.Node] -> CompilerMonad ProgNode
compileSCC d dep nodes | recursive = compileRelNode d (head relnames)
                       | otherwise = compileSCCNode d relnames
    where
    recursive = any (\(from, to) -> elem from nodes && elem to nodes) $ G.edges dep
    relnames = map (fromJust . G.lab dep) nodes

compileRelNode :: DatalogProgram -> String -> CompilerMonad ProgNode
compileRelNode d relname = do
    rel <- compileRelation d relname
    return $ RelNode rel

compileSCCNode :: DatalogProgram -> [String] -> CompilerMonad ProgNode
compileSCCNode d relnames = do
    rels <- mapM (compileRelation d) relnames
    return $ SCCNode rels

{- Generate Rust representation of relation and associated rules.

//Example code generated by this function: 
let ancestorset: Arc<Mutex<ValSet<Value>>> = Arc::new(Mutex::new(FnvHashSet::default()));
let ancestor = {
    let ancestorset = ancestorset.clone();
    Relation {
        name:         "ancestor".to_string(),
        input:        false,
        id:           2,      
        rules:        vec![
            Rule{
                rel: 1, 
                xforms: vec![]
            },
            Rule{
                rel: 2, 
                xforms: vec![XForm::Join{
                    afun:        &(arrange_by_snd as ArrangeFunc<Value>),
                    arrangement: (1,0),
                    jfun:        &(jfun as JoinFunc<Value>)
                }]
            }],
        arrangements: vec![
            Arrangement{
                name: "arrange_by_ancestor".to_string(),
                afun: &(arrange_by_fst as ArrangeFunc<Value>)
            },
            Arrangement{
                name: "arrange_by_self".to_string(),
                afun: &(arrange_by_self as ArrangeFunc<Value>)
            }],
        change_cb:    Arc::new(move |v,pol| set_update("ancestor", &ancestorset, v, pol))
    }
};
-}
compileRelation :: DatalogProgram -> String -> CompilerMonad ProgRel
compileRelation d rname = do
    let Relation{..} = getRelation d rname
    relid <- getRelId rname
    -- collect all rules for this relation
    let rules = filter (not . null . ruleRHS)
                $ filter ((== rname) . atomRelation . head . ruleLHS) 
                $ progRules d
    rules' <- mapM (compileRule d) rules
    let f arrangements =
            "Relation {"                                                                $$
            "    name:         \"" <> pp rname <> "\".to_string(),"                     $$
            "    input:        " <> (if relGround then "true" else "false") <> ","      $$
            "    id:           " <> pp relid <> ","                                     $$
            "    rules:        vec!["                                                   $$
            (nest' $ nest' $ vcat $ punctuate comma rules') <> "],"                     $$
            "    arrangements: vec!["                                                   $$
            (nest' $ nest' $ vcat $ punctuate comma arrangements) <> "],"               $$
            "    change_cb:    Arc::new(move |v,pol| )"                                 $$
            "}"
    return (rname, f)

{- Generate Rust representation of a Datalog rule

// Example Rust code generated by this function
Rule{
    rel: 2, 
    xforms: vec![XForm::Join{
        afun:        &(arrange_by_snd as ArrangeFunc<Value>),
        arrangement: (1,0),
        jfun:        &(jfun as JoinFunc<Value>)
    }]
}
-}
compileRule :: DatalogProgram -> Rule -> CompilerMonad Doc
compileRule d rl@Rule{..} = do
    fstrelid <- getRelId $ atomRelation $ rhsAtom $ head ruleRHS
    xforms <- compileRule' d rl 0
    return $ "Rule{"                                            $$
             "    rel: " <> pp fstrelid <> ","                  $$ 
             "    xforms: vec!["                                $$ 
             (nest' $ nest' $ vcat $ punctuate comma xforms)    $$
             "}"

-- Generates one XForm in the chain
compileRule' :: DatalogProgram -> Rule -> Int -> CompilerMonad [Doc]
compileRule' d rl@Rule{..} last_rhs_idx = do
    -- Open up input constructor; bring Datalog variables into scope
    let open = if last_rhs_idx == 0
                  then openAtom d $ rhsAtom $ head ruleRHS
                  else openTuple $ rhsVarsAfter d rl last_rhs_idx
    -- Apply filters and assignments between last_rhs_idx and the next
    -- join or antijoin
    let filters = map (mkFilter . rhsExpr)
                  $ takeWhile (\case
                              RHSCondition{} -> True
                              _              -> False)
                  $ drop last_rhs_idx ruleRHS
    let prefix = open $+$ vcat filters
    -- index of the next join
    let join_idx = last_rhs_idx + length filters + 1
    if join_idx == length ruleRHS
       then do 
           head <- mkHead d prefix rl
           return [head]
       else do 
           (xform, last_idx') <- 
               case ruleRHS !! join_idx of
                    RHSLiteral True a  -> mkJoin d prefix a rl join_idx
                    RHSLiteral False a -> (, join_idx) <$> mkAntijoin d prefix a rl join_idx
           rest <- compileRule' d rl last_idx'
           return $ xform:rest

-- Generate Rust code to filter records and bring variables into scope.
-- The Rust code returns None if the record does not pass the filter.
--
-- let (v1,v2) /*v1,v2 are references*/ = match &v {
--     Value::Rel1(v1,v2) => (v1,v2),
--     _ => return None
-- };
openAtom :: DatalogProgram -> Atom -> Doc
openAtom d Atom{..} = 
    "let " <> vars <> " = match &v {"                                                            $$
    "    Value::" <> constructor <> "(" <> pattern <> " )" <+> cond_str <+> "=> " <> vars <> "," $$
    "    _ => return None"                                                                       $$
    "};"
    where
    rel = getRelation d atomRelation
    constructor = mkConstructorName d $ relType rel
    varnames = map pp $ exprVars atomVal
    vars = parens $ hsep $ punctuate comma varnames
    (pattern, cond) = mkPatExpr d atomVal
    cond_str = if cond == empty then empty else ("if" <+> cond)

-- Generate Rust constructor name for a type
mkConstructorName :: DatalogProgram -> Type -> Doc
mkConstructorName = undefined

-- Generate Rust code to open up tuples and bring variables into scope.
-- The Rust code returns None if the record does not pass the filter.
openTuple :: [Field] -> Doc
openTuple = undefined

-- Implement RHSCondition semantics in Rust; brings new variables into
-- scope if this is an assignment
mkFilter :: Expr -> Doc
mkFilter = undefined

-- Compile XForm::Join
-- Returns generated xform and index of the last RHS term consumed by
-- the XForm
mkJoin :: DatalogProgram -> Doc -> Atom -> Rule -> Int -> CompilerMonad (Doc, Int)
mkJoin d prefix Atom{..} rl@Rule{..} join_idx = undefined

-- Compile XForm::Antijoin
mkAntijoin :: DatalogProgram -> Doc -> Atom -> Rule -> Int -> CompilerMonad Doc
mkAntijoin d prefix Atom{..} rl@Rule{..} ajoin_idx = undefined

-- Compile XForm::FilterMap that generates the head of the rule
mkHead :: DatalogProgram -> Doc -> Rule -> CompilerMonad Doc
mkHead d prefix rl = undefined

-- Variables in the RHS of the rule visible after i'th term.
rhsVarsAfter :: DatalogProgram -> Rule -> Int -> [Field]
rhsVarsAfter = undefined

mkProg :: M.Map String (M.Map Arrangement Int) -> [ProgNode] -> Doc
mkProg = undefined

-- Compile Datalog pattern expression to Rust.
-- The first element in the return tuple is a Rust match pattern, the second
-- element is a (possibly empty condition attached to the pattern),
-- e.g., the Datalog pattern
-- 'Constructor{f1= x, f2= "foo"}' compiles into
-- '(TypeName::Constructor{f1: x, f2=_0}, *_0 == "foo".to_string())'
-- where '_0' is an auxiliary variable of type 'String'
mkPatExpr :: DatalogProgram -> Expr -> (Doc, Doc)
mkPatExpr d e = evalState (exprFoldM (mkPatExpr' d) e) 0

mkPatExpr' :: DatalogProgram -> ExprNode (Doc, Doc) -> State Int (Doc, Doc)
mkPatExpr' _ EVar{..}                  = return (pp exprVar, empty)
mkPatExpr' _ (EBool _ True)            = return ("true", empty)
mkPatExpr' _ (EBool _ False)           = return ("false", empty)
mkPatExpr' _ EInt{..}                  = do 
    i <- get
    put $ i+1
    let vname = pp $ "_" <> pp i
    let val = case exprIVal of
                   v | v <= (toInteger (maxBound::Word64)) && v >= (toInteger (minBound::Word64))
                     -> "Int::from_u64(" <> pp v <> ")"
                   v | v <= (toInteger (maxBound::Int64))  && v >= (toInteger (minBound::Int64))
                     -> "Int::from_i64(" <> pp v <> ")"
                   v -> "Int::parse_bytes(b\"" <> pp v <> "\", 10)"
    return (vname, "*" <> vname <+> "==" <+> val)
mkPatExpr' _ EString{..}               = do
    i <- get
    put $ i+1
    let vname = pp $ "_" <> pp i
    return (vname, "*" <> vname <+> "==" <+> "\"" <> pp exprString <> "\"" <> ".to_string()")
mkPatExpr' _ EBit{..} | exprWidth <= 64= return (pp exprIVal, empty)
mkPatExpr' _ EBit{..}                  = do
    i <- get
    put $ i+1
    let vname = pp $ "_" <> pp i
    return (vname, "*" <> vname <+> "==" <+> "Uint::parse_bytes(b\"" <> pp exprIVal <> "\", 10)")
mkPatExpr' d EStruct{..}               = return (e, cond)
    where
    struct_name = name $ consType d exprConstructor
    e = pp struct_name <> "::" <> pp exprConstructor <> "{" <>
        (hsep $ punctuate comma $ map (\(fname, (e, _)) -> pp fname <> ":" <+> e) exprStructFields) <>
        "}"
    cond = hsep $ intersperse "&&" $ map (\(_,(_,c)) -> c) exprStructFields
mkPatExpr' d ETuple{..}                = return (e, cond)
    where
    e = "(" <> (hsep $ punctuate comma $ map (pp . fst) exprTupleFields) <> ")"
    cond = hsep $ intersperse "&&" $ map (pp . snd) exprTupleFields
mkPatExpr' _ EPHolder{}                = return ("_", empty)
mkPatExpr' _ ETyped{..}                = return exprExpr
