{-
Copyright (c) 2018-2020 VMware, Inc.
SPDX-License-Identifier: MIT

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-}

{-# LANGUAGE RecordWildCards, LambdaCase, FlexibleContexts, OverloadedStrings, QuasiQuotes, ImplicitParams, TupleSections #-}

{- |
Module     : OVSDB.Compile
Description: Compile 'OVSDB schema' to DDlog.
-}

module Language.DifferentialDatalog.OVSDB.Compile (compileSchema, compileSchemaFile) where

import Prelude hiding((<>), readFile, writeFile)
import Text.PrettyPrint
import Text.RawString.QQ
import Data.Word
import Data.Maybe
import Data.Char
import Data.List

import Language.DifferentialDatalog.OVSDB.Parse
import Language.DifferentialDatalog.Parse
import Language.DifferentialDatalog.Util
import Language.DifferentialDatalog.Name
import Language.DifferentialDatalog.Pos
import Language.DifferentialDatalog.PP
import Language.DifferentialDatalog.Error
import Control.Monad.Except

{-
The compiler generates 5 kinds of DDlog tables: Input, Output, Delta+, Delta-, DeltaUpdate:

Input: input tables that have the same schema as corresponding OVSDB tables

Output: these are the tables computed by DDlog program.  They have the same
    schema as corresponding OVSDB tables.

Delta+: new records to be inserted to OVSDB.
Delta-: records to be deleted from OVSDB.
DeltaUpdate: records to be modified in OVSDB.

The last three tables are generated by comparing input and output tables.  If a record
with a given UUID exists in the input table, but not the output table, this record must
be deleted.  UUIDs found in the output table, but not the input table, must be created.
Records present in both tables with the same UUID but different values in other columns
must be updated.

Note that the user must only provide rules to compute Output relations based on Input
relations; the compiler generates rules to compute all other relations.

The following diagram illustrates dependencies among these relations.

      (user-defined rules)
Input--------------------> Output------> Delta+
                              |
                              |------------> Delta-
                              |
                              +----------> DeltaUpdate
-}

data TableKind = TableInput
               | TableOutput
               | TableDeltaPlus
               | TableDeltaMinus
               | TableDeltaUpdate
               deriving(Eq)

builtins :: String
builtins = [r|import ovsdb
|]

mkTableName :: (?schema::OVSDBSchema, ?outputs::[(String, [String])]) => Table -> TableKind -> Doc
mkTableName t tkind =
    case tkind of
         TableInput       -> pp $ name t
         TableOutput      -> "Out_" <> (pp $ name t)
         TableDeltaPlus   -> "DeltaPlus_" <> (pp $ name t)
         TableDeltaMinus  -> "DeltaMinus_" <> (pp $ name t)
         TableDeltaUpdate -> "Update_" <> (pp $ name t)

compileSchemaFile :: FilePath -> [(String, [String])] -> IO Doc
compileSchemaFile fname outputs = do
    content <- readFile fname
    schema <- case parseSchema content fname of
                   Left  e    -> errorWithoutStackTrace $ "Failed to parse input file: " ++ e
                   Right prog -> return prog
    case compileSchema schema outputs of
         Left e    -> errorWithoutStackTrace e
         Right doc -> return doc

compileSchema :: (MonadError String me) => OVSDBSchema -> [(String, [String])] -> me Doc
compileSchema schema outputs = do
    let tables = schemaTables schema
    mapM_ (\(o, _) -> do let t = find ((==o) . name) tables
                         when (isNothing t) $ throwError $ "Table " ++ o ++ " not found") outputs
    uniqNames Nothing ("Multiple declarations of table " ++ ) tables
    let ?schema = schema
    let ?outputs = outputs
    rels <- ((\(inp, outp, priv) -> vcat
                                    $ ["/* Input relations */\n"] ++ inp ++
                                      ["\n/* Output relations */\n"] ++ outp ++
                                      ["\n/* Delta tables definitions */\n"] ++ priv) . unzip3) <$>
            mapM (\t -> mkTable (isNothing $ lookup (name t) outputs) t) tables
    return $ pp builtins $+$ "" $+$ rels

mkTable :: (?schema::OVSDBSchema, ?outputs::[(String, [String])], MonadError String me) => Bool -> Table  -> me (Doc, Doc, Doc)
mkTable isinput t@Table{..} = do
    ovscols <- tableCheckCols t
    maybe (return ())
          (\rocols -> mapM_ (\c -> when (isNothing $ find ((== c) . name) (tableGetCols t))
                                        $ throwError $ "Column " ++ c ++ " not found in table " ++ name t) rocols)
          $ lookup (name t) ?outputs
    uniqNames Nothing (\col -> "Multiple declarations of column " ++ col ++ " in table " ++ tableName) ovscols
    if isinput
       then (, empty, empty) <$> mkTable' TableInput t
       else do output           <- mkTable' TableOutput         t
               input            <- mkTable' TableInput          t
               delta_plus       <- mkTable' TableDeltaPlus      t
               let delta_plus_rules = mkDeltaPlusRules          t
               delta_minus      <- mkTable' TableDeltaMinus     t
               let delta_minus_rules = mkDeltaMinusRules        t
               delta_update     <- mkTable' TableDeltaUpdate    t
               let delta_update_rules = mkDeltaUpdateRules      t
               return $ (empty,
                         output,
                         delta_plus          $+$
                         delta_plus_rules    $+$
                         delta_minus         $+$
                         delta_minus_rules   $+$
                         delta_update        $+$
                         delta_update_rules  $+$
                         input)

mkTable' :: (?schema::OVSDBSchema, ?outputs::[(String, [String])], MonadError String me) => TableKind -> Table -> me Doc
mkTable' tkind t@Table{..} = do
    let ovscols = tableGetCols t
    let writable_cols = tableGetNonROCols t
    let prefix = case tkind of
                      TableInput       -> "input"
                      TableDeltaPlus   -> "output"
                      TableDeltaMinus  -> "output"
                      TableDeltaUpdate -> "output"
                      TableOutput      -> empty
    let tname = mkTableName t tkind
    let cols = case tkind of
                    TableInput       -> ovscols
                    TableDeltaPlus   -> writable_cols
                    TableDeltaMinus  -> [uuidCol]
                    TableDeltaUpdate -> writable_cols
                    TableOutput      -> writable_cols
    columns <- mapM (mkCol tkind tableName) cols
    let key = if tkind == TableInput
                 then "primary key (x) x._uuid"
                 else empty
    return $ prefix <+> "relation" <+> pp tname <+> "("    $$
             (nest' $ vcommaSep columns)                   $$
             ")"                                           $$
             key

mkDeltaPlusRules :: (?schema::OVSDBSchema, ?outputs::[(String, [String])]) => Table -> Doc
mkDeltaPlusRules t@Table{..} =
    (mkTableName t TableDeltaPlus) <> "(" <> commaSep cols <> ") :-"        $$
    (nest' $ mkTableName t TableOutput <> "(" <> commaSep cols <> "),")     $$
    (nest' $ "not" <+> mkTableName t TableInput <> "(._uuid = _uuid).")
    where
    nonro_cols = tableGetNonROCols t
    cols = map (\c -> "." <> mkColName c <+> "=" <+> mkColName c) nonro_cols

-- DeltaMinus(uuid) :- Input(uuid, key, _), not Output(_, key, _).
mkDeltaMinusRules :: (?schema::OVSDBSchema, ?outputs::[(String, [String])]) => Table ->  Doc
mkDeltaMinusRules t@Table{..} =
    (mkTableName t TableDeltaMinus) <> "(uuid) :-"                         $$
    (nest' $ mkTableName t TableInput <> "(._uuid = uuid),")   $$
    (nest' $ "not" <+> mkTableName t TableOutput <> "(._uuid = uuid).")

-- DeltaUpdate(uuid, new) :- Output(uuid, new), Input(uuid, old), old != new.
mkDeltaUpdateRules :: (?schema::OVSDBSchema, ?outputs::[(String, [String])]) => Table -> Doc
mkDeltaUpdateRules t@Table{..} =
    (mkTableName t TableDeltaUpdate) <> "(" <> commaSep outcols <> ") :-"               $$
    (nest' $ mkTableName t TableOutput <> "(" <> commaSep outcols <> "),")              $$
    (nest' $ mkTableName t TableInput <> "(" <> commaSep realcols <> "),")              $$
    (nest' $ (parens $ commaSep old_vars) <+> "!=" <+> (parens $ commaSep new_vars) <> ".")
    where
    nonro_cols = tableGetNonROCols t
    outcols = map (\c -> let n = mkColName c in
                         "." <> n <+> "=" <+> (if n == "_uuid" then n else "__new_" <> n))
                  nonro_cols
    realcols = map (\c -> let n = mkColName c in
                         "." <> n <+> "=" <+> (if n == "_uuid" then n else "__old_" <> n))
                  nonro_cols
    new_vars = map (\c -> let n = mkColName c in
                          if n == "_uuid" then n else "__new_" <> n)
                  nonro_cols
    old_vars = map (\c -> let n = mkColName c in
                          if n == "_uuid" then n else "__old_" <> n)
                  nonro_cols

mkCol :: (?schema::OVSDBSchema, ?outputs::[(String, [String])], MonadError String me) => TableKind -> String -> TableColumn -> me Doc
mkCol tkind tname c@TableColumn{..} = do
    checkNoProg (not $ elem columnName __reservedNames) (pos c) $ "Illegal column name " ++ columnName ++ " in table " ++ tname
    t <- case columnType of
              ColumnTypeAtomic at  -> mkAtomicType at
              ColumnTypeComplex ct -> mkComplexType tkind ct
              ColumnTypeUndefined  -> error "OVSDB.Compile.mkCol: undefine column type"
    return $ mkColName c <> ":" <+> t

__reservedNames :: [String]
__reservedNames = map (("__" ++) . map toLower) $ reservedNames

mkColName :: TableColumn -> Doc
mkColName c = mkColName' $ name c

mkColName' :: String -> Doc
mkColName' c =
    if elem x reservedNames
       then pp $ "__" ++ x
       else pp x
    where x = map toLower c


mkAtomicType :: (MonadError String me) => AtomicType -> me Doc
mkAtomicType IntegerType{}          = return "integer"
mkAtomicType RealType{}             = return "double"
mkAtomicType BooleanType{}          = return "bool"
mkAtomicType StringType{}           = return "string"
mkAtomicType UUIDType{}             = return "uuid"
mkAtomicType UndefinedAtomicType{}  = error "OVSDB.Compile.mkAtomicType: undefined atomic type"

complexTypeBounds :: ComplexType -> (Integer, Integer)
complexTypeBounds ComplexType{..} = (min_bound, max_bound)
    where
    min_bound = maybe 1 id minComplexType
    max_bound = maybe 1
                (\case
                  Some x    -> x
                  Unlimited -> fromIntegral (maxBound::Word64))
                maxComplexType

mkComplexType :: (?schema::OVSDBSchema, ?outputs::[(String, [String])], MonadError String me) => TableKind -> ComplexType -> me Doc
mkComplexType tkind t@ComplexType{..} = do
    let (min_bound, max_bound) = complexTypeBounds t
    checkNoProg (max_bound >= min_bound) (pos t) $ "min bound exceeds max bound"
    checkNoProg (min_bound == 0 || min_bound == 1) (pos t) $ "min bound must be 0 or 1"
    checkNoProg (max_bound > 0) (pos t) $ "max bound must be greater than 0"
    checkNoProg (max_bound /= 1 || isNothing valueComplexType) (pos t)
          $ "Cannot handle key-value pairs when max bound is 1"
    key <- mkBaseType tkind keyComplexType
    case (min_bound, max_bound) of
         (1,1) -> return key
         --(0,1) -> return $ "option_t<" <> key <> ">"
         _     -> do
             case valueComplexType of
                  Nothing -> return $ "Set<" <> key <> ">"
                  Just v  -> do vt <- mkBaseType tkind v
                                return $ "Map<" <> key <> "," <> vt <> ">"

mkBaseType :: (?schema::OVSDBSchema, ?outputs::[(String, [String])], MonadError String me) =>  TableKind -> BaseType -> me Doc
mkBaseType _     (BaseTypeSimple at)   = mkAtomicType at
mkBaseType _     (BaseTypeComplex cbt) | isJust (refTableBaseType cbt)
                                       = return "uuid"
mkBaseType _     (BaseTypeComplex cbt) = mkAtomicType $ typeBaseType cbt
mkBaseType _     BaseTypeUndefined     = error "OVSDB.Compile.mkBaseType: undefined base type"

tableCheckCols :: (MonadError String me) => Table -> me [TableColumn]
tableCheckCols t@Table{..} = do
    let tprops = filter (\case
                          ColumnsProperty{} -> True
                          _                 -> False) tableProperties
    checkNoProg (not $ null tprops) (pos t) $ "Table " ++ tableName ++ " does not have a \"columns\" property"
    checkNoProg (length tprops == 1) (pos t) $ "Table " ++ tableName ++ " has multiple \"columns\" properties"
    let (ColumnsProperty ovscols) : _ = tprops
    return ovscols

tableGetCols :: Table -> [TableColumn]
tableGetCols Table{..} = uuidCol:ovscols
    where
    (ColumnsProperty ovscols) : _ = filter (\case
                                             ColumnsProperty{} -> True
                                             _                 -> False) tableProperties

uuidCol :: TableColumn
uuidCol = TableColumn { columnPos       = nopos
                      , columnName      = "_uuid"
                      , columnType      = ColumnTypeAtomic (UUIDType nopos)
                      , columnEphemeral = Nothing
                      , columnMutable   = Nothing
                      }

tableGetNonROCols :: (?outputs::[(String, [String])]) => Table -> [TableColumn]
tableGetNonROCols t =
    case lookup (name t) ?outputs of
         Nothing -> ovscols
         Just ro -> filter (\col -> notElem (name col) ro) ovscols
    where
    ovscols = tableGetCols t
