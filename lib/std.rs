/// Rust implementation of DDlog standard library functions and types.

extern crate num;

use differential_datalog::arcval;
use differential_datalog::record::*;

use std::fmt::Display;
use std::fmt;
use std::hash::Hash;
use std::hash::Hasher;
use twox_hash::XxHash;
use std::vec;
use std::collections::btree_set;
use std::collections::btree_map;
use std::vec::{Vec};
use std::collections::{BTreeMap, BTreeSet};
use std::iter::FromIterator;
use std::ops;
use std::cmp;
use std::marker;
use std::slice;

/* FlatBuffers bindings generated by `ddlog` */
#[cfg(feature="flatbuf")]
use flatbuf::{FromFlatBuffer, ToFlatBuffer, ToFlatBufferTable, ToFlatBufferVectorElement, FBIter};

/* FlatBuffers runtime */
#[cfg(feature="flatbuf")]
use flatbuffers as fbrt;

const XX_SEED1: u64 = 0x23b691a751d0e108;
const XX_SEED2: u64 = 0x20b09801dce5ff84;

// Ref
pub type std_Ref<A> = arcval::ArcVal<A>;

pub fn std_ref_new<A: Clone>(x: &A) -> std_Ref<A> {
    arcval::ArcVal::from(x.clone())
}

pub fn std_deref<A: Clone>(x: &std_Ref<A>) -> &A {
    x.deref()
}

#[cfg(feature="flatbuf")]
impl <T,FB> FromFlatBuffer<FB> for std_Ref<T>
where
T: FromFlatBuffer<FB>
{
    fn from_flatbuf(fb: FB) -> Response<Self> {
        Ok(std_Ref::from(T::from_flatbuf(fb)?))
    }
}

#[cfg(feature="flatbuf")]
impl <'b, T> ToFlatBuffer<'b> for std_Ref<T>
where
T: ToFlatBuffer<'b>,
{
    type Target = T::Target;

    fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
        self.deref().to_flatbuf(fbb)
    }
}

#[cfg(feature="flatbuf")]
impl <'b, T> ToFlatBufferTable<'b> for std_Ref<T>
where
T: ToFlatBufferTable<'b>,
{
    type Target = T::Target;

    fn to_flatbuf_table(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> fbrt::WIPOffset<Self::Target> {
        self.deref().to_flatbuf_table(fbb)
    }
}

#[cfg(feature="flatbuf")]
impl <'b, T> ToFlatBufferVectorElement<'b> for std_Ref<T>
where
T: ToFlatBufferVectorElement<'b>,
{
    type Target = T::Target;

    fn to_flatbuf_vector_element(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
        self.deref().to_flatbuf_vector_element(fbb)
    }
}

// min/max
pub fn std_max<A: Ord + Clone>(x: &A, y: &A) -> A {
    if *x >= *y {
        x.clone()
    } else {
        y.clone()
    }
}

pub fn std_min<A: Ord + Clone>(x: &A, y: &A) -> A {
    if *x <= *y {
        x.clone()
    } else {
        y.clone()
    }
}

// Arithmetic functions
pub fn std_pow32<T: num::One + ops::Mul + Clone>(base: &T, exp: &u32) -> T {
    num::pow::pow(base.clone(), *exp as usize)
}

// Option
pub fn option2std<T: Clone>(x: Option<T>) -> std_Option<T> {
    match x {
        None => std_Option::std_None,
        Some(v) => std_Option::std_Some{x: v}
    }
}

// Range
pub fn std_range<A: Clone + Ord + ops::Add<Output = A> + PartialOrd>(from: &A, to: &A, step: &A) -> std_Vec<A> {
    let mut vec = std_Vec::new();
    let mut x = from.clone();
    while x <= *to {
        vec.push(x.clone());
        x = x + step.clone();
    };
    vec
}

// Vector

#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug, Default)]
pub struct std_Vec<T> {
    pub x: Vec<T>
}

/* This is needed so we can support for-loops over `Vec`'s
 */
pub struct VecIter<'a, X> {
    iter: slice::Iter<'a, X>
}

impl<'a, X> VecIter<'a, X> {
    pub fn new(vec: &'a std_Vec<X>) -> VecIter<'a, X> {
        VecIter{iter: vec.x.iter()}
    }
}

impl<'a, X> Iterator for VecIter<'a, X> {
    type Item = &'a X;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

impl <'a, T> std_Vec<T> {
    pub fn iter(&'a self) -> VecIter<'a, T> {
        VecIter::new(self)
    }
}

impl <T> std_Vec<T> {
    pub fn new() -> Self {
        std_Vec{x: Vec::new()}
    }
    pub fn with_capacity(capacity: usize) -> Self {
        std_Vec{x: Vec::with_capacity(capacity)}
    }
    pub fn push(&mut self, v: T) {
        self.x.push(v);
    }
}

impl <T: Clone> std_Vec<T> {
    pub fn extend_from_slice(&mut self, other: &[T]) {
        self.x.extend_from_slice(other);
    }
}

impl<T: FromRecord> FromRecord for std_Vec<T> {
    fn from_record(val: &Record) -> Result<Self, String> {
        Vec::from_record(val).map(|x|std_Vec{x})
    }
}

impl<T: IntoRecord> IntoRecord for std_Vec<T> {
    fn into_record(self) -> Record {
        self.x.into_record()
    }
}

impl<T: FromRecord> Mutator<std_Vec<T>> for Record
{
    fn mutate(&self, vec: &mut std_Vec<T>) -> Result<(), String> {
        self.mutate(&mut vec.x)
    }
}

impl<T: Display> Display for std_Vec<T> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let len = self.x.len();
        formatter.write_str("[")?;
        for (i, v) in self.x.iter().enumerate() {
            formatter.write_fmt(format_args!("{}", *v))?;
            if i < len-1 {
                formatter.write_str(",")?;
            }
        }
        formatter.write_str("]")?;
        Ok(())
    }
}

impl<T> IntoIterator for std_Vec<T> {
    type Item = T;
    type IntoIter = vec::IntoIter<T>;
    fn into_iter(self) -> Self::IntoIter {
        self.x.into_iter()
    }
}


#[cfg(feature="flatbuf")]
impl <'a,T,F> FromFlatBuffer<fbrt::Vector<'a,F>> for std_Vec<T>
where
T: Ord+FromFlatBuffer<F::Inner>,
F: fbrt::Follow<'a> + 'a,
{
    fn from_flatbuf(fb: fbrt::Vector<'a,F>) -> Response<Self> {
        let mut vec = std_Vec::with_capacity(fb.len());
        for x in FBIter::from_vector(fb) {
            vec.push(T::from_flatbuf(x)?);
        };
        Ok(vec)
    }
}

// For scalar types, the FlatBuffers API returns slice instead of 'Vector'.
#[cfg(feature="flatbuf")]
impl <'a,T> FromFlatBuffer<&'a [T]> for std_Vec<T>
where
T: Clone
{
    fn from_flatbuf(fb: &'a [T]) -> Response<Self> {
        let mut vec = std_Vec::with_capacity(fb.len());
        vec.extend_from_slice(fb);
        Ok(vec)
    }
}

#[cfg(feature="flatbuf")]
impl <'b, T> ToFlatBuffer<'b> for std_Vec<T>
where
T: ToFlatBufferVectorElement<'b>,
{
    type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T::Target as fbrt::Push>::Output>>;

    fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
        let vec: Vec<T::Target> = self.iter().map(|x|x.to_flatbuf_vector_element(fbb)).collect();
        fbb.create_vector(vec.as_slice())
    }
}

pub fn std_vec_len<X: Ord + Clone>(v: &std_Vec<X>) -> u64 {
    v.x.len() as u64
}

pub fn std_vec_empty<X: Ord + Clone>() -> std_Vec<X> {
    std_Vec::new()
}

pub fn std_vec_singleton<X: Ord + Clone>(x: &X) -> std_Vec<X> {
    std_Vec{x: vec![x.clone()]}
}

pub fn std_vec_push<X: Ord+Clone>(v: &mut std_Vec<X>, x: &X) {
    v.push((*x).clone());
}

pub fn std_vec_push_imm<X: Ord+Clone>(v: &std_Vec<X>, x: &X) -> std_Vec<X> {
    let mut v2 = v.clone();
    v2.push((*x).clone());
    v2
}

pub fn std_vec_contains<X: Ord>(v: &std_Vec<X>, x: &X) -> bool {
    v.x.contains(x)
}

pub fn std_vec_is_empty<X: Ord>(v: &std_Vec<X>) -> bool {
    v.x.is_empty()
}

pub fn std_vec_nth<X: Ord + Clone>(v: &std_Vec<X>, n: &u64) -> std_Option<X> {
    option2std(v.x.get(*n as usize).cloned())
}

pub fn std_vec2set<X: Ord + Clone>(s: &std_Vec<X>) -> std_Set<X> {
    std_Set{x: s.x.iter().cloned().collect()}
}

// Set

#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug, Default)]
pub struct std_Set<T: Ord> {
    pub x: BTreeSet<T>
}

/* This is needed so we can support for-loops over `Set`'s
 */
pub struct SetIter<'a, X> {
    iter: btree_set::Iter<'a, X>
}

impl<'a, X: Ord> SetIter<'a, X> {
    pub fn new(set: &'a std_Set<X>) -> SetIter<'a, X> {
        SetIter{iter: set.x.iter()}
    }
}

impl<'a, X> Iterator for SetIter<'a, X> {
    type Item = &'a X;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

impl <'a, T: Ord> std_Set<T> {
    pub fn iter(&'a self) -> SetIter<'a, T> {
        SetIter::new(self)
    }
}

impl <T: Ord> std_Set<T> {
    pub fn new() -> Self {
        std_Set{x: BTreeSet::new()}
    }
    pub fn insert(&mut self, v: T) {
        self.x.insert(v);
    }
}

impl<T: FromRecord + Ord> FromRecord for std_Set<T> {
    fn from_record(val: &Record) -> Result<Self, String> {
        BTreeSet::from_record(val).map(|x|std_Set{x})
    }
}

impl<T: IntoRecord + Ord> IntoRecord for std_Set<T> {
    fn into_record(self) -> Record {
        self.x.into_record()
    }
}

impl<T: FromRecord + Ord> Mutator<std_Set<T>> for Record
{
    fn mutate(&self, set: &mut std_Set<T>) -> Result<(), String> {
        self.mutate(&mut set.x)
    }
}

impl<T: Ord> IntoIterator for std_Set<T> {
    type Item = T;
    type IntoIter = btree_set::IntoIter<T>;
    fn into_iter(self) -> Self::IntoIter {
        self.x.into_iter()
    }
}

impl<T: Ord> FromIterator<T> for std_Set<T> {
    fn from_iter<I>(iter: I) -> Self
    where I: IntoIterator<Item = T>
    {
        std_Set{x: BTreeSet::from_iter(iter)}
    }
}

impl<T: Display + Ord> Display for std_Set<T> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let len = self.x.len();
        formatter.write_str("[")?;
        for (i, v) in self.x.iter().enumerate() {
            formatter.write_fmt(format_args!("{}", *v))?;
            if i < len-1 {
                formatter.write_str(",")?;
            }
        }
        formatter.write_str("]")?;
        Ok(())
    }
}

#[cfg(feature="flatbuf")]
impl <'a,T,F> FromFlatBuffer<fbrt::Vector<'a,F>> for std_Set<T>
where
T: Ord+FromFlatBuffer<F::Inner>,
F: fbrt::Follow<'a> + 'a,
{
    fn from_flatbuf(fb: fbrt::Vector<'a,F>) -> Response<Self> {
        let mut set = std_Set::new();
        for x in FBIter::from_vector(fb) {
            set.insert(T::from_flatbuf(x)?);
        };
        Ok(set)
    }
}

// For scalar types, the FlatBuffers API returns slice instead of 'Vector'.
#[cfg(feature="flatbuf")]
impl <'a,T> FromFlatBuffer<&'a [T]> for std_Set<T>
where
T: Ord + Clone
{
    fn from_flatbuf(fb: &'a [T]) -> Response<Self> {
        let mut set = std_Set::new();
        for x in fb.iter() {
            set.insert(x.clone());
        };
        Ok(set)
    }
}

#[cfg(feature="flatbuf")]
impl <'b, T> ToFlatBuffer<'b> for std_Set<T>
where
T: Ord + ToFlatBufferVectorElement<'b>,
{
    type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T::Target as fbrt::Push>::Output>>;

    fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
        let vec: Vec<T::Target> = self.iter().map(|x|x.to_flatbuf_vector_element(fbb)).collect();
        fbb.create_vector(vec.as_slice())
    }
}

pub fn std_set_size<X: Ord + Clone>(s: &std_Set<X>) -> u64 {
    s.x.len() as u64
}

pub fn std_set_empty<X: Ord + Clone>() -> std_Set<X> {
    std_Set::new()
}

pub fn std_set_singleton<X: Ord + Clone>(v: &X) -> std_Set<X> {
    let mut s = std_Set::new();
    s.insert(v.clone());
    s
}

pub fn std_set_insert<X: Ord+Clone>(s: &mut std_Set<X>, v: &X) {
    s.x.insert((*v).clone());
}

pub fn std_set_insert_imm<X: Ord+Clone>(s: &std_Set<X>, v: &X) -> std_Set<X> {
    let mut s2 = s.clone();
    s2.insert((*v).clone());
    s2
}

pub fn std_set_contains<X: Ord>(s: &std_Set<X>, v: &X) -> bool {
    s.x.contains(v)
}

pub fn std_set_is_empty<X: Ord>(s: &std_Set<X>) -> bool {
    s.x.is_empty()
}

pub fn std_set_nth<X: Ord + Clone>(s: &std_Set<X>, n: &u64) -> std_Option<X> {
    option2std(s.x.iter().nth(*n as usize).cloned())
}

pub fn std_set2vec<X: Ord + Clone>(s: &std_Set<X>) -> std_Vec<X> {
    std_Vec{x: s.x.iter().cloned().collect()}
}

pub fn std_set_union<X: Ord + Clone>(s1: &std_Set<X>, s2: &std_Set<X>) -> std_Set<X> {
    let mut s = s1.clone();
    s.x.append(&mut s2.x.clone());
    s
}

pub fn std_set_unions<X: Ord + Clone>(sets: &std_Vec<std_Set<X>>) -> std_Set<X> {
    let mut s = BTreeSet::new();
    for si in sets.x.iter() {
        s.append(&mut si.x.clone());
    };
    std_Set{x: s}
}


// Map

#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug, Default)]
pub struct std_Map<K: Ord,V> {
    pub x: BTreeMap<K,V>
}

/* This is needed so we can support for-loops over `Map`'s
 */
pub struct MapIter<'a, K, V> {
    iter: btree_map::Iter<'a, K, V>
}

impl<'a, K: Ord, V> MapIter<'a, K, V> {
    pub fn new(map: &'a std_Map<K, V>) -> MapIter<'a, K, V> {
        MapIter{iter: map.x.iter()}
    }
}

impl<'a, K, V> Iterator for MapIter<'a, K, V> {
    type Item = (&'a K, &'a V);

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

impl <'a, K: Ord, V> std_Map<K, V> {
    pub fn iter(&'a self) -> MapIter<'a, K, V> {
        MapIter::new(self)
    }
}

impl <K: Ord, V> std_Map<K,V> {
    pub fn new() -> Self {
        std_Map{x: BTreeMap::new()}
    }
    pub fn insert(&mut self, k: K, v: V) {
        self.x.insert(k,v);
    }
}

impl<K: FromRecord+Ord, V: FromRecord> FromRecord for std_Map<K,V> {
    fn from_record(val: &Record) -> Result<Self, String> {
        BTreeMap::from_record(val).map(|x|std_Map{x})
    }
}

impl<K: IntoRecord + Ord, V: IntoRecord> IntoRecord for std_Map<K,V> {
    fn into_record(self) -> Record {
        self.x.into_record()
    }
}

impl<K: FromRecord + Ord, V: FromRecord + PartialEq> Mutator<std_Map<K,V>> for Record
{
    fn mutate(&self, map: &mut std_Map<K,V>) -> Result<(), String> {
        self.mutate(&mut map.x)
    }
}

impl<K: Ord,V> IntoIterator for std_Map<K,V> {
    type Item = (K,V);
    type IntoIter = btree_map::IntoIter<K,V>;
    fn into_iter(self) -> Self::IntoIter {
        self.x.into_iter()
    }
}

impl<K: Ord, V> FromIterator<(K,V)> for std_Map<K,V> {
    fn from_iter<I>(iter: I) -> Self
    where I: IntoIterator<Item = (K,V)>
    {
        std_Map{x: BTreeMap::from_iter(iter)}
    }
}

impl<K: Display+Ord, V: Display> Display for std_Map<K,V> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        let len = self.x.len();
        formatter.write_str("[")?;
        for (i, (k,v)) in self.x.iter().enumerate() {
            formatter.write_fmt(format_args!("({},{})", *k, *v))?;
            if i < len-1 {
                formatter.write_str(",")?;
            }
        }
        formatter.write_str("]")?;
        Ok(())
    }
}

#[cfg(feature="flatbuf")]
impl <'a,K,V,F> FromFlatBuffer<fbrt::Vector<'a,F>> for std_Map<K,V>
where
F: fbrt::Follow<'a> + 'a,
K: Ord,
(K,V): FromFlatBuffer<F::Inner>
{
    fn from_flatbuf(fb: fbrt::Vector<'a,F>) -> Response<Self> {
        let mut m = std_Map::new();
        for x in FBIter::from_vector(fb) {
            let (k,v) = <(K,V)>::from_flatbuf(x)?;
            m.insert(k,v);
        };
        Ok(m)
    }
}

#[cfg(feature="flatbuf")]
impl <'b, K, V, T> ToFlatBuffer<'b> for std_Map<K, V>
where
K: Ord + Clone,
V: Clone,
(K,V): ToFlatBufferVectorElement<'b, Target=T>,
T: 'b + fbrt::Push + Copy
{
    type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T as fbrt::Push>::Output>>;

    fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
        let vec: Vec<<(K,V) as ToFlatBufferVectorElement<'b>>::Target> =
            self.iter().map(|(k,v)|((*k).clone(), (*v).clone()).to_flatbuf_vector_element(fbb)).collect();
        fbb.create_vector(vec.as_slice())
    }
}

pub fn std_map_empty<K: Ord + Clone,V: Clone>() -> std_Map<K, V> {
    std_Map::new()
}

pub fn std_map_singleton<K: Ord + Clone,V: Clone>(k: &K, v: &V) -> std_Map<K, V> {
    let mut m = std_Map::new();
    m.insert(k.clone(), v.clone());
    m
}

pub fn std_map_insert<K: Ord+Clone, V: Clone>(m: &mut std_Map<K,V>, k: &K, v: &V) {
    m.x.insert((*k).clone(), (*v).clone());
}

pub fn std_map_remove<K: Ord+Clone, V: Clone>(m: &mut std_Map<K,V>, k: &K) {
    m.x.remove(k);
}

pub fn std_map_insert_imm<K: Ord+Clone, V: Clone>(m: &std_Map<K,V>, k: &K, v: &V) -> std_Map<K,V> {
    let mut m2 = m.clone();
    m2.insert((*k).clone(), (*v).clone());
    m2
}

pub fn std_map_get<K: Ord, V: Clone>(m: &std_Map<K,V>, k: &K) -> std_Option<V> {
    option2std(m.x.get(k).cloned())
}

pub fn std_map_contains_key<K: Ord, V: Clone>(s: &std_Map<K,V>, k: &K) -> bool {
    s.x.contains_key(k)
}

pub fn std_map_is_empty<K: Ord, V: Clone>(m: &std_Map<K,V>) -> bool {
    m.x.is_empty()
}

pub fn std_map_union<K: Ord + Clone,V: Clone>(m1: &std_Map<K,V>, m2: &std_Map<K,V>) -> std_Map<K, V> {
    let mut m = m1.clone();
    m.x.append(&mut m2.x.clone());
    m
}


// strings

pub fn std___builtin_2string<T: Display>(x: &T) -> String {
    format!("{}", *x).to_string()
}

pub fn std_hex<T: fmt::LowerHex>(x: &T) -> String {
    format!("{:x}", *x).to_string()
}

pub fn std_parse_dec_u64(s: &String) -> std_Option<u64> {
    option2std(s.parse::<u64>().ok())
}

pub fn std_parse_dec_i64(s: &String) -> std_Option<i64> {
    option2std(s.parse::<i64>().ok())
}

pub fn std_string_join(strings: &std_Vec<String>, sep: &String) -> String {
    strings.x.join(sep.as_str())
}

pub fn std_string_split(s: &String, sep: &String) -> std_Vec<String> {
    std_Vec{x: s.split(sep).map(|x| x.to_owned()).collect()}
}

pub fn std_string_contains(s1: &String, s2: &String) -> bool {
    s1.contains(s2.as_str())
}

pub fn std_string_substr(s: &String, start: &u64, end: &u64) -> String {
    let len = s.len();
    let from = cmp::min(*start as usize, len);
    let to = cmp::max(from, cmp::min(*end as usize, len));
    s[from..to].to_string()
}

pub fn std_string_len(s: &String) -> u64 {
    s.len() as u64
}

pub fn std_str_to_lower(s: &String) -> String {
    s.to_lowercase()
}

// Hashing

pub fn std_hash64<T: Hash>(x: &T) -> u64 {
    let mut hasher = XxHash::with_seed(XX_SEED1);
    x.hash(&mut hasher);
    hasher.finish()
}

pub fn std_hash128<T: Hash>(x: &T) -> u128 {
    let mut hasher = XxHash::with_seed(XX_SEED1);
    x.hash(&mut hasher);
    let w1 = hasher.finish();
    let mut hasher = XxHash::with_seed(XX_SEED2);
    x.hash(&mut hasher);
    let w2 = hasher.finish();
    ((w1 as u128) << 64) | (w2 as u128)
}

pub type ProjectFunc<X> = fn(&Value) -> X;

/*
 * Group type (used in aggregation operators)
 */
pub struct std_Group<'a, X> {
    /* TODO: remove "pub" */
    pub group: &'a [(&'a Value, Weight)],
    pub project: &'a ProjectFunc<X>
}

/* This is needed so we can support for-loops over `Group`'s
 */
pub struct GroupIter<'a, X> {
    iter: slice::Iter<'a, (&'a Value, Weight)>,
    project: &'a ProjectFunc<X>
}

impl<'a, X> GroupIter<'a, X> {
    pub fn new(grp: &std_Group<'a, X>) -> GroupIter<'a, X> {
        GroupIter{iter: grp.group.iter(), project: grp.project}
    }
}

impl<'a, X> Iterator for GroupIter<'a, X> {
    type Item = X;

    fn next(&mut self) -> Option<Self::Item> {
        match self.iter.next() {
            None => None,
            Some((x,_)) => Some((self.project)(x))
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

impl<'a, X> std_Group<'a, X> {
    pub fn new(group: &'a[(&'a Value, Weight)], project: &'static ProjectFunc<X>) -> std_Group<'a, X> {
        std_Group{group: group, project: project}
    }

    fn size(&self) -> u64 {
        self.group.len() as u64
    }

    fn first(&'a self) -> X {
        (self.project)(self.group[0].0)
    }

    fn nth_unchecked(&'a self, n: u64) -> X {
        (self.project)(self.group[n as usize].0)
    }

    pub fn iter(&'a self) -> GroupIter<'a, X> {
        GroupIter::new(self)
    }
}

impl<'a, X> std_Group<'a, X> {
    fn nth(&'a self, n: u64) -> std_Option<X> {
        if self.size() > n {
            std_Option::std_Some{x: (self.project)(self.group[n as usize].0)}
        } else {
            std_Option::std_None
        }
    }
}

/*
 * Standard aggregation function
 */
pub fn std_group_count<A>(g: &std_Group<A>) -> u64 {
    g.size()
}

pub fn std_group_first<A>(g: &std_Group<A>) -> A {
    g.first()
}

pub fn std_group_nth<A>(g: &std_Group<A>, n: &u64) -> std_Option<A> {
    g.nth(*n)
}

pub fn std_group2set<A: Ord + Clone>(g: &std_Group<A>) -> std_Set<A> {
    let mut res = std_Set::new();
    for v in g.iter() {
        std_set_insert(&mut res, &v);
    };
    res
}

pub fn std_group_set_unions<A: Ord + Clone>(g: &std_Group<std_Set<A>>) -> std_Set<A>
{
    let mut res = std_Set::new();
    for gr in g.iter() {
        for v in gr.iter() {
           std_set_insert(&mut res, v);
        }
    };
    res
}

pub fn std_group_setref_unions<A: Ord + Clone>(g: &std_Group<std_Ref<std_Set<A>>>)
    -> std_Ref<std_Set<A>>
{
    if g.size() == 1 {
        g.first()
    } else {
        let mut res: std_Ref<std_Set<A>> = std_ref_new(&std_Set::new());
        {
            let mut rres = std_Ref::get_mut(&mut res).unwrap();
            for gr in g.iter() {
                for v in gr.iter() {
                    std_set_insert(&mut rres, &v);
                }
            };
        }
        res
    }
}

pub fn std_group2vec<A: Ord + Clone>(g: &std_Group<A>) -> std_Vec<A>
{
    let mut res = std_Vec::with_capacity(g.size() as usize);
    for v in g.iter() {
        std_vec_push(&mut res, &v);
    };
    res
}

pub fn std_group2map<K: Ord + Clone, V: Clone>(g: &std_Group<(K,V)>) -> std_Map<K,V>
{
    let mut res = std_Map::new();
    for (k, v) in g.iter() {
        std_map_insert(&mut res, &k, &v);
    };
    res
}

pub fn std_group_min<A: Ord>(g: &std_Group<A>) -> A {
    g.iter().min().unwrap()
}

pub fn std_group_max<A: Ord>(g: &std_Group<A>) -> A {
    g.iter().max().unwrap()
}

pub fn std_group_sum<A: ops::Add + ops::AddAssign>(g: &std_Group<A>) -> A {
    let mut res = std_group_first(g);
    for v in g.iter().skip(1) {
        res += v;
    };
    res
}

/* Tuples */
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct tuple0;

impl FromRecord for tuple0 {
    fn from_record(val: &Record) -> Result<Self, String> {
        <()>::from_record(val).map(|_|tuple0)
    }
}

impl IntoRecord for tuple0 {
    fn into_record(self) -> Record {
        ().into_record()
    }
}

macro_rules! decl_tuple {
    ( $name:ident, $( $t:tt ),+ ) => {
        #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
        pub struct $name< $($t),* >($(pub $t),*);
        impl <$($t: FromRecord),*> FromRecord for $name<$($t),*> {
            fn from_record(val: &Record) -> Result<Self, String> {
                <($($t),*)>::from_record(val).map(|($($t),*)|$name($($t),*))
            }
        }

        impl <$($t: IntoRecord),*> IntoRecord for $name<$($t),*> {
            fn into_record(self) -> Record {
                let $name($($t),*) = self;
                Record::Tuple(vec![$($t.into_record()),*])
            }
        }

        impl <$($t: FromRecord),*> Mutator<$name<$($t),*>> for Record {
            fn mutate(&self, x: &mut $name<$($t),*>) -> Result<(), String> {
                *x = <$name<$($t),*>>::from_record(self)?;
                Ok(())
            }
        }
    };
}

decl_tuple!(tuple2,  T1, T2);
decl_tuple!(tuple3,  T1, T2, T3);
decl_tuple!(tuple4,  T1, T2, T3, T4);
decl_tuple!(tuple5,  T1, T2, T3, T4, T5);
decl_tuple!(tuple6,  T1, T2, T3, T4, T5, T6);
decl_tuple!(tuple7,  T1, T2, T3, T4, T5, T6, T7);
decl_tuple!(tuple8,  T1, T2, T3, T4, T5, T6, T7, T8);
decl_tuple!(tuple9,  T1, T2, T3, T4, T5, T6, T7, T8, T9);
decl_tuple!(tuple10, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
decl_tuple!(tuple11, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
decl_tuple!(tuple12, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);
decl_tuple!(tuple13, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);
decl_tuple!(tuple14, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);
decl_tuple!(tuple15, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);
decl_tuple!(tuple16, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);
decl_tuple!(tuple17, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17);
decl_tuple!(tuple18, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18);
decl_tuple!(tuple19, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19);
decl_tuple!(tuple20, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20);

// Endianness
pub fn std_ntohl(x: &u32) -> u32 {
    u32::from_be(*x)
}

pub fn std_ntohs(x: &u16) -> u16 {
    u16::from_be(*x)
}

pub fn std_htonl(x: &u32) -> u32 {
    u32::to_be(*x)
}

pub fn std_htons(x: &u16) -> u16 {
    u16::to_be(*x)
}
